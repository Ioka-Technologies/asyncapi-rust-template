{"version":3,"file":"index.js","sources":["../template/src/main.rs.js","../template/src/config.rs.js","../template/src/errors.rs.js","../template/src/models.rs.js","../template/src/handlers.rs.js","../template/src/context.rs.js","../template/src/router.rs.js","../template/src/server/mod.rs.js","../template/src/server/builder.rs.js","../template/src/middleware.rs.js","../template/src/recovery.rs.js","../template/src/auth/mod.rs.js","../template/src/auth/config.rs.js","../template/src/auth/jwt.rs.js","../template/src/auth/middleware.rs.js","../template/src/auth/rbac.rs.js","../template/src/transport/mod.rs.js","../template/src/transport/factory.rs.js","../template/src/transport/mqtt.rs.js","../template/src/transport/kafka.rs.js","../template/src/transport/amqp.rs.js","../template/src/transport/websocket.rs.js","../template/src/transport/http.rs.js","../template/index.js"],"sourcesContent":["export default function MainRs({ asyncapi, _params }) {\n    const info = asyncapi.info();\n    const title = info.title();\n\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    return (\n        <File name=\"main.rs\">\n            {`#![allow(dead_code, unused_imports)]\n\nuse crate::errors::AsyncApiResult;\nuse tracing::{info, warn, Level};\nuse tracing_subscriber;\nuse std::env;\n\n// Import modules\nmod config;\nmod server;\nmod models;\nmod handlers;\nmod middleware;\nmod errors;\nmod recovery;\nmod transport;\nmod context;\nmod router;\n#[cfg(feature = \"auth\")]\nmod auth;\n\nuse config::Config;\nuse server::Server;\n\n#[tokio::main]\nasync fn main() -> AsyncApiResult<()> {\n    // Initialize tracing with configurable level\n    let log_level = env::var(\"LOG_LEVEL\")\n        .unwrap_or_else(|_| \"info\".to_string())\n        .parse::<Level>()\n        .unwrap_or(Level::INFO);\n\n    tracing_subscriber::fmt()\n        .with_max_level(log_level)\n        .init();\n\n    info!(\"Starting ${title} server...\");\n    info!(\"Generated from AsyncAPI specification\");\n\n    // Load configuration\n    let config = Config::from_env()?;\n    info!(\"Server configuration: {:?}\", config);\n\n    // Initialize server\n    let server = Server::new(config).await?;\n\n    // Start protocol handlers\n    server.start_http_handler().await?;\n\n    info!(\"Server started successfully!\");\n    info!(\"Press Ctrl+C to shutdown\");\n\n    // Keep the server running\n    match tokio::signal::ctrl_c().await {\n        Ok(()) => {\n            info!(\"Received shutdown signal\");\n        }\n        Err(err) => {\n            warn!(\"Unable to listen for shutdown signal: {}\", err);\n        }\n    }\n\n    info!(\"Shutting down server...\");\n    server.shutdown().await?;\n\n    Ok(())\n}\n`}\n        </File>\n    );\n}\n","export default function ConfigRs({ asyncapi }) {\n    // Helper functions for Rust identifier generation\n    function toRustIdentifier(str) {\n        if (!str) return 'unknown';\n        let identifier = str\n            .replace(/[^a-zA-Z0-9_]/g, '_')\n            .replace(/^[0-9]/, '_$&')\n            .replace(/_+/g, '_')\n            .replace(/^_+|_+$/g, '');\n        if (/^[0-9]/.test(identifier)) {\n            identifier = 'item_' + identifier;\n        }\n        if (!identifier) {\n            identifier = 'unknown';\n        }\n        const rustKeywords = [\n            'as', 'break', 'const', 'continue', 'crate', 'else', 'enum', 'extern',\n            'false', 'fn', 'for', 'if', 'impl', 'in', 'let', 'loop', 'match',\n            'mod', 'move', 'mut', 'pub', 'ref', 'return', 'self', 'Self',\n            'static', 'struct', 'super', 'trait', 'true', 'type', 'unsafe',\n            'use', 'where', 'while', 'async', 'await', 'dyn'\n        ];\n        if (rustKeywords.includes(identifier)) {\n            identifier = identifier + '_';\n        }\n        return identifier;\n    }\n\n    function toRustTypeName(str) {\n        if (!str) return 'Unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .split('_')\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n\n    function toRustFieldName(str) {\n        if (!str) return 'unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .replace(/([A-Z])/g, '_$1')\n            .toLowerCase()\n            .replace(/^_/, '')\n            .replace(/_+/g, '_');\n    }\n\n    function getDefaultPort(protocol) {\n        switch (protocol?.toLowerCase()) {\n        case 'mqtt':\n        case 'mqtts':\n            return 1883;\n        case 'kafka':\n        case 'kafka-secure':\n            return 9092;\n        case 'amqp':\n        case 'amqps':\n            return 5672;\n        case 'ws':\n        case 'wss':\n            return 8080;\n        case 'http':\n            return 80;\n        case 'https':\n            return 443;\n        default:\n            return 8080;\n        }\n    }\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const serverConfigs = [];\n\n    if (servers) {\n        Object.entries(servers).forEach(([name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                serverConfigs.push({\n                    name,\n                    fieldName: toRustFieldName(name),\n                    typeName: toRustTypeName(name + '_config'),\n                    protocol: protocol.toLowerCase(),\n                    host: server.host && server.host(),\n                    description: server.description && server.description(),\n                    defaultPort: getDefaultPort(protocol)\n                });\n            }\n        });\n    }\n\n    return (\n        <File name=\"config.rs\">\n            {`//! Configuration management for the AsyncAPI server\n\nuse anyhow::Result;\nuse std::env;\nuse tracing::Level;\n\n/// Server configuration\n#[derive(Debug, Clone)]\npub struct Config {\n    pub host: String,\n    pub port: u16,\n    pub log_level: Level,\n    ${serverConfigs.map(server => `pub ${server.fieldName}_config: ${server.typeName},`).join('\\n    ')}\n}\n\n${serverConfigs.map(server => `\n/// Configuration for ${server.name} server\n#[derive(Debug, Clone)]\npub struct ${server.typeName} {\n    pub host: String,\n    pub port: u16,\n    pub protocol: String,\n}\n\nimpl Default for ${server.typeName} {\n    fn default() -> Self {\n        Self {\n            host: \"${server.host || 'localhost'}\".to_string(),\n            port: ${server.defaultPort},\n            protocol: \"${server.protocol}\".to_string(),\n        }\n    }\n}`).join('\\n')}\n\nimpl Config {\n    pub fn from_env() -> Result<Self> {\n        let host = env::var(\"SERVER_HOST\").unwrap_or_else(|_| \"0.0.0.0\".to_string());\n        let port = env::var(\"SERVER_PORT\")\n            .unwrap_or_else(|_| \"8080\".to_string())\n            .parse::<u16>()\n            .unwrap_or(8080);\n\n        let log_level = env::var(\"LOG_LEVEL\")\n            .unwrap_or_else(|_| \"info\".to_string())\n            .parse::<Level>()\n            .unwrap_or(Level::INFO);\n\n        Ok(Self {\n            host,\n            port,\n            log_level,\n            ${serverConfigs.map(server => `${server.fieldName}_config: ${server.typeName}::default(),`).join('\\n            ')}\n        })\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function ErrorsRs({ asyncapi }) {\n    // Detect protocols from servers for protocol-specific errors\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    return (\n        <File name=\"errors.rs\">\n            {`//! Comprehensive error handling system for AsyncAPI operations\n//!\n//! This module provides a hierarchical error system with:\n//! - Custom error types for different failure scenarios\n//! - Error context and correlation for debugging\n//! - Protocol-specific error handling\n//! - Error recovery and retry mechanisms\n//! - Structured error data for monitoring\n\nuse thiserror::Error;\nuse std::fmt;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n/// Correlation ID for tracing errors across operations\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CorrelationId(pub Uuid);\n\nimpl CorrelationId {\n    pub fn new() -> Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl fmt::Display for CorrelationId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl Default for CorrelationId {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Error severity levels for categorization and alerting\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ErrorSeverity {\n    /// Low severity - informational, no action required\n    Low,\n    /// Medium severity - warning, monitoring required\n    Medium,\n    /// High severity - error, immediate attention needed\n    High,\n    /// Critical severity - system failure, urgent action required\n    Critical,\n}\n\nimpl fmt::Display for ErrorSeverity {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorSeverity::Low => write!(f, \"LOW\"),\n            ErrorSeverity::Medium => write!(f, \"MEDIUM\"),\n            ErrorSeverity::High => write!(f, \"HIGH\"),\n            ErrorSeverity::Critical => write!(f, \"CRITICAL\"),\n        }\n    }\n}\n\n/// Error category for classification and handling\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ErrorCategory {\n    /// Configuration-related errors\n    Configuration,\n    /// Network and protocol errors\n    Network,\n    /// Message validation errors\n    Validation,\n    /// Business logic errors\n    BusinessLogic,\n    /// System resource errors\n    Resource,\n    /// Security-related errors\n    Security,\n    /// Serialization/deserialization errors\n    Serialization,\n    /// Routing errors\n    Routing,\n    /// Authorization errors\n    Authorization,\n    /// Unknown or unclassified errors\n    Unknown,\n}\n\nimpl fmt::Display for ErrorCategory {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorCategory::Configuration => write!(f, \"CONFIGURATION\"),\n            ErrorCategory::Network => write!(f, \"NETWORK\"),\n            ErrorCategory::Validation => write!(f, \"VALIDATION\"),\n            ErrorCategory::BusinessLogic => write!(f, \"BUSINESS_LOGIC\"),\n            ErrorCategory::Resource => write!(f, \"RESOURCE\"),\n            ErrorCategory::Security => write!(f, \"SECURITY\"),\n            ErrorCategory::Serialization => write!(f, \"SERIALIZATION\"),\n            ErrorCategory::Routing => write!(f, \"ROUTING\"),\n            ErrorCategory::Authorization => write!(f, \"AUTHORIZATION\"),\n            ErrorCategory::Unknown => write!(f, \"UNKNOWN\"),\n        }\n    }\n}\n\n/// Error metadata for enhanced context and monitoring\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ErrorMetadata {\n    pub correlation_id: CorrelationId,\n    pub severity: ErrorSeverity,\n    pub category: ErrorCategory,\n    pub timestamp: DateTime<Utc>,\n    pub retryable: bool,\n    pub source_location: Option<String>,\n    pub additional_context: std::collections::HashMap<String, String>,\n}\n\nimpl ErrorMetadata {\n    pub fn new(severity: ErrorSeverity, category: ErrorCategory, retryable: bool) -> Self {\n        Self {\n            correlation_id: CorrelationId::new(),\n            severity,\n            category,\n            timestamp: Utc::now(),\n            retryable,\n            source_location: None,\n            additional_context: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn with_context(mut self, key: &str, value: &str) -> Self {\n        self.additional_context.insert(key.to_string(), value.to_string());\n        self\n    }\n\n    pub fn with_location(mut self, location: &str) -> Self {\n        self.source_location = Some(location.to_string());\n        self\n    }\n}\n\n/// Root error type for all AsyncAPI operations\n#[derive(Error, Debug)]\npub enum AsyncApiError {\n    #[error(\"Configuration error: {message}\")]\n    Configuration {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Protocol error: {message}\")]\n    Protocol {\n        message: String,\n        protocol: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Validation error: {message}\")]\n    Validation {\n        message: String,\n        field: Option<String>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Handler error: {message}\")]\n    Handler {\n        message: String,\n        handler_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Middleware error: {message}\")]\n    Middleware {\n        message: String,\n        middleware_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Recovery error: {message}\")]\n    Recovery {\n        message: String,\n        attempts: u32,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Resource error: {message}\")]\n    Resource {\n        message: String,\n        resource_type: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Security error: {message}\")]\n    Security {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Authentication error: {message}\")]\n    Authentication {\n        message: String,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Authorization error: {message}\")]\n    Authorization {\n        message: String,\n        required_permissions: Vec<String>,\n        user_permissions: Vec<String>,\n    },\n\n    #[error(\"Rate limit exceeded: {message}\")]\n    RateLimit {\n        message: String,\n        retry_after: Option<std::time::Duration>,\n    },\n\n    #[error(\"Context error: {message}\")]\n    Context {\n        message: String,\n        context_key: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Router error: {message}\")]\n    Router {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n}\n\nimpl AsyncApiError {\n    /// Create a new error with the specified message, category, and optional source\n    pub fn new(\n        message: String,\n        category: ErrorCategory,\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    ) -> Self {\n        let (severity, retryable) = match category {\n            ErrorCategory::Configuration => (ErrorSeverity::High, false),\n            ErrorCategory::Network => (ErrorSeverity::High, true),\n            ErrorCategory::Validation => (ErrorSeverity::Medium, false),\n            ErrorCategory::BusinessLogic => (ErrorSeverity::High, true),\n            ErrorCategory::Resource => (ErrorSeverity::High, true),\n            ErrorCategory::Security => (ErrorSeverity::Critical, false),\n            ErrorCategory::Serialization => (ErrorSeverity::Medium, false),\n            ErrorCategory::Routing => (ErrorSeverity::Medium, true),\n            ErrorCategory::Authorization => (ErrorSeverity::High, false),\n            ErrorCategory::Unknown => (ErrorSeverity::Medium, false),\n        };\n\n        let metadata = ErrorMetadata::new(severity, category, retryable)\n            .with_location(&format!(\"{}:{}\", file!(), line!()));\n\n        match category {\n            ErrorCategory::Configuration => AsyncApiError::Configuration {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Network => AsyncApiError::Protocol {\n                message,\n                protocol: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Validation => AsyncApiError::Validation {\n                message,\n                field: None,\n                metadata,\n                source,\n            },\n            ErrorCategory::BusinessLogic => AsyncApiError::Handler {\n                message,\n                handler_name: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Resource => AsyncApiError::Resource {\n                message,\n                resource_type: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Security => AsyncApiError::Security {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Serialization => AsyncApiError::Validation {\n                message,\n                field: None,\n                metadata,\n                source,\n            },\n            ErrorCategory::Routing => AsyncApiError::Router {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Authorization => AsyncApiError::Security {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Unknown => AsyncApiError::Configuration {\n                message,\n                metadata,\n                source,\n            },\n        }\n    }\n\n    /// Get error metadata for monitoring and logging\n    pub fn metadata(&self) -> &ErrorMetadata {\n        match self {\n            AsyncApiError::Configuration { metadata, .. } => metadata,\n            AsyncApiError::Protocol { metadata, .. } => metadata,\n            AsyncApiError::Validation { metadata, .. } => metadata,\n            AsyncApiError::Handler { metadata, .. } => metadata,\n            AsyncApiError::Middleware { metadata, .. } => metadata,\n            AsyncApiError::Recovery { metadata, .. } => metadata,\n            AsyncApiError::Resource { metadata, .. } => metadata,\n            AsyncApiError::Security { metadata, .. } => metadata,\n            AsyncApiError::Context { metadata, .. } => metadata,\n            AsyncApiError::Router { metadata, .. } => metadata,\n            // Authentication, Authorization, and RateLimit don't have metadata\n            _ => panic!(\"Error variant without metadata\"),\n        }\n    }\n\n    /// Check if error is retryable\n    pub fn is_retryable(&self) -> bool {\n        self.metadata().retryable\n    }\n\n    /// Get error severity\n    pub fn severity(&self) -> ErrorSeverity {\n        self.metadata().severity\n    }\n\n    /// Get error category\n    pub fn category(&self) -> ErrorCategory {\n        self.metadata().category\n    }\n\n    /// Get correlation ID for tracing\n    pub fn correlation_id(&self) -> &CorrelationId {\n        &self.metadata().correlation_id\n    }\n\n    /// Add context to error metadata\n    pub fn add_context(&mut self, key: &str, value: &str) {\n        match self {\n            AsyncApiError::Configuration { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Protocol { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Validation { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Handler { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Middleware { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Recovery { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Resource { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Security { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Context { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            // Authentication, Authorization, and RateLimit don't have metadata\n            _ => {}\n        }\n    }\n}\n\n${Array.from(protocols).map(protocol => {\n            const protocolTitle = protocol.charAt(0).toUpperCase() + protocol.slice(1);\n\n            return `\n/// ${protocolTitle} protocol-specific errors\n#[derive(Error, Debug)]\npub enum ${protocolTitle}Error {\n    #[error(\"${protocolTitle} connection error: {message}\")]\n    Connection {\n        message: String,\n        endpoint: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"${protocolTitle} authentication error: {message}\")]\n    Authentication {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"${protocolTitle} message error: {message}\")]\n    Message {\n        message: String,\n        message_id: Option<String>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    ${protocol === 'mqtt' ? `\n    #[error(\"MQTT subscription error: {message}\")]\n    Subscription {\n        message: String,\n        topic: String,\n        qos: u8,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"MQTT publish error: {message}\")]\n    Publish {\n        message: String,\n        topic: String,\n        qos: u8,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${protocol === 'kafka' ? `\n    #[error(\"Kafka producer error: {message}\")]\n    Producer {\n        message: String,\n        topic: String,\n        partition: Option<i32>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Kafka consumer error: {message}\")]\n    Consumer {\n        message: String,\n        topic: String,\n        group_id: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Kafka offset error: {message}\")]\n    Offset {\n        message: String,\n        topic: String,\n        partition: i32,\n        offset: i64,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${protocol === 'amqp' ? `\n    #[error(\"AMQP channel error: {message}\")]\n    Channel {\n        message: String,\n        channel_id: u16,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"AMQP exchange error: {message}\")]\n    Exchange {\n        message: String,\n        exchange_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"AMQP queue error: {message}\")]\n    Queue {\n        message: String,\n        queue_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${(protocol === 'ws' || protocol === 'wss') ? `\n    #[error(\"WebSocket frame error: {message}\")]\n    Frame {\n        message: String,\n        frame_type: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"WebSocket protocol error: {message}\")]\n    Protocol {\n        message: String,\n        expected: String,\n        received: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${(protocol === 'http' || protocol === 'https') ? `\n    #[error(\"HTTP status error: {status_code} - {message}\")]\n    Status {\n        message: String,\n        status_code: u16,\n        method: String,\n        url: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"HTTP timeout error: {message}\")]\n    Timeout {\n        message: String,\n        timeout_duration: std::time::Duration,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n}\n\nimpl ${protocolTitle}Error {\n    /// Get error metadata\n    pub fn metadata(&self) -> &ErrorMetadata {\n        match self {\n            ${protocolTitle}Error::Connection { metadata, .. } => metadata,\n            ${protocolTitle}Error::Authentication { metadata, .. } => metadata,\n            ${protocolTitle}Error::Message { metadata, .. } => metadata,\n            ${protocol === 'mqtt' ? `\n            ${protocolTitle}Error::Subscription { metadata, .. } => metadata,\n            ${protocolTitle}Error::Publish { metadata, .. } => metadata,` : ''}\n            ${protocol === 'kafka' ? `\n            ${protocolTitle}Error::Producer { metadata, .. } => metadata,\n            ${protocolTitle}Error::Consumer { metadata, .. } => metadata,\n            ${protocolTitle}Error::Offset { metadata, .. } => metadata,` : ''}\n            ${protocol === 'amqp' ? `\n            ${protocolTitle}Error::Channel { metadata, .. } => metadata,\n            ${protocolTitle}Error::Exchange { metadata, .. } => metadata,\n            ${protocolTitle}Error::Queue { metadata, .. } => metadata,` : ''}\n            ${(protocol === 'ws' || protocol === 'wss') ? `\n            ${protocolTitle}Error::Frame { metadata, .. } => metadata,\n            ${protocolTitle}Error::Protocol { metadata, .. } => metadata,` : ''}\n            ${(protocol === 'http' || protocol === 'https') ? `\n            ${protocolTitle}Error::Status { metadata, .. } => metadata,\n            ${protocolTitle}Error::Timeout { metadata, .. } => metadata,` : ''}\n        }\n    }\n\n    /// Check if error is retryable\n    pub fn is_retryable(&self) -> bool {\n        self.metadata().retryable\n    }\n}\n\nimpl From<${protocolTitle}Error> for AsyncApiError {\n    fn from(error: ${protocolTitle}Error) -> Self {\n        AsyncApiError::Protocol {\n            message: error.to_string(),\n            protocol: \"${protocol}\".to_string(),\n            metadata: error.metadata().clone(),\n            source: Some(Box::new(error)),\n        }\n    }\n}`;\n        }).join('\\n')}\n\n/// Result type alias for AsyncAPI operations\npub type AsyncApiResult<T> = Result<T, AsyncApiError>;\n\n/// Helper macros for creating errors with context\n#[macro_export]\nmacro_rules! config_error {\n    ($msg:expr) => {\n        AsyncApiError::Configuration {\n            message: $msg.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $source:expr) => {\n        AsyncApiError::Configuration {\n            message: $msg.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: Some(Box::new($source)),\n        }\n    };\n}\n\n#[macro_export]\nmacro_rules! validation_error {\n    ($msg:expr) => {\n        AsyncApiError::Validation {\n            message: $msg.to_string(),\n            field: None,\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $field:expr) => {\n        AsyncApiError::Validation {\n            message: $msg.to_string(),\n            field: Some($field.to_string()),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n}\n\n#[macro_export]\nmacro_rules! handler_error {\n    ($msg:expr, $handler:expr) => {\n        AsyncApiError::Handler {\n            message: $msg.to_string(),\n            handler_name: $handler.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::BusinessLogic,\n                true,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $handler:expr, $source:expr) => {\n        AsyncApiError::Handler {\n            message: $msg.to_string(),\n            handler_name: $handler.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::BusinessLogic,\n                true,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: Some(Box::new($source)),\n        }\n    };\n}\n\n/// Error conversion utilities\nimpl From<serde_json::Error> for AsyncApiError {\n    fn from(error: serde_json::Error) -> Self {\n        AsyncApiError::Validation {\n            message: format!(\"JSON serialization/deserialization error: {}\", error),\n            field: None,\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<anyhow::Error> for AsyncApiError {\n    fn from(error: anyhow::Error) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Configuration error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: None,\n        }\n    }\n}\n\nimpl From<std::env::VarError> for AsyncApiError {\n    fn from(error: std::env::VarError) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Environment variable error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<std::num::ParseIntError> for AsyncApiError {\n    fn from(error: std::num::ParseIntError) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Integer parsing error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<tokio::time::error::Elapsed> for AsyncApiError {\n    fn from(error: tokio::time::error::Elapsed) -> Self {\n        AsyncApiError::Resource {\n            message: format!(\"Operation timeout: {}\", error),\n            resource_type: \"timeout\".to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Resource,\n                true,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\n`}\n        </File>\n    );\n}\n","export default function ModelsRs({ asyncapi }) {\n    // Helper functions for Rust identifier generation\n    function toRustIdentifier(str) {\n        if (!str) return 'unknown';\n        let identifier = str\n            .replace(/[^a-zA-Z0-9_]/g, '_')\n            .replace(/^[0-9]/, '_$&')\n            .replace(/_+/g, '_')\n            .replace(/^_+|_+$/g, '');\n        if (/^[0-9]/.test(identifier)) {\n            identifier = 'item_' + identifier;\n        }\n        if (!identifier) {\n            identifier = 'unknown';\n        }\n        const rustKeywords = [\n            'as', 'break', 'const', 'continue', 'crate', 'else', 'enum', 'extern',\n            'false', 'fn', 'for', 'if', 'impl', 'in', 'let', 'loop', 'match',\n            'mod', 'move', 'mut', 'pub', 'ref', 'return', 'self', 'Self',\n            'static', 'struct', 'super', 'trait', 'true', 'type', 'unsafe',\n            'use', 'where', 'while', 'async', 'await', 'dyn'\n        ];\n        if (rustKeywords.includes(identifier)) {\n            identifier = identifier + '_';\n        }\n        return identifier;\n    }\n\n    function toRustTypeName(str) {\n        if (!str) return 'Unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .split('_')\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n\n    function toRustFieldName(str) {\n        if (!str) return 'unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .replace(/([A-Z])/g, '_$1')\n            .toLowerCase()\n            .replace(/^_/, '')\n            .replace(/_+/g, '_');\n    }\n    // Extract message schemas\n    const components = asyncapi.components();\n    const messageSchemas = [];\n    const messageTypes = new Set();\n\n    if (components && components.messages) {\n        const messages = components.messages();\n        if (messages) {\n            Object.entries(messages).forEach(([name, message]) => {\n                let payload = null;\n                try {\n                    if (message.payload && typeof message.payload === 'function') {\n                        const payloadSchema = message.payload();\n                        payload = payloadSchema && payloadSchema.json ? payloadSchema.json() : null;\n                    }\n                } catch (e) {\n                    // Ignore payload extraction errors\n                }\n\n                messageSchemas.push({\n                    name,\n                    rustName: toRustTypeName(name),\n                    payload,\n                    description: message.description && typeof message.description === 'function' ? message.description() : null\n                });\n                messageTypes.add(name);\n            });\n        }\n    }\n\n    // Helper function to convert JSON schema to Rust type\n    function jsonSchemaToRustType(schema) {\n        if (!schema || !schema.type) return 'serde_json::Value';\n\n        switch (schema.type) {\n        case 'string':\n            if (schema.format === 'date-time') return 'chrono::DateTime<chrono::Utc>';\n            if (schema.format === 'uuid') return 'uuid::Uuid';\n            return 'String';\n        case 'integer':\n            return schema.format === 'int64' ? 'i64' : 'i32';\n        case 'number':\n            return 'f64';\n        case 'boolean':\n            return 'bool';\n        case 'array': {\n            const itemType = jsonSchemaToRustType(schema.items);\n            return `Vec<${itemType}>`;\n        }\n        case 'object':\n            return 'serde_json::Value'; // For complex objects, use generic JSON\n        default:\n            return 'serde_json::Value';\n        }\n    }\n\n    // Generate message structs\n    function generateMessageStruct(schema) {\n        if (!schema || !schema.properties) {\n            return '    pub data: serde_json::Value,';\n        }\n\n        const fields = Object.entries(schema.properties).map(([fieldName, fieldSchema]) => {\n            const rustType = jsonSchemaToRustType(fieldSchema);\n            const optional = !schema.required || !schema.required.includes(fieldName);\n            const finalType = optional ? `Option<${rustType}>` : rustType;\n            const rustFieldName = toRustFieldName(fieldName);\n            return `    pub ${rustFieldName}: ${finalType},`;\n        }).join('\\n');\n\n        return fields;\n    }\n\n    return (\n        <File name=\"models.rs\">\n            {`//! Message models generated from AsyncAPI specification\n\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\nuse chrono::{DateTime, Utc};\n\n/// Base trait for all AsyncAPI messages\npub trait AsyncApiMessage {\n    fn message_type(&self) -> &'static str;\n    fn channel(&self) -> &'static str;\n}\n\n${messageSchemas.map(schema => `\n/// ${schema.description || `Message type: ${schema.name}`}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ${schema.rustName} {\n${generateMessageStruct(schema.payload)}\n}\n\nimpl AsyncApiMessage for ${schema.rustName} {\n    fn message_type(&self) -> &'static str {\n        \"${schema.name}\"\n    }\n\n    fn channel(&self) -> &'static str {\n        // TODO: Map to appropriate channel based on your AsyncAPI spec\n        \"default\"\n    }\n}`).join('\\n')}\n\n${messageTypes.size === 0 ? `\n/// Example message structure when no messages are defined in the spec\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExampleMessage {\n    pub id: String,\n    pub content: String,\n    pub timestamp: DateTime<Utc>,\n}\n\nimpl AsyncApiMessage for ExampleMessage {\n    fn message_type(&self) -> &'static str {\n        \"example\"\n    }\n\n    fn channel(&self) -> &'static str {\n        \"example/channel\"\n    }\n}` : ''}\n`}\n        </File>\n    );\n}\n","export default function HandlersRs({ asyncapi }) {\n    // Helper functions for Rust identifier generation\n    function toRustIdentifier(str) {\n        if (!str) return 'unknown';\n        let identifier = str\n            .replace(/[^a-zA-Z0-9_]/g, '_')\n            .replace(/^[0-9]/, '_$&')\n            .replace(/_+/g, '_')\n            .replace(/^_+|_+$/g, '');\n        if (/^[0-9]/.test(identifier)) {\n            identifier = 'item_' + identifier;\n        }\n        if (!identifier) {\n            identifier = 'unknown';\n        }\n        const rustKeywords = [\n            'as', 'break', 'const', 'continue', 'crate', 'else', 'enum', 'extern',\n            'false', 'fn', 'for', 'if', 'impl', 'in', 'let', 'loop', 'match',\n            'mod', 'move', 'mut', 'pub', 'ref', 'return', 'self', 'Self',\n            'static', 'struct', 'super', 'trait', 'true', 'type', 'unsafe',\n            'use', 'where', 'while', 'async', 'await', 'dyn'\n        ];\n        if (rustKeywords.includes(identifier)) {\n            identifier = identifier + '_';\n        }\n        return identifier;\n    }\n\n    function toRustTypeName(str) {\n        if (!str) return 'Unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .split('_')\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n\n    function toRustFieldName(str) {\n        if (!str) return 'unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .replace(/([A-Z])/g, '_$1')\n            .toLowerCase()\n            .replace(/^_/, '')\n            .replace(/_+/g, '_');\n    }\n\n    // Extract channels and their operations\n    const channels = asyncapi.channels();\n    const channelData = [];\n\n    if (channels) {\n        Object.entries(channels).forEach(([channelName, channel]) => {\n            const operations = channel.operations && channel.operations();\n            const channelOps = [];\n\n            if (operations) {\n                Object.entries(operations).forEach(([opName, operation]) => {\n                    const action = operation.action && operation.action();\n                    const messages = operation.messages && operation.messages();\n\n                    channelOps.push({\n                        name: opName,\n                        action,\n                        messages: messages || []\n                    });\n                });\n            }\n\n            channelData.push({\n                name: channelName,\n                rustName: toRustTypeName(channelName + '_handler'),\n                fieldName: toRustFieldName(channelName + '_handler'),\n                address: channel.address && channel.address(),\n                description: channel.description && channel.description(),\n                operations: channelOps.map(op => ({\n                    ...op,\n                    rustName: toRustFieldName(op.name)\n                }))\n            });\n        });\n    }\n\n    return (\n        <File name=\"handlers.rs\">\n            {`//! Message handlers for AsyncAPI operations with enhanced error handling\n//!\n//! This module provides:\n//! - Robust error handling with custom error types\n//! - Retry mechanisms with exponential backoff\n//! - Circuit breaker pattern for failure isolation\n//! - Dead letter queue for unprocessable messages\n//! - Comprehensive logging and monitoring\n\nuse crate::models::*;\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse crate::recovery::{RecoveryManager, RetryConfig};\nuse crate::context::RequestContext;\nuse async_trait::async_trait;\nuse tracing::{info, error, warn, debug, instrument};\nuse std::sync::Arc;\nuse uuid::Uuid;\n\n/// Base trait for all message handlers with enhanced error handling\n#[async_trait]\npub trait MessageHandler<T> {\n    /// Handle a message with basic error handling\n    async fn handle(&self, message: T) -> AsyncApiResult<()>;\n\n    /// Handle a message with full recovery mechanisms\n    async fn handle_with_recovery(&self, message: T, recovery_manager: &RecoveryManager) -> AsyncApiResult<()>;\n}\n\n/// Context for message processing with correlation tracking\n#[derive(Debug, Clone)]\npub struct MessageContext {\n    pub correlation_id: Uuid,\n    pub channel: String,\n    pub operation: String,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    pub retry_count: u32,\n}\n\nimpl MessageContext {\n    pub fn new(channel: &str, operation: &str) -> Self {\n        Self {\n            correlation_id: Uuid::new_v4(),\n            channel: channel.to_string(),\n            operation: operation.to_string(),\n            timestamp: chrono::Utc::now(),\n            retry_count: 0,\n        }\n    }\n\n    pub fn with_retry(&self, retry_count: u32) -> Self {\n        let mut ctx = self.clone();\n        ctx.retry_count = retry_count;\n        ctx\n    }\n}\n\n${channelData.map(channel => `\n/// Handler for ${channel.name} channel with enhanced error handling\n#[derive(Debug)]\npub struct ${channel.rustName} {\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl ${channel.rustName} {\n    pub fn new(recovery_manager: Arc<RecoveryManager>) -> Self {\n        Self { recovery_manager }\n    }\n\n${channel.operations.map(op => `\n    /// Handle ${op.action} operation for ${channel.name} with comprehensive error handling\n    #[instrument(skip(self, payload), fields(\n        channel = \"${channel.name}\",\n        operation = \"${op.name}\",\n        payload_size = payload.len()\n    ))]\n    pub async fn handle_${op.rustName}(&self, payload: &[u8], context: &MessageContext) -> AsyncApiResult<()> {\n        debug!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            retry_count = context.retry_count,\n            \"Starting message processing\"\n        );\n\n        // Input validation with detailed error context\n        if payload.is_empty() {\n            return Err(AsyncApiError::Validation {\n                message: \"Empty payload received\".to_string(),\n                field: Some(\"payload\".to_string()),\n                metadata: ErrorMetadata::new(\n                    ErrorSeverity::Medium,\n                    ErrorCategory::Validation,\n                    false,\n                ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                 .with_context(\"channel\", &context.channel)\n                 .with_context(\"operation\", &context.operation),\n                source: None,\n            });\n        }\n\n        // Parse message with error handling - fix type annotation\n        let message: serde_json::Value = match serde_json::from_slice::<serde_json::Value>(payload) {\n            Ok(msg) => {\n                debug!(\n                    correlation_id = %context.correlation_id,\n                    message_type = msg.get(\"type\").and_then(|v| v.as_str()).unwrap_or(\"unknown\"),\n                    \"Successfully parsed message\"\n                );\n                msg\n            }\n            Err(e) => {\n                error!(\n                    correlation_id = %context.correlation_id,\n                    error = %e,\n                    payload_preview = %String::from_utf8_lossy(&payload[..payload.len().min(100)]),\n                    \"Failed to parse message payload\"\n                );\n                return Err(AsyncApiError::Validation {\n                    message: format!(\"Invalid JSON payload: {}\", e),\n                    field: Some(\"payload\".to_string()),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Validation,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"channel\", &context.channel)\n                     .with_context(\"operation\", &context.operation)\n                     .with_context(\"parse_error\", &e.to_string()),\n                    source: Some(Box::new(e)),\n                });\n            }\n        };\n\n        // Business logic with error handling\n        match self.process_${op.rustName}_message(&message, context).await {\n            Ok(()) => {\n                info!(\n                    correlation_id = %context.correlation_id,\n                    channel = %context.channel,\n                    operation = %context.operation,\n                    processing_time = ?(chrono::Utc::now() - context.timestamp),\n                    \"Message processed successfully\"\n                );\n                Ok(())\n            }\n            Err(e) => {\n                error!(\n                    correlation_id = %context.correlation_id,\n                    error = %e,\n                    retry_count = context.retry_count,\n                    \"Message processing failed\"\n                );\n\n                // Add message to dead letter queue if not retryable\n                if !e.is_retryable() {\n                    let dlq = self.recovery_manager.get_dead_letter_queue();\n                    dlq.add_message(&context.channel, payload.to_vec(), &e, context.retry_count).await?;\n                }\n\n                Err(e)\n            }\n        }\n    }\n\n    /// Process the actual business logic for ${op.action} operation\n    async fn process_${op.rustName}_message(\n        &self,\n        message: &serde_json::Value,\n        context: &MessageContext,\n    ) -> AsyncApiResult<()> {\n        // TODO: Implement your business logic here\n        // This is where you would:\n        // 1. Validate the message schema\n        // 2. Extract required fields\n        // 3. Perform business operations\n        // 4. Update databases or external services\n        // 5. Send responses or notifications\n\n        // Example implementation with error handling:\n        let message_type = message.get(\"type\")\n            .and_then(|v| v.as_str())\n            .ok_or_else(|| AsyncApiError::Validation {\n                message: \"Missing required field 'type'\".to_string(),\n                field: Some(\"type\".to_string()),\n                metadata: ErrorMetadata::new(\n                    ErrorSeverity::Medium,\n                    ErrorCategory::Validation,\n                    false,\n                ).with_context(\"correlation_id\", &context.correlation_id.to_string()),\n                source: None,\n            })?;\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            message_type = message_type,\n            \"Processing message of type: {}\", message_type\n        );\n\n        // Simulate processing with potential failure\n        match message_type {\n            \"ping\" => {\n                info!(correlation_id = %context.correlation_id, \"Processing ping message\");\n                Ok(())\n            }\n            \"error_test\" => {\n                // Simulate a retryable error for testing\n                Err(AsyncApiError::Handler {\n                    message: \"Simulated processing error for testing\".to_string(),\n                    handler_name: \"${channel.rustName}\".to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::High,\n                        ErrorCategory::BusinessLogic,\n                        true, // This error is retryable\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"message_type\", message_type),\n                    source: None,\n                })\n            }\n            _ => {\n                warn!(\n                    correlation_id = %context.correlation_id,\n                    message_type = message_type,\n                    \"Unknown message type, processing as generic message\"\n                );\n                Ok(())\n            }\n        }\n    }\n\n    /// Handle ${op.action} operation with full recovery mechanisms\n    pub async fn handle_${op.rustName}_with_recovery(\n        &self,\n        payload: &[u8],\n        context: &MessageContext,\n    ) -> AsyncApiResult<()> {\n        let mut retry_strategy = self.recovery_manager.get_retry_strategy(\"message_handler\");\n\n        // Get circuit breaker for this handler\n        let circuit_breaker = self.recovery_manager.get_circuit_breaker(\"${channel.rustName}\");\n\n        // Get bulkhead for message processing\n        let bulkhead = self.recovery_manager.get_bulkhead(\"message_processing\");\n\n        // Execute with all recovery mechanisms\n        let operation = || async {\n            // Use bulkhead if available\n            if let Some(bulkhead) = &bulkhead {\n                bulkhead.execute(|| async {\n                    self.handle_${op.rustName}(payload, context).await\n                }).await\n            } else {\n                self.handle_${op.rustName}(payload, context).await\n            }\n        };\n\n        // Use circuit breaker if available\n        let result = if let Some(ref circuit_breaker) = circuit_breaker {\n            circuit_breaker.execute(operation).await\n        } else {\n            operation().await\n        };\n\n        // Apply retry strategy if the operation failed\n        match result {\n            Ok(()) => Ok(()),\n            Err(e) if e.is_retryable() => {\n                warn!(\n                    correlation_id = %context.correlation_id,\n                    error = %e,\n                    \"Operation failed, attempting retry\"\n                );\n\n                // Clone necessary values to avoid borrowing issues\n                let circuit_breaker_clone = circuit_breaker.clone();\n                let bulkhead_clone = bulkhead.clone();\n\n                let current_attempt = retry_strategy.current_attempt();\n                retry_strategy.execute(|| async {\n                    let retry_context = context.with_retry(current_attempt);\n                    if let Some(ref circuit_breaker) = circuit_breaker_clone {\n                        circuit_breaker.execute(|| async {\n                            if let Some(ref bulkhead) = bulkhead_clone {\n                                bulkhead.execute(|| async {\n                                    self.handle_${op.rustName}(payload, &retry_context).await\n                                }).await\n                            } else {\n                                self.handle_${op.rustName}(payload, &retry_context).await\n                            }\n                        }).await\n                    } else {\n                        self.handle_${op.rustName}(payload, &retry_context).await\n                    }\n                }).await\n            }\n            Err(e) => Err(e),\n        }\n    }`).join('\\n')}\n}`).join('\\n')}\n\n/// Enhanced handler registry with recovery management\n#[derive(Debug)]\npub struct HandlerRegistry {\n    ${channelData.map(channel => `pub ${channel.fieldName}: ${channel.rustName},`).join('\\n    ')}\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl HandlerRegistry {\n    pub fn new() -> Self {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n        Self {\n            ${channelData.map(channel => `${channel.fieldName}: ${channel.rustName}::new(recovery_manager.clone()),`).join('\\n            ')}\n            recovery_manager,\n        }\n    }\n\n    pub fn with_recovery_manager(recovery_manager: Arc<RecoveryManager>) -> Self {\n        Self {\n            ${channelData.map(channel => `${channel.fieldName}: ${channel.rustName}::new(recovery_manager.clone()),`).join('\\n            ')}\n            recovery_manager,\n        }\n    }\n\n    /// Route message to appropriate handler with enhanced error handling\n    #[instrument(skip(self, payload), fields(channel, operation, payload_size = payload.len()))]\n    pub async fn route_message(&self, channel: &str, operation: &str, payload: &[u8]) -> AsyncApiResult<()> {\n        let context = MessageContext::new(channel, operation);\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            channel = channel,\n            operation = operation,\n            payload_size = payload.len(),\n            \"Routing message to handler\"\n        );\n\n        match channel {\n            ${channelData.map(channel => `\"${channel.name}\" => {\n                match operation {\n                    ${channel.operations.map(op => `\"${op.name}\" => {\n                        self.${channel.fieldName}.handle_${op.rustName}_with_recovery(payload, &context).await\n                    },`).join('\\n                    ')}\n                    _ => {\n                        warn!(\n                            correlation_id = %context.correlation_id,\n                            channel = channel,\n                            operation = operation,\n                            \"Unknown operation for channel\"\n                        );\n                        Err(AsyncApiError::Handler {\n                            message: format!(\"Unknown operation '{}' for channel '{}'\", operation, channel),\n                            handler_name: \"HandlerRegistry\".to_string(),\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::Medium,\n                                ErrorCategory::BusinessLogic,\n                                false,\n                            ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                             .with_context(\"channel\", channel)\n                             .with_context(\"operation\", operation),\n                            source: None,\n                        })\n                    }\n                }\n            },`).join('\\n            ')}\n            _ => {\n                error!(\n                    correlation_id = %context.correlation_id,\n                    channel = channel,\n                    operation = operation,\n                    \"Unknown channel\"\n                );\n                Err(AsyncApiError::Handler {\n                    message: format!(\"Unknown channel: {}\", channel),\n                    handler_name: \"HandlerRegistry\".to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::High,\n                        ErrorCategory::BusinessLogic,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"channel\", channel)\n                     .with_context(\"operation\", operation),\n                    source: None,\n                })\n            }\n        }\n    }\n\n    /// Get recovery manager for external configuration\n    pub fn recovery_manager(&self) -> Arc<RecoveryManager> {\n        self.recovery_manager.clone()\n    }\n\n    /// Get handler statistics for monitoring\n    pub async fn get_statistics(&self) -> HandlerStatistics {\n        HandlerStatistics {\n            dead_letter_queue_size: self.recovery_manager.get_dead_letter_queue().size().await,\n            // Add more statistics as needed\n        }\n    }\n}\n\nimpl Default for HandlerRegistry {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Statistics for monitoring handler performance\n#[derive(Debug, Clone)]\npub struct HandlerStatistics {\n    pub dead_letter_queue_size: usize,\n}\n`}\n        </File>\n    );\n}\n","export default function ContextRs() {\n    return (\n        <File name=\"context.rs\">\n            {`//! Advanced context management system for AsyncAPI applications\n//!\n//! This module provides:\n//! - Request-scoped context with automatic propagation\n//! - Thread-safe execution context for shared state\n//! - Context-aware error handling and enrichment\n//! - Performance metrics and tracing integration\n//! - Middleware data sharing and storage\n\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};\nuse tokio::sync::RwLock;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse tracing::{info, warn, error, debug, instrument, Span};\n\n/// Request-scoped context that carries data through the entire processing pipeline\n#[derive(Debug, Clone)]\npub struct RequestContext {\n    /// Unique correlation ID for request tracking\n    pub correlation_id: Uuid,\n    /// Request start time for performance tracking\n    pub start_time: Instant,\n    /// Request timestamp\n    pub timestamp: SystemTime,\n    /// Source channel/topic\n    pub channel: String,\n    /// Operation being performed\n    pub operation: String,\n    /// Request metadata and headers\n    pub metadata: HashMap<String, String>,\n    /// Custom data storage for middleware and handlers\n    pub data: Arc<RwLock<HashMap<String, ContextValue>>>,\n    /// Performance metrics\n    pub metrics: Arc<RwLock<RequestMetrics>>,\n    /// Tracing span for distributed tracing\n    pub span: Span,\n    /// Request priority (for routing and processing)\n    pub priority: RequestPriority,\n    /// Request tags for categorization\n    pub tags: Vec<String>,\n    /// Authentication claims (if authenticated)\n    #[cfg(feature = \"auth\")]\n    pub auth_claims: Option<crate::auth::Claims>,\n}\n\nimpl RequestContext {\n    /// Create a new request context\n    pub fn new(channel: &str, operation: &str) -> Self {\n        let correlation_id = Uuid::new_v4();\n        let span = tracing::info_span!(\n            \"request\",\n            correlation_id = %correlation_id,\n            channel = %channel,\n            operation = %operation\n        );\n\n        Self {\n            correlation_id,\n            start_time: Instant::now(),\n            timestamp: SystemTime::now(),\n            channel: channel.to_string(),\n            operation: operation.to_string(),\n            metadata: HashMap::new(),\n            data: Arc::new(RwLock::new(HashMap::new())),\n            metrics: Arc::new(RwLock::new(RequestMetrics::new())),\n            span,\n            priority: RequestPriority::Normal,\n            tags: Vec::new(),\n        }\n    }\n\n    /// Create context with custom correlation ID\n    pub fn with_correlation_id(channel: &str, operation: &str, correlation_id: Uuid) -> Self {\n        let mut ctx = Self::new(channel, operation);\n        ctx.correlation_id = correlation_id;\n        ctx\n    }\n\n    /// Add metadata to the context\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n\n    /// Set request priority\n    pub fn with_priority(mut self, priority: RequestPriority) -> Self {\n        self.priority = priority;\n        self\n    }\n\n    /// Add tags to the context\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    /// Store data in the context\n    pub async fn set_data<T: Into<ContextValue>>(&self, key: &str, value: T) -> AsyncApiResult<()> {\n        let mut data = self.data.write().await;\n        data.insert(key.to_string(), value.into());\n        debug!(\n            correlation_id = %self.correlation_id,\n            key = key,\n            \"Stored data in request context\"\n        );\n        Ok(())\n    }\n\n    /// Retrieve data from the context\n    pub async fn get_data(&self, key: &str) -> Option<ContextValue> {\n        let data = self.data.read().await;\n        data.get(key).cloned()\n    }\n\n    /// Get typed data from the context\n    pub async fn get_typed_data<T>(&self, key: &str) -> AsyncApiResult<Option<T>>\n    where\n        T: for<'de> Deserialize<'de>,\n    {\n        if let Some(value) = self.get_data(key).await {\n            match value {\n                ContextValue::Json(json_str) => {\n                    match serde_json::from_str::<T>(&json_str) {\n                        Ok(typed_value) => Ok(Some(typed_value)),\n                        Err(e) => Err(AsyncApiError::Context {\n                            message: format!(\"Failed to deserialize context data: {}\", e),\n                            context_key: key.to_string(),\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::Medium,\n                                ErrorCategory::Serialization,\n                                false,\n                            ).with_context(\"correlation_id\", &self.correlation_id.to_string()),\n                            source: Some(Box::new(e)),\n                        }),\n                    }\n                }\n                _ => Err(AsyncApiError::Context {\n                    message: \"Context value is not JSON serializable\".to_string(),\n                    context_key: key.to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Low,\n                        ErrorCategory::Validation,\n                        false,\n                    ).with_context(\"correlation_id\", &self.correlation_id.to_string()),\n                    source: None,\n                }),\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Record a metric event\n    pub async fn record_metric(&self, event: MetricEvent) {\n        let mut metrics = self.metrics.write().await;\n        metrics.record_event(event);\n    }\n\n    /// Get current metrics\n    pub async fn get_metrics(&self) -> RequestMetrics {\n        self.metrics.read().await.clone()\n    }\n\n    /// Get elapsed time since request start\n    pub fn elapsed(&self) -> Duration {\n        self.start_time.elapsed()\n    }\n\n    /// Create a child context for sub-operations\n    pub fn child_context(&self, operation: &str) -> Self {\n        let child_span = tracing::info_span!(\n            parent: &self.span,\n            \"child_operation\",\n            operation = %operation,\n            parent_correlation_id = %self.correlation_id\n        );\n\n        Self {\n            correlation_id: Uuid::new_v4(),\n            start_time: Instant::now(),\n            timestamp: SystemTime::now(),\n            channel: self.channel.clone(),\n            operation: operation.to_string(),\n            metadata: self.metadata.clone(),\n            data: self.data.clone(), // Share data with parent\n            metrics: Arc::new(RwLock::new(RequestMetrics::new())),\n            span: child_span,\n            priority: self.priority,\n            tags: self.tags.clone(),\n            #[cfg(feature = \"auth\")]\n            auth_claims: self.auth_claims.clone(),\n        }\n    }\n\n    /// Set authentication claims\n    #[cfg(feature = \"auth\")]\n    pub fn set_auth_claims(&mut self, claims: crate::auth::Claims) {\n        self.auth_claims = Some(claims);\n    }\n\n    /// Get authentication claims\n    #[cfg(feature = \"auth\")]\n    pub fn get_auth_claims(&self) -> Option<&crate::auth::Claims> {\n        self.auth_claims.as_ref()\n    }\n\n    /// Check if the request is authenticated\n    #[cfg(feature = \"auth\")]\n    pub fn is_authenticated(&self) -> bool {\n        self.auth_claims.is_some()\n    }\n\n    /// Get the authenticated user ID\n    #[cfg(feature = \"auth\")]\n    pub fn get_user_id(&self) -> Option<&str> {\n        self.auth_claims.as_ref().map(|claims| claims.sub.as_str())\n    }\n\n    /// Check if the authenticated user has a specific role\n    #[cfg(feature = \"auth\")]\n    pub fn has_role(&self, role: &str) -> bool {\n        self.auth_claims.as_ref()\n            .map(|claims| claims.has_role(role))\n            .unwrap_or(false)\n    }\n\n    /// Check if the authenticated user has a specific permission\n    #[cfg(feature = \"auth\")]\n    pub fn has_permission(&self, permission: &str) -> bool {\n        self.auth_claims.as_ref()\n            .map(|claims| claims.has_permission(permission))\n            .unwrap_or(false)\n    }\n\n    /// Get client ID for rate limiting and tracking\n    pub fn get_client_id(&self) -> Option<String> {\n        // Try to get from auth claims first\n        #[cfg(feature = \"auth\")]\n        if let Some(claims) = &self.auth_claims {\n            return Some(claims.sub.clone());\n        }\n\n        // Fall back to metadata\n        if let Some(client_id) = self.metadata.get(\"client_id\") {\n            return Some(client_id.clone());\n        }\n\n        // Fall back to IP address or other identifier\n        if let Some(ip) = self.metadata.get(\"remote_addr\") {\n            return Some(ip.clone());\n        }\n\n        None\n    }\n\n    /// Get header value\n    pub fn get_header(&self, name: &str) -> Option<&String> {\n        self.metadata.get(&format!(\"header_{}\", name.to_lowercase()))\n    }\n\n    /// Set header value\n    pub fn set_header(&mut self, name: &str, value: &str) {\n        self.metadata.insert(format!(\"header_{}\", name.to_lowercase()), value.to_string());\n    }\n\n    /// Get metadata value\n    pub fn get_metadata(&self, key: &str) -> Option<&String> {\n        self.metadata.get(key)\n    }\n\n    /// Set metadata value\n    pub fn set_metadata(&mut self, key: &str, value: &str) {\n        self.metadata.insert(key.to_string(), value.to_string());\n    }\n\n    /// Get property value (convenience method for common properties)\n    pub fn get_property(&self, key: &str) -> Option<&String> {\n        self.metadata.get(&format!(\"prop_{}\", key))\n    }\n\n    /// Set property value (convenience method for common properties)\n    pub fn set_property(&mut self, key: String, value: String) {\n        self.metadata.insert(format!(\"prop_{}\", key), value);\n    }\n\n    /// Enrich error with context information\n    pub fn enrich_error(&self, mut error: AsyncApiError) -> AsyncApiError {\n        error.add_context(\"correlation_id\", &self.correlation_id.to_string());\n        error.add_context(\"channel\", &self.channel);\n        error.add_context(\"operation\", &self.operation);\n        error.add_context(\"elapsed_ms\", &self.elapsed().as_millis().to_string());\n\n        // Add metadata to error context\n        for (key, value) in &self.metadata {\n            error.add_context(&format!(\"metadata_{}\", key), value);\n        }\n\n        error\n    }\n}\n\n/// Values that can be stored in the context\n#[derive(Debug, Clone)]\npub enum ContextValue {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    Json(String),\n    Binary(Vec<u8>),\n}\n\nimpl From<String> for ContextValue {\n    fn from(value: String) -> Self {\n        ContextValue::String(value)\n    }\n}\n\nimpl From<&str> for ContextValue {\n    fn from(value: &str) -> Self {\n        ContextValue::String(value.to_string())\n    }\n}\n\nimpl From<i64> for ContextValue {\n    fn from(value: i64) -> Self {\n        ContextValue::Integer(value)\n    }\n}\n\nimpl From<f64> for ContextValue {\n    fn from(value: f64) -> Self {\n        ContextValue::Float(value)\n    }\n}\n\nimpl From<bool> for ContextValue {\n    fn from(value: bool) -> Self {\n        ContextValue::Boolean(value)\n    }\n}\n\nimpl From<Vec<u8>> for ContextValue {\n    fn from(value: Vec<u8>) -> Self {\n        ContextValue::Binary(value)\n    }\n}\n\nimpl<T: Serialize> From<&T> for ContextValue {\n    fn from(value: &T) -> Self {\n        match serde_json::to_string(value) {\n            Ok(json) => ContextValue::Json(json),\n            Err(_) => ContextValue::String(\"serialization_failed\".to_string()),\n        }\n    }\n}\n\n/// Request priority levels for routing and processing\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum RequestPriority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}\n\nimpl Default for RequestPriority {\n    fn default() -> Self {\n        RequestPriority::Normal\n    }\n}\n\n/// Performance metrics for a request\n#[derive(Debug, Clone)]\npub struct RequestMetrics {\n    pub events: Vec<MetricEvent>,\n    pub start_time: Instant,\n}\n\nimpl RequestMetrics {\n    pub fn new() -> Self {\n        Self {\n            events: Vec::new(),\n            start_time: Instant::now(),\n        }\n    }\n\n    pub fn record_event(&mut self, event: MetricEvent) {\n        self.events.push(event);\n    }\n\n    pub fn total_duration(&self) -> Duration {\n        self.start_time.elapsed()\n    }\n\n    pub fn get_events_by_type(&self, event_type: &str) -> Vec<&MetricEvent> {\n        self.events.iter().filter(|e| e.event_type == event_type).collect()\n    }\n}\n\n/// Individual metric event\n#[derive(Debug, Clone)]\npub struct MetricEvent {\n    pub event_type: String,\n    pub timestamp: Instant,\n    pub duration: Option<Duration>,\n    pub metadata: HashMap<String, String>,\n}\n\nimpl MetricEvent {\n    pub fn new(event_type: &str) -> Self {\n        Self {\n            event_type: event_type.to_string(),\n            timestamp: Instant::now(),\n            duration: None,\n            metadata: HashMap::new(),\n        }\n    }\n\n    pub fn with_duration(mut self, duration: Duration) -> Self {\n        self.duration = Some(duration);\n        self\n    }\n\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n}\n\n/// Global execution context for shared state\n#[derive(Debug)]\npub struct ExecutionContext {\n    /// Application-wide configuration\n    pub config: Arc<RwLock<HashMap<String, String>>>,\n    /// Shared metrics and statistics\n    pub global_metrics: Arc<RwLock<GlobalMetrics>>,\n    /// Active request contexts\n    pub active_requests: Arc<RwLock<HashMap<Uuid, RequestContext>>>,\n    /// Context creation time\n    pub created_at: SystemTime,\n}\n\nimpl ExecutionContext {\n    pub fn new() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(HashMap::new())),\n            global_metrics: Arc::new(RwLock::new(GlobalMetrics::new())),\n            active_requests: Arc::new(RwLock::new(HashMap::new())),\n            created_at: SystemTime::now(),\n        }\n    }\n\n    /// Register an active request\n    pub async fn register_request(&self, context: RequestContext) {\n        let mut requests = self.active_requests.write().await;\n        requests.insert(context.correlation_id, context);\n\n        let mut metrics = self.global_metrics.write().await;\n        metrics.active_requests += 1;\n        metrics.total_requests += 1;\n    }\n\n    /// Unregister a completed request\n    pub async fn unregister_request(&self, correlation_id: Uuid) -> Option<RequestContext> {\n        let mut requests = self.active_requests.write().await;\n        let context = requests.remove(&correlation_id);\n\n        if context.is_some() {\n            let mut metrics = self.global_metrics.write().await;\n            metrics.active_requests = metrics.active_requests.saturating_sub(1);\n        }\n\n        context\n    }\n\n    /// Get active request count\n    pub async fn active_request_count(&self) -> usize {\n        self.active_requests.read().await.len()\n    }\n\n    /// Get global metrics\n    pub async fn get_global_metrics(&self) -> GlobalMetrics {\n        self.global_metrics.read().await.clone()\n    }\n\n    /// Set configuration value\n    pub async fn set_config(&self, key: &str, value: &str) {\n        let mut config = self.config.write().await;\n        config.insert(key.to_string(), value.to_string());\n    }\n\n    /// Get configuration value\n    pub async fn get_config(&self, key: &str) -> Option<String> {\n        let config = self.config.read().await;\n        config.get(key).cloned()\n    }\n}\n\nimpl Default for ExecutionContext {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Global application metrics\n#[derive(Debug, Clone)]\npub struct GlobalMetrics {\n    pub total_requests: u64,\n    pub active_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub uptime: Duration,\n    pub start_time: SystemTime,\n}\n\nimpl GlobalMetrics {\n    pub fn new() -> Self {\n        Self {\n            total_requests: 0,\n            active_requests: 0,\n            successful_requests: 0,\n            failed_requests: 0,\n            average_response_time: Duration::ZERO,\n            uptime: Duration::ZERO,\n            start_time: SystemTime::now(),\n        }\n    }\n\n    pub fn record_success(&mut self, duration: Duration) {\n        self.successful_requests += 1;\n        self.update_average_response_time(duration);\n    }\n\n    pub fn record_failure(&mut self, duration: Duration) {\n        self.failed_requests += 1;\n        self.update_average_response_time(duration);\n    }\n\n    fn update_average_response_time(&mut self, duration: Duration) {\n        let total_completed = self.successful_requests + self.failed_requests;\n        if total_completed > 0 {\n            let total_time = self.average_response_time.as_nanos() * (total_completed - 1) as u128 + duration.as_nanos();\n            self.average_response_time = Duration::from_nanos((total_time / total_completed as u128) as u64);\n        }\n    }\n\n    pub fn success_rate(&self) -> f64 {\n        let total_completed = self.successful_requests + self.failed_requests;\n        if total_completed > 0 {\n            self.successful_requests as f64 / total_completed as f64\n        } else {\n            0.0\n        }\n    }\n}\n\n/// Context manager for handling context lifecycle\npub struct ContextManager {\n    execution_context: Arc<ExecutionContext>,\n}\n\nimpl ContextManager {\n    pub fn new() -> Self {\n        Self {\n            execution_context: Arc::new(ExecutionContext::new()),\n        }\n    }\n\n    pub fn with_execution_context(execution_context: Arc<ExecutionContext>) -> Self {\n        Self { execution_context }\n    }\n\n    /// Create a new request context and register it\n    #[instrument(skip(self), fields(channel, operation))]\n    pub async fn create_request_context(&self, channel: &str, operation: &str) -> RequestContext {\n        let context = RequestContext::new(channel, operation);\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            channel = %channel,\n            operation = %operation,\n            \"Created new request context\"\n        );\n\n        self.execution_context.register_request(context.clone()).await;\n        context\n    }\n\n    /// Complete a request context and update metrics\n    #[instrument(skip(self, context), fields(correlation_id = %context.correlation_id))]\n    pub async fn complete_request_context(&self, context: RequestContext, success: bool) -> AsyncApiResult<()> {\n        let duration = context.elapsed();\n\n        // Update global metrics\n        {\n            let mut metrics = self.execution_context.global_metrics.write().await;\n            if success {\n                metrics.record_success(duration);\n            } else {\n                metrics.record_failure(duration);\n            }\n        }\n\n        // Unregister the request\n        self.execution_context.unregister_request(context.correlation_id).await;\n\n        info!(\n            correlation_id = %context.correlation_id,\n            duration_ms = duration.as_millis(),\n            success = success,\n            \"Completed request context\"\n        );\n\n        Ok(())\n    }\n\n    /// Get execution context\n    pub fn execution_context(&self) -> Arc<ExecutionContext> {\n        self.execution_context.clone()\n    }\n\n    /// Get context statistics\n    pub async fn get_statistics(&self) -> ContextStatistics {\n        let global_metrics = self.execution_context.get_global_metrics().await;\n        let active_count = self.execution_context.active_request_count().await;\n\n        ContextStatistics {\n            active_requests: active_count,\n            total_requests: global_metrics.total_requests,\n            success_rate: global_metrics.success_rate(),\n            average_response_time: global_metrics.average_response_time,\n            uptime: self.execution_context.created_at.elapsed().unwrap_or_default(),\n        }\n    }\n}\n\nimpl Default for ContextManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Statistics about context usage\n#[derive(Debug, Clone, Serialize)]\npub struct ContextStatistics {\n    pub active_requests: usize,\n    pub total_requests: u64,\n    pub success_rate: f64,\n    pub average_response_time: Duration,\n    pub uptime: Duration,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_request_context_creation() {\n        let ctx = RequestContext::new(\"test/channel\", \"test_operation\");\n        assert_eq!(ctx.channel, \"test/channel\");\n        assert_eq!(ctx.operation, \"test_operation\");\n        assert_eq!(ctx.priority, RequestPriority::Normal);\n    }\n\n    #[tokio::test]\n    async fn test_context_data_storage() {\n        let ctx = RequestContext::new(\"test/channel\", \"test_operation\");\n\n        ctx.set_data(\"test_key\", \"test_value\").await.unwrap();\n        let value = ctx.get_data(\"test_key\").await;\n\n        assert!(value.is_some());\n        match value.unwrap() {\n            ContextValue::String(s) => assert_eq!(s, \"test_value\"),\n            _ => panic!(\"Expected string value\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_context_manager() {\n        let manager = ContextManager::new();\n        let ctx = manager.create_request_context(\"test/channel\", \"test_op\").await;\n\n        assert_eq!(manager.execution_context.active_request_count().await, 1);\n\n        manager.complete_request_context(ctx, true).await.unwrap();\n        assert_eq!(manager.execution_context.active_request_count().await, 0);\n    }\n\n    #[test]\n    fn test_request_priority_ordering() {\n        assert!(RequestPriority::Critical > RequestPriority::High);\n        assert!(RequestPriority::High > RequestPriority::Normal);\n        assert!(RequestPriority::Normal > RequestPriority::Low);\n    }\n}\n`}\n        </File>\n    );\n}\n","/* eslint-disable no-useless-escape */\nexport default function RouterRs({ asyncapi }) {\n    // Extract channels and operations for route generation\n    const channels = asyncapi.channels();\n    const channelData = [];\n\n    if (channels) {\n        Object.entries(channels).forEach(([channelName, channel]) => {\n            const operations = channel.operations && channel.operations();\n            const channelOps = [];\n\n            if (operations) {\n                Object.entries(operations).forEach(([opName, operation]) => {\n                    const action = operation.action && operation.action();\n                    channelOps.push({\n                        name: opName,\n                        action,\n                        channel: channelName\n                    });\n                });\n            }\n\n            channelData.push({\n                name: channelName,\n                operations: channelOps\n            });\n        });\n    }\n\n    return (\n        <File name=\"router.rs\">\n            {`//! Advanced routing system for AsyncAPI applications\n//!\n//! This module provides:\n//! - Pattern-based routing with wildcards and parameters\n//! - Content-based message routing\n//! - Route guards and middleware chains\n//! - Dynamic route registration and modification\n//! - Performance-optimized route matching\n\nuse crate::context::{RequestContext, RequestPriority};\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse crate::handlers::HandlerRegistry;\nuse crate::middleware::{Middleware, MiddlewarePipeline};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse tracing::{info, warn, error, debug, instrument};\nuse std::time::{Duration, Instant};\nuse uuid::Uuid;\n\n/// Advanced router for message routing with pattern matching and content-based routing\n#[derive(Debug)]\npub struct Router {\n    /// Static routes for exact matches\n    static_routes: Arc<RwLock<HashMap<String, Route>>>,\n    /// Pattern routes for wildcard and parameter matching\n    pattern_routes: Arc<RwLock<Vec<PatternRoute>>>,\n    /// Content-based routes that examine message payload\n    content_routes: Arc<RwLock<Vec<ContentRoute>>>,\n    /// Default route for unmatched messages\n    default_route: Arc<RwLock<Option<Route>>>,\n    /// Route performance metrics\n    metrics: Arc<RwLock<RouterMetrics>>,\n    /// Route cache for performance optimization\n    route_cache: Arc<RwLock<HashMap<String, CachedRoute>>>,\n    /// Maximum cache size\n    max_cache_size: usize,\n}\n\nimpl Router {\n    /// Create a new router instance\n    pub fn new() -> Self {\n        Self {\n            static_routes: Arc::new(RwLock::new(HashMap::new())),\n            pattern_routes: Arc::new(RwLock::new(Vec::new())),\n            content_routes: Arc::new(RwLock::new(Vec::new())),\n            default_route: Arc::new(RwLock::new(None)),\n            metrics: Arc::new(RwLock::new(RouterMetrics::new())),\n            route_cache: Arc::new(RwLock::new(HashMap::new())),\n            max_cache_size: 1000,\n        }\n    }\n\n    /// Create router with custom cache size\n    pub fn with_cache_size(cache_size: usize) -> Self {\n        let mut router = Self::new();\n        router.max_cache_size = cache_size;\n        router\n    }\n\n    /// Add a static route for exact channel/operation matching\n    #[instrument(skip(self, route), fields(channel = %route.channel, operation = %route.operation))]\n    pub async fn add_static_route(&self, route: Route) -> AsyncApiResult<()> {\n        let route_key = format!(\"{}:{}\", route.channel, route.operation);\n\n        debug!(\n            channel = %route.channel,\n            operation = %route.operation,\n            priority = ?route.priority,\n            \"Adding static route\"\n        );\n\n        let mut routes = self.static_routes.write().await;\n        routes.insert(route_key, route);\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Add a pattern route for wildcard and parameter matching\n    #[instrument(skip(self, pattern_route), fields(pattern = %pattern_route.pattern))]\n    pub async fn add_pattern_route(&self, pattern_route: PatternRoute) -> AsyncApiResult<()> {\n        debug!(\n            pattern = %pattern_route.pattern,\n            priority = ?pattern_route.route.priority,\n            \"Adding pattern route\"\n        );\n\n        let mut routes = self.pattern_routes.write().await;\n        routes.push(pattern_route);\n\n        // Sort by priority (higher priority first)\n        routes.sort_by(|a, b| b.route.priority.cmp(&a.route.priority));\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Add a content-based route that examines message payload\n    #[instrument(skip(self, content_route), fields(name = %content_route.name))]\n    pub async fn add_content_route(&self, content_route: ContentRoute) -> AsyncApiResult<()> {\n        debug!(\n            name = %content_route.name,\n            priority = ?content_route.route.priority,\n            \"Adding content-based route\"\n        );\n\n        let mut routes = self.content_routes.write().await;\n        routes.push(content_route);\n\n        // Sort by priority (higher priority first)\n        routes.sort_by(|a, b| b.route.priority.cmp(&a.route.priority));\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Set the default route for unmatched messages\n    pub async fn set_default_route(&self, route: Route) -> AsyncApiResult<()> {\n        debug!(\n            channel = %route.channel,\n            operation = %route.operation,\n            \"Setting default route\"\n        );\n\n        let mut default_route = self.default_route.write().await;\n        *default_route = Some(route);\n\n        Ok(())\n    }\n\n    /// Route a message to the appropriate handler\n    #[instrument(skip(self, payload, context), fields(\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    pub async fn route_message(\n        &self,\n        context: &RequestContext,\n        payload: &[u8],\n        handlers: &HandlerRegistry,\n    ) -> AsyncApiResult<RouteResult> {\n        let start_time = Instant::now();\n        let route_key = format!(\"{}:{}\", context.channel, context.operation);\n\n        // Check cache first\n        if let Some(cached_route) = self.get_cached_route(&route_key).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                route_key = %route_key,\n                \"Using cached route\"\n            );\n\n            let result = self.execute_route(&cached_route.route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::CacheHit, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try static routes first (fastest)\n        if let Some(route) = self.find_static_route(&context.channel, &context.operation).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Found static route match\"\n            );\n\n            self.cache_route(route_key.clone(), route.clone()).await;\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::StaticMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try pattern routes\n        if let Some((route, params)) = self.find_pattern_route(&context.channel, &context.operation).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                params = ?params,\n                \"Found pattern route match\"\n            );\n\n            // Add route parameters to context\n            for (key, value) in params {\n                context.set_data(&format!(\"route_param_{}\", key), value).await?;\n            }\n\n            self.cache_route(route_key.clone(), route.clone()).await;\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::PatternMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try content-based routes\n        if let Some(route) = self.find_content_route(payload, context).await? {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Found content-based route match\"\n            );\n\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::ContentMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Use default route if available\n        if let Some(route) = self.get_default_route().await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Using default route\"\n            );\n\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::DefaultRoute, start_time.elapsed()).await;\n            return result;\n        }\n\n        // No route found\n        self.record_route_metric(RouteMetric::NoMatch, start_time.elapsed()).await;\n\n        error!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            \"No route found for message\"\n        );\n\n        Err(AsyncApiError::Router {\n            message: format!(\"No route found for channel '{}' operation '{}'\", context.channel, context.operation),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Routing,\n                false,\n            ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n             .with_context(\"channel\", &context.channel)\n             .with_context(\"operation\", &context.operation),\n            source: None,\n        })\n    }\n\n    /// Execute a route with its middleware chain and guards\n    async fn execute_route(\n        &self,\n        route: &Route,\n        context: &RequestContext,\n        payload: &[u8],\n        handlers: &HandlerRegistry,\n    ) -> AsyncApiResult<RouteResult> {\n        // Check route guards\n        for guard in &route.guards {\n            if !(guard.check)(context, payload).await? {\n                return Err(AsyncApiError::Router {\n                    message: format!(\"Route guard '{}' failed\", guard.name),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Authorization,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"guard_name\", &guard.name)\n                     .with_context(\"channel\", &context.channel)\n                     .with_context(\"operation\", &context.operation),\n                    source: None,\n                });\n            }\n        }\n\n        // Process through route middleware\n        let processed_payload = if let Some(ref middleware) = route.middleware {\n            // Convert RequestContext to MiddlewareContext\n            let middleware_context = crate::middleware::MiddlewareContext {\n                correlation_id: context.correlation_id,\n                channel: context.channel.clone(),\n                operation: context.operation.clone(),\n                timestamp: chrono::DateTime::from(context.timestamp),\n                metadata: context.metadata.clone(),\n            };\n            middleware.process_inbound(&middleware_context, payload).await?\n        } else {\n            payload.to_vec()\n        };\n\n        // Route to handler\n        let result = match &route.destination {\n            RouteDestination::Handler { channel, operation } => {\n                handlers.route_message(channel, operation, &processed_payload).await?;\n                RouteResult::Handled\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                let mut results = Vec::new();\n                for dest in destinations {\n                    match handlers.route_message(&dest.channel, &dest.operation, &processed_payload).await {\n                        Ok(()) => results.push(dest.clone()),\n                        Err(e) => {\n                            warn!(\n                                correlation_id = %context.correlation_id,\n                                channel = %dest.channel,\n                                operation = %dest.operation,\n                                error = %e,\n                                \"Failed to route to one of multiple destinations\"\n                            );\n                        }\n                    }\n                }\n                RouteResult::MultipleHandled(results)\n            }\n            RouteDestination::Custom { handler } => {\n                handler(context, &processed_payload).await?;\n                RouteResult::CustomHandled\n            }\n        };\n\n        Ok(result)\n    }\n\n    /// Find static route\n    async fn find_static_route(&self, channel: &str, operation: &str) -> Option<Route> {\n        let routes = self.static_routes.read().await;\n        let route_key = format!(\"{}:{}\", channel, operation);\n        routes.get(&route_key).cloned()\n    }\n\n    /// Find pattern route with parameter extraction\n    async fn find_pattern_route(&self, channel: &str, operation: &str) -> Option<(Route, HashMap<String, String>)> {\n        let routes = self.pattern_routes.read().await;\n        let route_path = format!(\"{}:{}\", channel, operation);\n\n        for pattern_route in routes.iter() {\n            if let Some(captures) = pattern_route.regex.captures(&route_path) {\n                let mut params = HashMap::new();\n\n                // Extract named parameters\n                for name in pattern_route.regex.capture_names().flatten() {\n                    if let Some(value) = captures.name(name) {\n                        params.insert(name.to_string(), value.as_str().to_string());\n                    }\n                }\n\n                return Some((pattern_route.route.clone(), params));\n            }\n        }\n\n        None\n    }\n\n    /// Find content-based route\n    async fn find_content_route(&self, payload: &[u8], context: &RequestContext) -> AsyncApiResult<Option<Route>> {\n        let routes = self.content_routes.read().await;\n\n        for content_route in routes.iter() {\n            if content_route.matcher.matches(payload, context).await? {\n                return Ok(Some(content_route.route.clone()));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Get default route\n    async fn get_default_route(&self) -> Option<Route> {\n        self.default_route.read().await.clone()\n    }\n\n    /// Cache a route for performance\n    async fn cache_route(&self, key: String, route: Route) {\n        let mut cache = self.route_cache.write().await;\n\n        // Implement LRU eviction if cache is full\n        if cache.len() >= self.max_cache_size {\n            // Remove oldest entry (simple implementation)\n            if let Some(oldest_key) = cache.keys().next().cloned() {\n                cache.remove(&oldest_key);\n            }\n        }\n\n        cache.insert(key, CachedRoute {\n            route,\n            cached_at: Instant::now(),\n        });\n    }\n\n    /// Get cached route\n    async fn get_cached_route(&self, key: &str) -> Option<CachedRoute> {\n        let cache = self.route_cache.read().await;\n        cache.get(key).cloned()\n    }\n\n    /// Clear route cache\n    async fn clear_cache(&self) {\n        let mut cache = self.route_cache.write().await;\n        cache.clear();\n        debug!(\"Route cache cleared\");\n    }\n\n    /// Record route performance metric\n    async fn record_route_metric(&self, metric_type: RouteMetric, duration: Duration) {\n        let mut metrics = self.metrics.write().await;\n        metrics.record_metric(metric_type, duration);\n    }\n\n    /// Get router statistics\n    pub async fn get_statistics(&self) -> RouterStatistics {\n        let metrics = self.metrics.read().await;\n        let static_routes = self.static_routes.read().await;\n        let pattern_routes = self.pattern_routes.read().await;\n        let content_routes = self.content_routes.read().await;\n        let cache = self.route_cache.read().await;\n\n        RouterStatistics {\n            static_route_count: static_routes.len(),\n            pattern_route_count: pattern_routes.len(),\n            content_route_count: content_routes.len(),\n            cache_size: cache.len(),\n            cache_hit_rate: metrics.cache_hit_rate(),\n            average_route_time: metrics.average_route_time(),\n            total_routes: metrics.total_routes,\n        }\n    }\n\n    /// Initialize with default routes from AsyncAPI specification\n    pub async fn initialize_default_routes(&self) -> AsyncApiResult<()> {\n        info!(\"Initializing default routes from AsyncAPI specification\");\n\n        ${channelData.map(channel => `\n        // Routes for ${channel.name}\n        ${channel.operations.map(op => `\n        self.add_static_route(Route {\n            channel: \"${channel.name}\".to_string(),\n            operation: \"${op.name}\".to_string(),\n            priority: RequestPriority::Normal,\n            destination: RouteDestination::Handler {\n                channel: \"${channel.name}\".to_string(),\n                operation: \"${op.name}\".to_string(),\n            },\n            guards: Vec::new(),\n            middleware: None,\n            metadata: HashMap::new(),\n        }).await?;`).join('\\n        ')}\n        `).join('\\n')}\n\n        // Add pattern routes for common patterns\n        self.add_pattern_route(PatternRoute {\n            pattern: r\"(?P<channel>[^:]+):(?P<operation>.+)\".to_string(),\n            regex: Regex::new(r\"(?P<channel>[^:]+):(?P<operation>.+)\").unwrap(),\n            route: Route {\n                channel: \"dynamic\".to_string(),\n                operation: \"dynamic\".to_string(),\n                priority: RequestPriority::Low,\n                destination: RouteDestination::Handler {\n                    channel: \"dynamic\".to_string(),\n                    operation: \"dynamic\".to_string(),\n                },\n                guards: Vec::new(),\n                middleware: None,\n                metadata: HashMap::new(),\n            },\n        }).await?;\n\n        info!(\"Default routes initialized successfully\");\n        Ok(())\n    }\n}\n\nimpl Default for Router {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Individual route definition\npub struct Route {\n    /// Channel pattern\n    pub channel: String,\n    /// Operation pattern\n    pub operation: String,\n    /// Route priority for conflict resolution\n    pub priority: RequestPriority,\n    /// Route destination\n    pub destination: RouteDestination,\n    /// Route guards for validation\n    pub guards: Vec<RouteGuard>,\n    /// Route-specific middleware\n    pub middleware: Option<MiddlewarePipeline>,\n    /// Route metadata\n    pub metadata: HashMap<String, String>,\n}\n\nimpl std::fmt::Debug for Route {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Route\")\n            .field(\"channel\", &self.channel)\n            .field(\"operation\", &self.operation)\n            .field(\"priority\", &self.priority)\n            .field(\"destination\", &self.destination)\n            .field(\"guards\", &self.guards)\n            .field(\"middleware\", &self.middleware.is_some())\n            .field(\"metadata\", &self.metadata)\n            .finish()\n    }\n}\n\nimpl Clone for Route {\n    fn clone(&self) -> Self {\n        Self {\n            channel: self.channel.clone(),\n            operation: self.operation.clone(),\n            priority: self.priority,\n            destination: self.destination.clone(),\n            guards: self.guards.clone(),\n            middleware: None, // Can't clone MiddlewarePipeline, so set to None\n            metadata: self.metadata.clone(),\n        }\n    }\n}\n\n/// Route destination types\npub enum RouteDestination {\n    /// Route to a specific handler\n    Handler { channel: String, operation: String },\n    /// Route to multiple handlers (fan-out)\n    MultipleHandlers { destinations: Vec<HandlerDestination> },\n    /// Route to a custom function\n    Custom {\n        #[allow(clippy::type_complexity)]\n        handler: Arc<dyn Fn(&RequestContext, &[u8]) -> std::pin::Pin<Box<dyn std::future::Future<Output = AsyncApiResult<()>> + Send>> + Send + Sync>\n    },\n}\n\nimpl std::fmt::Debug for RouteDestination {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            RouteDestination::Handler { channel, operation } => {\n                f.debug_struct(\"Handler\")\n                    .field(\"channel\", channel)\n                    .field(\"operation\", operation)\n                    .finish()\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                f.debug_struct(\"MultipleHandlers\")\n                    .field(\"destinations\", destinations)\n                    .finish()\n            }\n            RouteDestination::Custom { .. } => {\n                f.debug_struct(\"Custom\")\n                    .field(\"handler\", &\"<function>\")\n                    .finish()\n            }\n        }\n    }\n}\n\nimpl Clone for RouteDestination {\n    fn clone(&self) -> Self {\n        match self {\n            RouteDestination::Handler { channel, operation } => {\n                RouteDestination::Handler {\n                    channel: channel.clone(),\n                    operation: operation.clone(),\n                }\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                RouteDestination::MultipleHandlers {\n                    destinations: destinations.clone(),\n                }\n            }\n            RouteDestination::Custom { handler } => {\n                RouteDestination::Custom {\n                    handler: handler.clone(),\n                }\n            }\n        }\n    }\n}\n\n/// Handler destination for multi-routing\n#[derive(Debug, Clone)]\npub struct HandlerDestination {\n    pub channel: String,\n    pub operation: String,\n}\n\n/// Pattern-based route with regex matching\n#[derive(Debug)]\npub struct PatternRoute {\n    /// Original pattern string\n    pub pattern: String,\n    /// Compiled regex for matching\n    pub regex: Regex,\n    /// Route definition\n    pub route: Route,\n}\n\n/// Content-based route that examines message payload\n#[derive(Debug)]\npub struct ContentRoute {\n    /// Route name for identification\n    pub name: String,\n    /// Content matcher\n    pub matcher: Box<dyn ContentMatcher + Send + Sync>,\n    /// Route definition\n    pub route: Route,\n}\n\n/// Trait for content-based routing\n#[async_trait::async_trait]\npub trait ContentMatcher: std::fmt::Debug {\n    /// Check if the content matches this route\n    async fn matches(&self, payload: &[u8], context: &RequestContext) -> AsyncApiResult<bool>;\n}\n\n/// JSON field matcher for content-based routing\n#[derive(Debug)]\npub struct JsonFieldMatcher {\n    pub field_path: String,\n    pub expected_value: serde_json::Value,\n}\n\n#[async_trait::async_trait]\nimpl ContentMatcher for JsonFieldMatcher {\n    async fn matches(&self, payload: &[u8], _context: &RequestContext) -> AsyncApiResult<bool> {\n        match serde_json::from_slice::<serde_json::Value>(payload) {\n            Ok(json) => {\n                let field_value = json.pointer(&self.field_path);\n                Ok(field_value == Some(&self.expected_value))\n            }\n            Err(_) => Ok(false), // Not JSON, doesn't match\n        }\n    }\n}\n\n/// Route guard for pre-routing validation\npub struct RouteGuard {\n    pub name: String,\n    #[allow(clippy::type_complexity)]\n    pub check: Arc<dyn Fn(&RequestContext, &[u8]) -> std::pin::Pin<Box<dyn std::future::Future<Output = AsyncApiResult<bool>> + Send>> + Send + Sync>,\n}\n\nimpl std::fmt::Debug for RouteGuard {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"RouteGuard\")\n            .field(\"name\", &self.name)\n            .field(\"check\", &\"<function>\")\n            .finish()\n    }\n}\n\nimpl Clone for RouteGuard {\n    fn clone(&self) -> Self {\n        Self {\n            name: self.name.clone(),\n            check: self.check.clone(),\n        }\n    }\n}\n\n/// Cached route entry\n#[derive(Debug, Clone)]\npub struct CachedRoute {\n    pub route: Route,\n    pub cached_at: Instant,\n}\n\n/// Route execution result\n#[derive(Debug)]\npub enum RouteResult {\n    /// Message was handled by a single handler\n    Handled,\n    /// Message was handled by multiple handlers\n    MultipleHandled(Vec<HandlerDestination>),\n    /// Message was handled by a custom handler\n    CustomHandled,\n}\n\n/// Router performance metrics\n#[derive(Debug)]\npub struct RouterMetrics {\n    pub total_routes: u64,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n    pub static_matches: u64,\n    pub pattern_matches: u64,\n    pub content_matches: u64,\n    pub default_routes: u64,\n    pub no_matches: u64,\n    pub route_times: Vec<Duration>,\n}\n\nimpl RouterMetrics {\n    pub fn new() -> Self {\n        Self {\n            total_routes: 0,\n            cache_hits: 0,\n            cache_misses: 0,\n            static_matches: 0,\n            pattern_matches: 0,\n            content_matches: 0,\n            default_routes: 0,\n            no_matches: 0,\n            route_times: Vec::new(),\n        }\n    }\n\n    pub fn record_metric(&mut self, metric_type: RouteMetric, duration: Duration) {\n        self.total_routes += 1;\n        self.route_times.push(duration);\n\n        // Keep only last 1000 measurements\n        if self.route_times.len() > 1000 {\n            self.route_times.remove(0);\n        }\n\n        match metric_type {\n            RouteMetric::CacheHit => self.cache_hits += 1,\n            RouteMetric::CacheMiss => self.cache_misses += 1,\n            RouteMetric::StaticMatch => self.static_matches += 1,\n            RouteMetric::PatternMatch => self.pattern_matches += 1,\n            RouteMetric::ContentMatch => self.content_matches += 1,\n            RouteMetric::DefaultRoute => self.default_routes += 1,\n            RouteMetric::NoMatch => self.no_matches += 1,\n        }\n    }\n\n    pub fn cache_hit_rate(&self) -> f64 {\n        let total_cache_attempts = self.cache_hits + self.cache_misses;\n        if total_cache_attempts > 0 {\n            self.cache_hits as f64 / total_cache_attempts as f64\n        } else {\n            0.0\n        }\n    }\n\n    pub fn average_route_time(&self) -> Duration {\n        if self.route_times.is_empty() {\n            Duration::ZERO\n        } else {\n            let total: Duration = self.route_times.iter().sum();\n            total / self.route_times.len() as u32\n        }\n    }\n}\n\n/// Route metric types\n#[derive(Debug, Clone, Copy)]\npub enum RouteMetric {\n    CacheHit,\n    CacheMiss,\n    StaticMatch,\n    PatternMatch,\n    ContentMatch,\n    DefaultRoute,\n    NoMatch,\n}\n\n/// Router statistics for monitoring\n#[derive(Debug, Clone, Serialize)]\npub struct RouterStatistics {\n    pub static_route_count: usize,\n    pub pattern_route_count: usize,\n    pub content_route_count: usize,\n    pub cache_size: usize,\n    pub cache_hit_rate: f64,\n    pub average_route_time: Duration,\n    pub total_routes: u64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_static_route_matching() {\n        let router = Router::new();\n\n        let route = Route {\n            channel: \"test/channel\".to_string(),\n            operation: \"test_operation\".to_string(),\n            priority: RequestPriority::Normal,\n            destination: RouteDestination::Handler {\n                channel: \"test/channel\".to_string(),\n                operation: \"test_operation\".to_string(),\n            },\n            guards: Vec::new(),\n            middleware: None,\n            metadata: HashMap::new(),\n        };\n\n        router.add_static_route(route).await.unwrap();\n\n        let found_route = router.find_static_route(\"test/channel\", \"test_operation\").await;\n        assert!(found_route.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_pattern_route_matching() {\n        let router = Router::new();\n\n        let pattern_route = PatternRoute {\n            pattern: r\"user/(?P<user_id>\\d+):update\".to_string(),\n            regex: Regex::new(r\"user/(?P<user_id>\\d+):update\").unwrap(),\n            route: Route {\n                channel: \"user\".to_string(),\n                operation: \"update\".to_string(),\n                priority: RequestPriority::Normal,\n                destination: RouteDestination::Handler {\n                    channel: \"user\".to_string(),\n                    operation: \"update\".to_string(),\n                },\n                guards: Vec::new(),\n                middleware: None,\n                metadata: HashMap::new(),\n            },\n        };\n\n        router.add_pattern_route(pattern_route).await.unwrap();\n\n        let (route, params) = router.find_pattern_route(\"user/123\", \"update\").await.unwrap();\n        assert_eq!(route.channel, \"user\");\n        assert_eq!(params.get(\"user_id\"), Some(&\"123\".to_string()));\n    }\n\n    #[test]\n    fn test_json_field_matcher() {\n        let matcher = JsonFieldMatcher {\n            field_path: \"/type\".to_string(),\n            expected_value: serde_json::Value::String(\"user_created\".to_string()),\n        };\n\n        let payload = r#\"{\"type\": \"user_created\", \"user_id\": 123}\"#.as_bytes();\n        // Note: This would need to be an async test in practice\n        // assert!(matcher.matches(payload, &context).await.unwrap());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function ServerModRs() {\n    return (\n        <File name=\"mod.rs\">\n            {`//! Server module for AsyncAPI service\n//!\n//! This module provides the main server implementation and builder pattern\n//! for constructing servers with various configurations and middleware.\n\npub mod builder;\n\npub use builder::{ServerBuilder, ServerConfig};\n\nuse crate::config::Config;\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse crate::handlers::HandlerRegistry;\nuse crate::middleware::MiddlewarePipeline;\nuse crate::context::ContextManager;\nuse crate::router::Router;\nuse crate::recovery::RecoveryManager;\n\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{info, warn, error, debug};\n\n/// Main server struct that orchestrates all components\npub struct Server {\n    config: Config,\n    handlers: Arc<RwLock<HandlerRegistry>>,\n    context_manager: Arc<ContextManager>,\n    router: Arc<Router>,\n    middleware: MiddlewarePipeline,\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl Server {\n    /// Create a new server with default configuration\n    pub async fn new(config: Config) -> AsyncApiResult<Self> {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n        let context_manager = Arc::new(ContextManager::new());\n        let router = Arc::new(Router::new());\n        let handlers = Arc::new(RwLock::new(\n            HandlerRegistry::with_recovery_manager(recovery_manager.clone())\n        ));\n        let middleware = MiddlewarePipeline::new(recovery_manager.clone());\n\n        // Initialize router with default routes\n        router.initialize_default_routes().await?;\n\n        Ok(Self {\n            config,\n            handlers,\n            context_manager,\n            router,\n            middleware,\n            recovery_manager,\n        })\n    }\n\n    /// Create a new server with custom configuration\n    pub async fn new_with_config(\n        config: Config,\n        handlers: Arc<RwLock<HandlerRegistry>>,\n        context_manager: Arc<ContextManager>,\n        router: Arc<Router>,\n        middleware: MiddlewarePipeline,\n    ) -> AsyncApiResult<Self> {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n\n        Ok(Self {\n            config,\n            handlers,\n            context_manager,\n            router,\n            middleware,\n            recovery_manager,\n        })\n    }\n\n    /// Start the server\n    pub async fn start(&self) -> AsyncApiResult<()> {\n        info!(\"Starting AsyncAPI server on {}:{}\",\n              self.config.host,\n              self.config.port);\n\n        // Initialize all components\n        self.initialize_components().await?;\n\n        // Start the main server loop\n        self.run_server_loop().await?;\n\n        Ok(())\n    }\n\n    /// Stop the server gracefully\n    pub async fn stop(&self) -> AsyncApiResult<()> {\n        info!(\"Stopping AsyncAPI server gracefully\");\n\n        // Perform cleanup operations\n        self.cleanup().await?;\n\n        info!(\"Server stopped successfully\");\n        Ok(())\n    }\n\n    /// Initialize all server components\n    async fn initialize_components(&self) -> AsyncApiResult<()> {\n        debug!(\"Initializing server components\");\n\n        // Components are already initialized during construction\n        debug!(\"Context manager ready\");\n        debug!(\"Middleware pipeline ready\");\n        debug!(\"Recovery manager ready\");\n\n        debug!(\"All server components initialized successfully\");\n        Ok(())\n    }\n\n    /// Main server loop\n    async fn run_server_loop(&self) -> AsyncApiResult<()> {\n        debug!(\"Starting main server loop\");\n\n        // This is where the actual server logic would run\n        // For now, we'll just keep the server alive\n        loop {\n            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n\n            // Check if we should continue running\n            if self.should_shutdown().await {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check if the server should shutdown\n    async fn should_shutdown(&self) -> bool {\n        // For now, never shutdown automatically\n        // In a real implementation, this would check for shutdown signals\n        false\n    }\n\n    /// Cleanup server resources\n    async fn cleanup(&self) -> AsyncApiResult<()> {\n        debug!(\"Cleaning up server resources\");\n\n        // Cleanup handlers\n        debug!(\"Handlers cleanup completed\");\n\n        // Cleanup middleware\n        debug!(\"Middleware cleanup completed\");\n\n        // Cleanup context manager\n        debug!(\"Context manager cleanup completed\");\n\n        // Cleanup recovery manager\n        debug!(\"Recovery manager cleanup completed\");\n\n        debug!(\"Server cleanup completed\");\n        Ok(())\n    }\n\n    /// Get server configuration\n    pub fn config(&self) -> &Config {\n        &self.config\n    }\n\n    /// Get handler registry\n    pub fn handlers(&self) -> Arc<RwLock<HandlerRegistry>> {\n        self.handlers.clone()\n    }\n\n    /// Get context manager\n    pub fn context_manager(&self) -> Arc<ContextManager> {\n        self.context_manager.clone()\n    }\n\n    /// Get router\n    pub fn router(&self) -> Arc<Router> {\n        self.router.clone()\n    }\n\n    /// Get middleware pipeline\n    pub fn middleware(&self) -> &MiddlewarePipeline {\n        &self.middleware\n    }\n\n    /// Get recovery manager\n    pub fn recovery_manager(&self) -> Arc<RecoveryManager> {\n        self.recovery_manager.clone()\n    }\n\n    /// Health check endpoint\n    pub async fn health_check(&self) -> AsyncApiResult<HealthStatus> {\n        debug!(\"Performing health check\");\n\n        let mut status = HealthStatus::new();\n\n        // Check handlers\n        status.handlers = ComponentHealth::Healthy;\n\n        // Check middleware\n        status.middleware = ComponentHealth::Healthy;\n\n        // Check context manager\n        status.context_manager = ComponentHealth::Healthy;\n\n        // Check recovery manager\n        status.recovery_manager = ComponentHealth::Healthy;\n\n        // Overall status\n        status.overall = if status.all_healthy() {\n            ComponentHealth::Healthy\n        } else {\n            ComponentHealth::Unhealthy\n        };\n\n        debug!(\"Health check completed: {:?}\", status.overall);\n        Ok(status)\n    }\n\n    /// Start HTTP handler\n    pub async fn start_http_handler(&self) -> AsyncApiResult<()> {\n        info!(\"Starting HTTP handler on {}:{}\", self.config.host, self.config.port);\n\n        // Initialize HTTP transport\n        // For now, just log that we're starting\n        debug!(\"HTTP handler started successfully\");\n        Ok(())\n    }\n\n    /// Shutdown the server\n    pub async fn shutdown(&self) -> AsyncApiResult<()> {\n        info!(\"Shutting down server\");\n        self.stop().await\n    }\n}\n\n/// Health status for the server and its components\n#[derive(Debug, Clone)]\npub struct HealthStatus {\n    pub overall: ComponentHealth,\n    pub handlers: ComponentHealth,\n    pub middleware: ComponentHealth,\n    pub context_manager: ComponentHealth,\n    pub recovery_manager: ComponentHealth,\n}\n\nimpl HealthStatus {\n    pub fn new() -> Self {\n        Self {\n            overall: ComponentHealth::Unknown,\n            handlers: ComponentHealth::Unknown,\n            middleware: ComponentHealth::Unknown,\n            context_manager: ComponentHealth::Unknown,\n            recovery_manager: ComponentHealth::Unknown,\n        }\n    }\n\n    pub fn all_healthy(&self) -> bool {\n        matches!(self.handlers, ComponentHealth::Healthy) &&\n        matches!(self.middleware, ComponentHealth::Healthy) &&\n        matches!(self.context_manager, ComponentHealth::Healthy) &&\n        matches!(self.recovery_manager, ComponentHealth::Healthy)\n    }\n}\n\n/// Health status for individual components\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ComponentHealth {\n    Healthy,\n    Unhealthy,\n    Unknown,\n}\n\nimpl Default for HealthStatus {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_server_creation() {\n        let config = Config::default();\n        let server = Server::new(config).await;\n        assert!(server.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let config = Config::default();\n        let server = Server::new(config).await.unwrap();\n        let health = server.health_check().await;\n        assert!(health.is_ok());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function ServerBuilderRs() {\n    return (\n        <File name=\"builder.rs\">\n            {`//! Server builder for flexible server construction with optional components\n//!\n//! This module provides a fluent builder API for constructing servers with\n//! optional middleware, monitoring, authentication, and other advanced features.\n//! Uses derive_builder for clean, maintainable builder pattern implementation.\n\nuse crate::config::Config;\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse crate::middleware::{Middleware, MiddlewarePipeline};\nuse crate::recovery::RecoveryManager;\nuse crate::context::ContextManager;\nuse crate::router::Router;\nuse crate::handlers::HandlerRegistry;\nuse crate::server::Server;\nuse derive_builder::Builder;\nuse std::sync::Arc;\nuse std::collections::HashMap;\nuse tracing::{info, debug, warn};\n\n#[cfg(feature = \"prometheus\")]\nuse crate::metrics::prometheus::PrometheusMetrics;\n\n#[cfg(feature = \"opentelemetry\")]\nuse crate::tracing::opentelemetry::OpenTelemetryTracing;\n\n#[cfg(feature = \"auth\")]\nuse crate::auth::{AuthConfig, AuthMiddleware};\n\n#[cfg(feature = \"connection-pooling\")]\nuse crate::pool::{PoolConfig, ConnectionPoolManager};\n\n#[cfg(feature = \"batching\")]\nuse crate::batching::{BatchConfig, BatchProcessor};\n\n#[cfg(feature = \"dynamic-config\")]\nuse crate::config::dynamic::DynamicConfigManager;\n\n#[cfg(feature = \"feature-flags\")]\nuse crate::features::{FeatureFlags, FeatureManager};\n\n/// Configuration for server construction with optional components\n#[derive(Builder)]\n#[builder(setter(into, strip_option), build_fn(validate = \"Self::validate\"))]\npub struct ServerConfig {\n    /// Base server configuration\n    pub config: Config,\n\n    /// Middleware components to add to the pipeline\n    #[builder(default = \"Vec::new()\", setter(skip))]\n    pub middleware: Vec<Box<dyn Middleware>>,\n\n    /// Feature flags configuration\n    #[builder(default = \"None\")]\n    pub feature_flags: Option<std::collections::HashMap<String, bool>>,\n\n    /// Authentication configuration\n    #[cfg(feature = \"auth\")]\n    #[builder(default = \"None\")]\n    pub auth_config: Option<AuthConfig>,\n\n    /// Connection pool configuration\n    #[cfg(feature = \"connection-pooling\")]\n    #[builder(default = \"None\")]\n    pub pool_config: Option<PoolConfig>,\n\n    /// Message batching configuration\n    #[cfg(feature = \"batching\")]\n    #[builder(default = \"None\")]\n    pub batch_config: Option<BatchConfig>,\n\n    /// Enable Prometheus metrics\n    #[builder(default = \"false\")]\n    pub prometheus_enabled: bool,\n\n    /// Enable OpenTelemetry tracing\n    #[builder(default = \"false\")]\n    pub opentelemetry_enabled: bool,\n\n    /// Enable dynamic configuration\n    #[builder(default = \"false\")]\n    pub dynamic_config_enabled: bool,\n\n    /// Custom properties for extensibility\n    #[builder(default = \"HashMap::new()\")]\n    pub custom_properties: HashMap<String, String>,\n}\n\n/// Type alias for the generated builder\npub type ServerBuilder = ServerConfigBuilder;\n\nimpl std::fmt::Debug for ServerConfig {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        let mut debug_struct = f.debug_struct(\"ServerConfig\");\n        debug_struct\n            .field(\"config\", &self.config)\n            .field(\"middleware_count\", &self.middleware.len())\n            .field(\"feature_flags\", &self.feature_flags);\n\n        #[cfg(feature = \"auth\")]\n        {\n            debug_struct.field(\"auth_config\", &self.auth_config);\n        }\n\n        #[cfg(feature = \"connection-pooling\")]\n        {\n            debug_struct.field(\"pool_config\", &self.pool_config);\n        }\n\n        #[cfg(feature = \"batching\")]\n        {\n            debug_struct.field(\"batch_config\", &self.batch_config);\n        }\n\n        debug_struct\n            .field(\"prometheus_enabled\", &self.prometheus_enabled)\n            .field(\"opentelemetry_enabled\", &self.opentelemetry_enabled)\n            .field(\"dynamic_config_enabled\", &self.dynamic_config_enabled)\n            .field(\"custom_properties\", &self.custom_properties)\n            .finish()\n    }\n}\n\nimpl ServerConfigBuilder {\n    /// Validate the configuration during build\n    fn validate(&self) -> Result<(), String> {\n        // Check for conflicting configurations\n        if self.prometheus_enabled.unwrap_or(false) && !cfg!(feature = \"prometheus\") {\n            return Err(\"Prometheus metrics enabled but 'prometheus' feature not compiled\".to_string());\n        }\n\n        if self.opentelemetry_enabled.unwrap_or(false) && !cfg!(feature = \"opentelemetry\") {\n            return Err(\"OpenTelemetry tracing enabled but 'opentelemetry' feature not compiled\".to_string());\n        }\n\n        // Validate auth configuration\n        #[cfg(feature = \"auth\")]\n        if let Some(ref auth_config) = self.auth_config {\n            if let Some(auth_config) = auth_config {\n                // Add auth config validation here\n            }\n        }\n\n        Ok(())\n    }\n}\n\nimpl ServerConfig {\n    /// Build the server with all configured components\n    pub async fn build_server(self) -> AsyncApiResult<Server> {\n        info!(\"Building server with configured components\");\n\n        // Initialize recovery manager\n        let recovery_manager = Arc::new(RecoveryManager::default());\n\n        // Initialize context manager\n        let context_manager = Arc::new(ContextManager::new());\n\n        // Initialize router\n        let router = Arc::new(Router::new());\n        router.initialize_default_routes().await?;\n\n        // Initialize handler registry\n        let handlers = Arc::new(tokio::sync::RwLock::new(\n            HandlerRegistry::with_recovery_manager(recovery_manager.clone())\n        ));\n\n        // Build middleware pipeline\n        let middleware_pipeline = self.build_middleware_pipeline(recovery_manager.clone()).await?;\n\n        // Create the server\n        let server = Server::new_with_config(\n            self.config,\n            handlers,\n            context_manager,\n            router,\n            middleware_pipeline,\n        ).await?;\n\n        info!(\"Server built successfully with {} middleware components\",\n              self.middleware.len());\n\n        Ok(server)\n    }\n\n    /// Build the middleware pipeline with all configured middleware\n    async fn build_middleware_pipeline(&self, recovery_manager: Arc<RecoveryManager>) -> AsyncApiResult<MiddlewarePipeline> {\n        debug!(\"Building middleware pipeline\");\n\n        let pipeline = MiddlewarePipeline::new(recovery_manager);\n\n        // Add authentication middleware if configured\n        #[cfg(feature = \"auth\")]\n        if let Some(auth_config) = &self.auth_config {\n            let auth_middleware = AuthMiddleware::new(auth_config.clone());\n            pipeline = pipeline.add_middleware(auth_middleware);\n        }\n\n        // Add Prometheus metrics middleware if enabled\n        #[cfg(feature = \"prometheus\")]\n        if self.prometheus_enabled {\n            let metrics_middleware = crate::middleware::MetricsMiddleware::with_prometheus();\n            pipeline = pipeline.add_middleware(metrics_middleware);\n        }\n\n        // Add OpenTelemetry tracing middleware if enabled\n        #[cfg(feature = \"opentelemetry\")]\n        if self.opentelemetry_enabled {\n            let tracing_middleware = crate::middleware::TracingMiddleware::new();\n            pipeline = pipeline.add_middleware(tracing_middleware);\n        }\n\n        // Add user-configured middleware\n        for _middleware in &self.middleware {\n            // Note: This would need to be cloned or we'd need a different approach\n            // for now, we'll document this limitation\n        }\n\n        debug!(\"Middleware pipeline built successfully\");\n        Ok(pipeline)\n    }\n}\n\n/// Convenience constructors for common server configurations\nimpl ServerBuilder {\n    /// Create a minimal server with basic logging\n    pub fn minimal(config: Config) -> Self {\n        let mut builder = Self::default();\n        builder.config(config);\n        builder.prometheus_enabled(false);\n        builder.opentelemetry_enabled(false);\n        builder\n    }\n\n    /// Create a development server with enhanced debugging\n    pub fn development(config: Config) -> Self {\n        let mut builder = Self::default();\n        builder.config(config);\n        builder.prometheus_enabled(false);\n        builder.opentelemetry_enabled(false);\n        builder\n    }\n\n    /// Create a production server with all monitoring and security features\n    pub fn production(config: Config) -> Self {\n        let mut builder = Self::default();\n        builder.config(config);\n\n        // Add optional production features if available\n        #[cfg(feature = \"prometheus\")]\n        {\n            builder.prometheus_enabled(true);\n        }\n\n        #[cfg(feature = \"opentelemetry\")]\n        {\n            builder.opentelemetry_enabled(true);\n        }\n\n        builder\n    }\n\n    /// Add middleware to the builder\n    pub fn add_middleware<M: Middleware + 'static>(self, _middleware: M) -> Self {\n        // Since we can't use the generated setter, we need to handle this manually\n        // For now, we'll document this as a limitation and provide alternative approaches\n        self\n    }\n\n    /// Add middleware conditionally\n    pub fn conditional_middleware<F, M>(self, _condition: F) -> Self\n    where\n        F: FnOnce(&Config) -> Option<M>,\n        M: Middleware + 'static,\n    {\n        // This would need access to config to evaluate the condition\n        // For now, return self unchanged\n        self\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_minimal_server_build() {\n        let config = Config::default();\n        let server = ServerBuilder::minimal(config).build().await;\n        assert!(server.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_builder_with_middleware() {\n        let config = Config::default();\n        let server = ServerBuilder::new(config)\n            .with_middleware(crate::middleware::LoggingMiddleware::default())\n            .build()\n            .await;\n        assert!(server.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_conditional_middleware() {\n        let config = Config::default();\n        let server = ServerBuilder::new(config)\n            .conditional_middleware(|_config| {\n                Some(crate::middleware::LoggingMiddleware::default())\n            })\n            .build()\n            .await;\n        assert!(server.is_ok());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function MiddlewareRs() {\n    return (\n        <File name=\"middleware.rs\">\n            {`//! Enhanced middleware for request/response processing with comprehensive error handling\n//!\n//! This module provides:\n//! - Error-aware middleware pipeline\n//! - Metrics collection and monitoring\n//! - Request/response validation\n//! - Performance tracking\n//! - Security and rate limiting\n\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse crate::context::RequestContext;\nuse crate::recovery::RecoveryManager;\nuse async_trait::async_trait;\nuse tracing::{info, warn, error, debug, instrument};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\n\n/// Enhanced middleware trait for processing messages with error handling\n#[async_trait::async_trait]\npub trait Middleware: Send + Sync {\n    /// Process inbound messages with error handling\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>>;\n\n    /// Process outbound messages with error handling\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>>;\n\n    /// Get middleware name for logging and metrics\n    fn name(&self) -> &'static str;\n\n    /// Check if middleware is enabled\n    fn is_enabled(&self) -> bool {\n        true\n    }\n}\n\n/// Context for middleware processing with correlation tracking\n#[derive(Debug, Clone)]\npub struct MiddlewareContext {\n    pub correlation_id: Uuid,\n    pub channel: String,\n    pub operation: String,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    pub metadata: std::collections::HashMap<String, String>,\n}\n\nimpl MiddlewareContext {\n    pub fn new(channel: &str, operation: &str) -> Self {\n        Self {\n            correlation_id: Uuid::new_v4(),\n            channel: channel.to_string(),\n            operation: operation.to_string(),\n            timestamp: chrono::Utc::now(),\n            metadata: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n}\n\n/// Logging middleware that logs all message traffic with enhanced context\npub struct LoggingMiddleware {\n    log_payloads: bool,\n    max_payload_log_size: usize,\n}\n\nimpl LoggingMiddleware {\n    pub fn new(log_payloads: bool, max_payload_log_size: usize) -> Self {\n        Self {\n            log_payloads,\n            max_payload_log_size,\n        }\n    }\n}\n\nimpl Default for LoggingMiddleware {\n    fn default() -> Self {\n        Self::new(false, 100) // Don't log payloads by default for security\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for LoggingMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"logging\",\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let start_time = Instant::now();\n\n        info!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            payload_size = payload.len(),\n            \"Processing inbound message\"\n        );\n\n        if self.log_payloads && !payload.is_empty() {\n            let payload_preview = if payload.len() > self.max_payload_log_size {\n                format!(\"{}... (truncated)\", String::from_utf8_lossy(&payload[..self.max_payload_log_size]))\n            } else {\n                String::from_utf8_lossy(payload).to_string()\n            };\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                payload_preview = %payload_preview,\n                \"Inbound message payload\"\n            );\n        }\n\n        let processing_time = start_time.elapsed();\n        debug!(\n            correlation_id = %context.correlation_id,\n            processing_time_ms = processing_time.as_millis(),\n            \"Logging middleware processing completed\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    #[instrument(skip(self, payload), fields(\n        middleware = \"logging\",\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        info!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            payload_size = payload.len(),\n            \"Processing outbound message\"\n        );\n\n        if self.log_payloads && !payload.is_empty() {\n            let payload_preview = if payload.len() > self.max_payload_log_size {\n                format!(\"{}... (truncated)\", String::from_utf8_lossy(&payload[..self.max_payload_log_size]))\n            } else {\n                String::from_utf8_lossy(payload).to_string()\n            };\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                payload_preview = %payload_preview,\n                \"Outbound message payload\"\n            );\n        }\n\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"logging\"\n    }\n}\n\n/// Metrics middleware for collecting performance data and error rates\npub struct MetricsMiddleware {\n    start_time: Instant,\n    message_count: Arc<RwLock<u64>>,\n    error_count: Arc<RwLock<u64>>,\n    processing_times: Arc<RwLock<Vec<std::time::Duration>>>,\n}\n\nimpl MetricsMiddleware {\n    pub fn new() -> Self {\n        Self {\n            start_time: Instant::now(),\n            message_count: Arc::new(RwLock::new(0)),\n            error_count: Arc::new(RwLock::new(0)),\n            processing_times: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn get_metrics(&self) -> MiddlewareMetrics {\n        let message_count = *self.message_count.read().await;\n        let error_count = *self.error_count.read().await;\n        let processing_times = self.processing_times.read().await;\n\n        let avg_processing_time = if processing_times.is_empty() {\n            std::time::Duration::ZERO\n        } else {\n            let total: std::time::Duration = processing_times.iter().sum();\n            total / processing_times.len() as u32\n        };\n\n        MiddlewareMetrics {\n            uptime: self.start_time.elapsed(),\n            message_count,\n            error_count,\n            error_rate: if message_count > 0 { error_count as f64 / message_count as f64 } else { 0.0 },\n            avg_processing_time,\n        }\n    }\n}\n\nimpl Default for MetricsMiddleware {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for MetricsMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"metrics\",\n        correlation_id = %context.correlation_id,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let start_time = Instant::now();\n\n        // Increment message count\n        {\n            let mut count = self.message_count.write().await;\n            *count += 1;\n        }\n\n        let processing_time = start_time.elapsed();\n\n        // Record processing time\n        {\n            let mut times = self.processing_times.write().await;\n            times.push(processing_time);\n\n            // Keep only last 1000 measurements to prevent memory growth\n            if times.len() > 1000 {\n                times.remove(0);\n            }\n        }\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            processing_time_ms = processing_time.as_millis(),\n            \"Metrics collected for inbound message\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    async fn process_outbound(&self, _context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // For outbound, we just pass through without additional metrics\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"metrics\"\n    }\n}\n\n/// Validation middleware for message schema validation with detailed error reporting\npub struct ValidationMiddleware {\n    strict_mode: bool,\n}\n\nimpl ValidationMiddleware {\n    pub fn new(strict_mode: bool) -> Self {\n        Self { strict_mode }\n    }\n}\n\nimpl Default for ValidationMiddleware {\n    fn default() -> Self {\n        Self::new(true) // Strict validation by default\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for ValidationMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"validation\",\n        correlation_id = %context.correlation_id,\n        strict_mode = self.strict_mode,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        debug!(\n            correlation_id = %context.correlation_id,\n            strict_mode = self.strict_mode,\n            \"Starting message validation\"\n        );\n\n        // Basic payload validation\n        if payload.is_empty() {\n            return Err(AsyncApiError::Validation {\n                message: \"Empty payload received\".to_string(),\n                field: Some(\"payload\".to_string()),\n                metadata: ErrorMetadata::new(\n                    ErrorSeverity::Medium,\n                    ErrorCategory::Validation,\n                    false,\n                ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                 .with_context(\"channel\", &context.channel)\n                 .with_context(\"operation\", &context.operation)\n                 .with_context(\"middleware\", \"validation\"),\n                source: None,\n            });\n        }\n\n        // JSON validation\n        match serde_json::from_slice::<serde_json::Value>(payload) {\n            Ok(json_value) => {\n                debug!(\n                    correlation_id = %context.correlation_id,\n                    message_type = json_value.get(\"type\").and_then(|v| v.as_str()).unwrap_or(\"unknown\"),\n                    \"Message validation successful\"\n                );\n\n                // Additional validation in strict mode\n                if self.strict_mode {\n                    // Check for required fields\n                    if json_value.get(\"type\").is_none() {\n                        warn!(\n                            correlation_id = %context.correlation_id,\n                            \"Missing 'type' field in strict validation mode\"\n                        );\n\n                        return Err(AsyncApiError::Validation {\n                            message: \"Missing required field 'type' in message\".to_string(),\n                            field: Some(\"type\".to_string()),\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::Medium,\n                                ErrorCategory::Validation,\n                                false,\n                            ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                             .with_context(\"validation_mode\", \"strict\"),\n                            source: None,\n                        });\n                    }\n                }\n\n                Ok(payload.to_vec())\n            }\n            Err(e) => {\n                error!(\n                    correlation_id = %context.correlation_id,\n                    error = %e,\n                    payload_preview = %String::from_utf8_lossy(&payload[..payload.len().min(100)]),\n                    \"JSON validation failed\"\n                );\n\n                Err(AsyncApiError::Validation {\n                    message: format!(\"Invalid JSON payload: {}\", e),\n                    field: Some(\"payload\".to_string()),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Validation,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"channel\", &context.channel)\n                     .with_context(\"operation\", &context.operation)\n                     .with_context(\"validation_error\", &e.to_string()),\n                    source: Some(Box::new(e)),\n                })\n            }\n        }\n    }\n\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // Validate outbound messages as well\n        if !payload.is_empty() {\n            match serde_json::from_slice::<serde_json::Value>(payload) {\n                Ok(_) => {\n                    debug!(\n                        correlation_id = %context.correlation_id,\n                        \"Outbound message validation successful\"\n                    );\n                }\n                Err(e) => {\n                    warn!(\n                        correlation_id = %context.correlation_id,\n                        error = %e,\n                        \"Outbound message validation failed\"\n                    );\n                    // For outbound, we might be less strict and just log the warning\n                }\n            }\n        }\n\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"validation\"\n    }\n}\n\n/// Rate limiting middleware to prevent abuse and overload\npub struct RateLimitMiddleware {\n    max_requests_per_minute: u32,\n    request_counts: Arc<RwLock<std::collections::HashMap<String, (u32, Instant)>>>,\n}\n\nimpl RateLimitMiddleware {\n    pub fn new(max_requests_per_minute: u32) -> Self {\n        Self {\n            max_requests_per_minute,\n            request_counts: Arc::new(RwLock::new(std::collections::HashMap::new())),\n        }\n    }\n}\n\nimpl Default for RateLimitMiddleware {\n    fn default() -> Self {\n        Self::new(1000) // 1000 requests per minute by default\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for RateLimitMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"rate_limit\",\n        correlation_id = %context.correlation_id,\n        max_rpm = self.max_requests_per_minute\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let key = format!(\"{}:{}\", context.channel, context.operation);\n        let now = Instant::now();\n\n        {\n            let mut counts = self.request_counts.write().await;\n\n            // Clean up old entries (older than 1 minute)\n            counts.retain(|_, (_, timestamp)| now.duration_since(*timestamp).as_secs() < 60);\n\n            // Check current rate\n            let (count, first_request_time) = counts.entry(key.clone()).or_insert((0, now));\n\n            if now.duration_since(*first_request_time).as_secs() < 60 {\n                if *count >= self.max_requests_per_minute {\n                    warn!(\n                        correlation_id = %context.correlation_id,\n                        channel = %context.channel,\n                        operation = %context.operation,\n                        current_count = *count,\n                        max_allowed = self.max_requests_per_minute,\n                        \"Rate limit exceeded\"\n                    );\n\n                    return Err(AsyncApiError::Resource {\n                        message: format!(\n                            \"Rate limit exceeded: {} requests per minute for {}\",\n                            self.max_requests_per_minute, key\n                        ),\n                        resource_type: \"rate_limit\".to_string(),\n                        metadata: ErrorMetadata::new(\n                            ErrorSeverity::Medium,\n                            ErrorCategory::Resource,\n                            true, // Rate limit errors are retryable after some time\n                        ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                         .with_context(\"rate_limit_key\", &key)\n                         .with_context(\"current_count\", &count.to_string())\n                         .with_context(\"max_allowed\", &self.max_requests_per_minute.to_string()),\n                        source: None,\n                    });\n                }\n                *count += 1;\n            } else {\n                // Reset counter for new minute window\n                *count = 1;\n                *first_request_time = now;\n            }\n        }\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            rate_limit_key = %key,\n            \"Rate limit check passed\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    async fn process_outbound(&self, _context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // No rate limiting for outbound messages\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"rate_limit\"\n    }\n}\n\n/// Middleware pipeline that processes messages through multiple middleware layers\npub struct MiddlewarePipeline {\n    middlewares: Vec<Box<dyn Middleware>>,\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl MiddlewarePipeline {\n    pub fn new(recovery_manager: Arc<RecoveryManager>) -> Self {\n        Self {\n            middlewares: Vec::new(),\n            recovery_manager,\n        }\n    }\n\n    /// Initialize the middleware pipeline\n    pub async fn initialize(&self) -> AsyncApiResult<()> {\n        debug!(\"Initializing middleware pipeline with {} middlewares\", self.middlewares.len());\n        Ok(())\n    }\n\n    /// Cleanup the middleware pipeline\n    pub async fn cleanup(&self) -> AsyncApiResult<()> {\n        debug!(\"Cleaning up middleware pipeline\");\n        Ok(())\n    }\n\n    /// Health check for the middleware pipeline\n    pub async fn health_check(&self) -> AsyncApiResult<crate::server::ComponentHealth> {\n        Ok(crate::server::ComponentHealth::Healthy)\n    }\n\n    /// Add middleware to the pipeline\n    pub fn add_middleware<M: Middleware + 'static>(mut self, middleware: M) -> Self {\n        self.middlewares.push(Box::new(middleware));\n        self\n    }\n\n    /// Process inbound message through all middleware\n    #[instrument(skip(self, payload), fields(\n        pipeline = \"inbound\",\n        middleware_count = self.middlewares.len(),\n        payload_size = payload.len()\n    ))]\n    pub async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let mut current_payload = payload.to_vec();\n\n        for middleware in &self.middlewares {\n            if !middleware.is_enabled() {\n                debug!(\n                    correlation_id = %context.correlation_id,\n                    middleware = middleware.name(),\n                    \"Skipping disabled middleware\"\n                );\n                continue;\n            }\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                middleware = middleware.name(),\n                \"Processing through middleware\"\n            );\n\n            match middleware.process_inbound(context, &current_payload).await {\n                Ok(processed_payload) => {\n                    current_payload = processed_payload;\n                }\n                Err(e) => {\n                    error!(\n                        correlation_id = %context.correlation_id,\n                        middleware = middleware.name(),\n                        error = %e,\n                        \"Middleware processing failed\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n\n        info!(\n            correlation_id = %context.correlation_id,\n            middleware_count = self.middlewares.len(),\n            final_payload_size = current_payload.len(),\n            \"Inbound middleware pipeline completed successfully\"\n        );\n\n        Ok(current_payload)\n    }\n\n    /// Process outbound message through all middleware (in reverse order)\n    #[instrument(skip(self, payload), fields(\n        pipeline = \"outbound\",\n        middleware_count = self.middlewares.len(),\n        payload_size = payload.len()\n    ))]\n    pub async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let mut current_payload = payload.to_vec();\n\n        // Process in reverse order for outbound\n        for middleware in self.middlewares.iter().rev() {\n            if !middleware.is_enabled() {\n                continue;\n            }\n\n            match middleware.process_outbound(context, &current_payload).await {\n                Ok(processed_payload) => {\n                    current_payload = processed_payload;\n                }\n                Err(e) => {\n                    error!(\n                        correlation_id = %context.correlation_id,\n                        middleware = middleware.name(),\n                        error = %e,\n                        \"Outbound middleware processing failed\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n\n        Ok(current_payload)\n    }\n}\n\nimpl Default for MiddlewarePipeline {\n    fn default() -> Self {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n        Self::new(recovery_manager)\n            .add_middleware(LoggingMiddleware::default())\n            .add_middleware(MetricsMiddleware::default())\n            .add_middleware(ValidationMiddleware::default())\n            .add_middleware(RateLimitMiddleware::default())\n    }\n}\n\n/// Metrics collected by middleware\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MiddlewareMetrics {\n    pub uptime: std::time::Duration,\n    pub message_count: u64,\n    pub error_count: u64,\n    pub error_rate: f64,\n    pub avg_processing_time: std::time::Duration,\n}\n`}\n        </File>\n    );\n}\n","export default function RecoveryRs() {\n    return (\n        <File name=\"recovery.rs\">\n            {`//! Error recovery and resilience patterns for AsyncAPI operations\n//!\n//! This module provides:\n//! - Retry mechanisms with exponential backoff\n//! - Circuit breaker pattern for preventing cascade failures\n//! - Bulkhead pattern for failure isolation\n//! - Dead letter queue handling\n//! - Graceful degradation strategies\n\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse std::time::{Duration, Instant};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{info, warn, error, debug};\nuse serde::{Deserialize, Serialize};\n\n/// Retry configuration for different operation types\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RetryConfig {\n    /// Maximum number of retry attempts\n    pub max_attempts: u32,\n    /// Initial delay between retries\n    pub initial_delay: Duration,\n    /// Maximum delay between retries\n    pub max_delay: Duration,\n    /// Backoff multiplier for exponential backoff\n    pub backoff_multiplier: f64,\n    /// Maximum total time to spend retrying\n    pub max_total_time: Duration,\n    /// Jitter factor to add randomness to delays (0.0 to 1.0)\n    pub jitter_factor: f64,\n}\n\nimpl Default for RetryConfig {\n    fn default() -> Self {\n        Self {\n            max_attempts: 3,\n            initial_delay: Duration::from_millis(100),\n            max_delay: Duration::from_secs(30),\n            backoff_multiplier: 2.0,\n            max_total_time: Duration::from_secs(300), // 5 minutes\n            jitter_factor: 0.1,\n        }\n    }\n}\n\nimpl RetryConfig {\n    /// Create a conservative retry config for critical operations\n    pub fn conservative() -> Self {\n        Self {\n            max_attempts: 5,\n            initial_delay: Duration::from_millis(500),\n            max_delay: Duration::from_secs(60),\n            backoff_multiplier: 1.5,\n            max_total_time: Duration::from_secs(600), // 10 minutes\n            jitter_factor: 0.2,\n        }\n    }\n\n    /// Create an aggressive retry config for non-critical operations\n    pub fn aggressive() -> Self {\n        Self {\n            max_attempts: 10,\n            initial_delay: Duration::from_millis(50),\n            max_delay: Duration::from_secs(10),\n            backoff_multiplier: 2.5,\n            max_total_time: Duration::from_secs(120), // 2 minutes\n            jitter_factor: 0.05,\n        }\n    }\n\n    /// Create a fast retry config for real-time operations\n    pub fn fast() -> Self {\n        Self {\n            max_attempts: 2,\n            initial_delay: Duration::from_millis(10),\n            max_delay: Duration::from_millis(500),\n            backoff_multiplier: 2.0,\n            max_total_time: Duration::from_secs(5),\n            jitter_factor: 0.1,\n        }\n    }\n}\n\n/// Retry strategy implementation with exponential backoff and jitter\npub struct RetryStrategy {\n    config: RetryConfig,\n    start_time: Instant,\n    attempt: u32,\n}\n\nimpl RetryStrategy {\n    pub fn new(config: RetryConfig) -> Self {\n        Self {\n            config,\n            start_time: Instant::now(),\n            attempt: 0,\n        }\n    }\n\n    /// Execute an operation with retry logic\n    pub async fn execute<F, Fut, T>(&mut self, operation: F) -> AsyncApiResult<T>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = AsyncApiResult<T>>,\n    {\n        loop {\n            self.attempt += 1;\n\n            debug!(\n                attempt = self.attempt,\n                max_attempts = self.config.max_attempts,\n                \"Executing operation with retry\"\n            );\n\n            match operation().await {\n                Ok(result) => {\n                    if self.attempt > 1 {\n                        info!(\n                            attempt = self.attempt,\n                            elapsed = ?self.start_time.elapsed(),\n                            \"Operation succeeded after retry\"\n                        );\n                    }\n                    return Ok(result);\n                }\n                Err(error) => {\n                    // Check if we should retry\n                    if !self.should_retry(&error) {\n                        warn!(\n                            attempt = self.attempt,\n                            error = %error,\n                            \"Operation failed with non-retryable error\"\n                        );\n                        return Err(error);\n                    }\n\n                    // Check if we've exceeded retry limits\n                    if self.attempt >= self.config.max_attempts {\n                        error!(\n                            attempt = self.attempt,\n                            max_attempts = self.config.max_attempts,\n                            \"Maximum retry attempts exceeded\"\n                        );\n                        return Err(AsyncApiError::Recovery {\n                            message: format!(\n                                \"Operation failed after {} attempts: {}\",\n                                self.attempt, error\n                            ),\n                            attempts: self.attempt,\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::High,\n                                ErrorCategory::Resource,\n                                false,\n                            ),\n                            source: Some(Box::new(error)),\n                        });\n                    }\n\n                    // Check total time limit\n                    if self.start_time.elapsed() >= self.config.max_total_time {\n                        error!(\n                            elapsed = ?self.start_time.elapsed(),\n                            max_total_time = ?self.config.max_total_time,\n                            \"Maximum retry time exceeded\"\n                        );\n                        return Err(AsyncApiError::Recovery {\n                            message: format!(\n                                \"Operation failed within time limit: {}\",\n                                error\n                            ),\n                            attempts: self.attempt,\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::High,\n                                ErrorCategory::Resource,\n                                false,\n                            ),\n                            source: Some(Box::new(error)),\n                        });\n                    }\n\n                    // Calculate delay and wait\n                    let delay = self.calculate_delay();\n                    warn!(\n                        attempt = self.attempt,\n                        delay_ms = delay.as_millis(),\n                        error = %error,\n                        \"Operation failed, retrying after delay\"\n                    );\n\n                    tokio::time::sleep(delay).await;\n                }\n            }\n        }\n    }\n\n    fn should_retry(&self, error: &AsyncApiError) -> bool {\n        // Don't retry non-retryable errors\n        if !error.is_retryable() {\n            return false;\n        }\n\n        // Don't retry validation or security errors\n        match error.category() {\n            ErrorCategory::Validation | ErrorCategory::Security => false,\n            _ => true,\n        }\n    }\n\n    fn calculate_delay(&self) -> Duration {\n        let base_delay = self.config.initial_delay.as_millis() as f64\n            * self.config.backoff_multiplier.powi((self.attempt - 1) as i32);\n\n        let max_delay = self.config.max_delay.as_millis() as f64;\n        let delay = base_delay.min(max_delay);\n\n        // Add jitter to prevent thundering herd\n        let jitter = delay * self.config.jitter_factor * (rand::random::<f64>() - 0.5);\n        let final_delay = (delay + jitter).max(0.0) as u64;\n\n        Duration::from_millis(final_delay)\n    }\n\n    /// Get current attempt number\n    pub fn current_attempt(&self) -> u32 {\n        self.attempt\n    }\n}\n\n/// Circuit breaker states\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub enum CircuitBreakerState {\n    /// Circuit is closed, requests are allowed\n    Closed,\n    /// Circuit is open, requests are rejected\n    Open,\n    /// Circuit is half-open, testing if service has recovered\n    HalfOpen,\n}\n\n/// Circuit breaker configuration\n#[derive(Debug, Clone)]\npub struct CircuitBreakerConfig {\n    /// Number of failures before opening the circuit\n    pub failure_threshold: u32,\n    /// Time to wait before transitioning from Open to HalfOpen\n    pub recovery_timeout: Duration,\n    /// Number of successful requests needed to close the circuit from HalfOpen\n    pub success_threshold: u32,\n    /// Time window for counting failures\n    pub failure_window: Duration,\n}\n\nimpl Default for CircuitBreakerConfig {\n    fn default() -> Self {\n        Self {\n            failure_threshold: 5,\n            recovery_timeout: Duration::from_secs(60),\n            success_threshold: 3,\n            failure_window: Duration::from_secs(60),\n        }\n    }\n}\n\n/// Circuit breaker implementation for preventing cascade failures\n#[derive(Debug)]\npub struct CircuitBreaker {\n    config: CircuitBreakerConfig,\n    state: Arc<RwLock<CircuitBreakerState>>,\n    failure_count: Arc<RwLock<u32>>,\n    success_count: Arc<RwLock<u32>>,\n    last_failure_time: Arc<RwLock<Option<Instant>>>,\n    last_state_change: Arc<RwLock<Instant>>,\n}\n\nimpl CircuitBreaker {\n    pub fn new(config: CircuitBreakerConfig) -> Self {\n        Self {\n            config,\n            state: Arc::new(RwLock::new(CircuitBreakerState::Closed)),\n            failure_count: Arc::new(RwLock::new(0)),\n            success_count: Arc::new(RwLock::new(0)),\n            last_failure_time: Arc::new(RwLock::new(None)),\n            last_state_change: Arc::new(RwLock::new(Instant::now())),\n        }\n    }\n\n    /// Execute an operation through the circuit breaker\n    pub async fn execute<F, Fut, T>(&self, operation: F) -> AsyncApiResult<T>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = AsyncApiResult<T>>,\n    {\n        // Check if circuit should transition states\n        self.check_state_transition().await;\n\n        let current_state = *self.state.read().await;\n\n        match current_state {\n            CircuitBreakerState::Open => {\n                debug!(\"Circuit breaker is open, rejecting request\");\n                Err(AsyncApiError::Resource {\n                    message: \"Circuit breaker is open\".to_string(),\n                    resource_type: \"circuit_breaker\".to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Resource,\n                        true,\n                    ),\n                    source: None,\n                })\n            }\n            CircuitBreakerState::Closed | CircuitBreakerState::HalfOpen => {\n                match operation().await {\n                    Ok(result) => {\n                        self.record_success().await;\n                        Ok(result)\n                    }\n                    Err(error) => {\n                        self.record_failure().await;\n                        Err(error)\n                    }\n                }\n            }\n        }\n    }\n\n    async fn record_success(&self) {\n        let mut success_count = self.success_count.write().await;\n        *success_count += 1;\n\n        let current_state = *self.state.read().await;\n        if current_state == CircuitBreakerState::HalfOpen\n            && *success_count >= self.config.success_threshold {\n            info!(\"Circuit breaker transitioning to Closed state\");\n            *self.state.write().await = CircuitBreakerState::Closed;\n            *self.failure_count.write().await = 0;\n            *success_count = 0;\n            *self.last_state_change.write().await = Instant::now();\n        }\n    }\n\n    async fn record_failure(&self) {\n        let mut failure_count = self.failure_count.write().await;\n        *failure_count += 1;\n        *self.last_failure_time.write().await = Some(Instant::now());\n\n        let current_state = *self.state.read().await;\n        if current_state == CircuitBreakerState::Closed\n            && *failure_count >= self.config.failure_threshold {\n            warn!(\n                failure_count = *failure_count,\n                threshold = self.config.failure_threshold,\n                \"Circuit breaker transitioning to Open state\"\n            );\n            *self.state.write().await = CircuitBreakerState::Open;\n            *self.success_count.write().await = 0;\n            *self.last_state_change.write().await = Instant::now();\n        } else if current_state == CircuitBreakerState::HalfOpen {\n            warn!(\"Circuit breaker transitioning back to Open state\");\n            *self.state.write().await = CircuitBreakerState::Open;\n            *self.success_count.write().await = 0;\n            *self.last_state_change.write().await = Instant::now();\n        }\n    }\n\n    async fn check_state_transition(&self) {\n        let current_state = *self.state.read().await;\n        let last_change = *self.last_state_change.read().await;\n\n        if current_state == CircuitBreakerState::Open\n            && last_change.elapsed() >= self.config.recovery_timeout {\n            info!(\"Circuit breaker transitioning to HalfOpen state\");\n            *self.state.write().await = CircuitBreakerState::HalfOpen;\n            *self.last_state_change.write().await = Instant::now();\n        }\n\n        // Reset failure count if outside failure window\n        if let Some(last_failure) = *self.last_failure_time.read().await {\n            if last_failure.elapsed() >= self.config.failure_window {\n                *self.failure_count.write().await = 0;\n            }\n        }\n    }\n\n    /// Get current circuit breaker state\n    pub async fn state(&self) -> CircuitBreakerState {\n        *self.state.read().await\n    }\n\n    /// Get current failure count\n    pub async fn failure_count(&self) -> u32 {\n        *self.failure_count.read().await\n    }\n}\n\n/// Dead letter queue for handling unprocessable messages\n#[derive(Debug)]\npub struct DeadLetterQueue {\n    max_size: usize,\n    messages: Arc<RwLock<Vec<DeadLetterMessage>>>,\n}\n\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct DeadLetterMessage {\n    pub id: String,\n    pub original_channel: String,\n    pub payload: Vec<u8>,\n    pub error: String,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    pub retry_count: u32,\n}\n\nimpl DeadLetterQueue {\n    pub fn new(max_size: usize) -> Self {\n        Self {\n            max_size,\n            messages: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    /// Add a message to the dead letter queue\n    pub async fn add_message(\n        &self,\n        channel: &str,\n        payload: Vec<u8>,\n        error: &AsyncApiError,\n        retry_count: u32,\n    ) -> AsyncApiResult<()> {\n        let mut messages = self.messages.write().await;\n\n        // Remove oldest message if at capacity\n        if messages.len() >= self.max_size {\n            messages.remove(0);\n            warn!(\"Dead letter queue at capacity, removing oldest message\");\n        }\n\n        let message = DeadLetterMessage {\n            id: uuid::Uuid::new_v4().to_string(),\n            original_channel: channel.to_string(),\n            payload,\n            error: error.to_string(),\n            timestamp: chrono::Utc::now(),\n            retry_count,\n        };\n\n        messages.push(message);\n        info!(\n            channel = channel,\n            error = %error,\n            queue_size = messages.len(),\n            \"Message added to dead letter queue\"\n        );\n\n        Ok(())\n    }\n\n    /// Get all messages in the dead letter queue\n    pub async fn get_messages(&self) -> Vec<DeadLetterMessage> {\n        self.messages.read().await.clone()\n    }\n\n    /// Remove a message from the dead letter queue\n    pub async fn remove_message(&self, message_id: &str) -> bool {\n        let mut messages = self.messages.write().await;\n        if let Some(pos) = messages.iter().position(|m| m.id == message_id) {\n            messages.remove(pos);\n            true\n        } else {\n            false\n        }\n    }\n\n    /// Clear all messages from the dead letter queue\n    pub async fn clear(&self) {\n        let mut messages = self.messages.write().await;\n        let count = messages.len();\n        messages.clear();\n        info!(cleared_count = count, \"Dead letter queue cleared\");\n    }\n\n    /// Get queue size\n    pub async fn size(&self) -> usize {\n        self.messages.read().await.len()\n    }\n}\n\n/// Bulkhead pattern for isolating failures\n#[derive(Debug)]\npub struct Bulkhead {\n    name: String,\n    semaphore: Arc<tokio::sync::Semaphore>,\n    max_concurrent: usize,\n    timeout: Duration,\n}\n\nimpl Bulkhead {\n    pub fn new(name: String, max_concurrent: usize, timeout: Duration) -> Self {\n        Self {\n            name,\n            semaphore: Arc::new(tokio::sync::Semaphore::new(max_concurrent)),\n            max_concurrent,\n            timeout,\n        }\n    }\n\n    /// Execute an operation within the bulkhead\n    pub async fn execute<F, Fut, T>(&self, operation: F) -> AsyncApiResult<T>\n    where\n        F: Fn() -> Fut,\n        Fut: std::future::Future<Output = AsyncApiResult<T>>,\n    {\n        // Try to acquire permit with timeout\n        let permit = match tokio::time::timeout(\n            self.timeout,\n            self.semaphore.acquire()\n        ).await {\n            Ok(Ok(permit)) => permit,\n            Ok(Err(_)) => {\n                return Err(AsyncApiError::Resource {\n                    message: format!(\"Bulkhead '{}' semaphore closed\", self.name),\n                    resource_type: \"bulkhead\".to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::High,\n                        ErrorCategory::Resource,\n                        true,\n                    ),\n                    source: None,\n                });\n            }\n            Err(_) => {\n                return Err(AsyncApiError::Resource {\n                    message: format!(\n                        \"Bulkhead '{}' timeout waiting for permit (max_concurrent: {})\",\n                        self.name, self.max_concurrent\n                    ),\n                    resource_type: \"bulkhead\".to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Resource,\n                        true,\n                    ),\n                    source: None,\n                });\n            }\n        };\n\n        debug!(\n            bulkhead = %self.name,\n            available_permits = self.semaphore.available_permits(),\n            \"Executing operation within bulkhead\"\n        );\n\n        // Execute operation with permit held\n        let result = operation().await;\n\n        // Permit is automatically released when dropped\n        drop(permit);\n\n        result\n    }\n\n    /// Get current available permits\n    pub fn available_permits(&self) -> usize {\n        self.semaphore.available_permits()\n    }\n}\n\n/// Recovery manager that coordinates all recovery strategies\n#[derive(Debug)]\npub struct RecoveryManager {\n    retry_configs: std::collections::HashMap<String, RetryConfig>,\n    circuit_breakers: std::collections::HashMap<String, Arc<CircuitBreaker>>,\n    dead_letter_queue: Arc<DeadLetterQueue>,\n    bulkheads: std::collections::HashMap<String, Arc<Bulkhead>>,\n}\n\nimpl RecoveryManager {\n    pub fn new() -> Self {\n        Self {\n            retry_configs: std::collections::HashMap::new(),\n            circuit_breakers: std::collections::HashMap::new(),\n            dead_letter_queue: Arc::new(DeadLetterQueue::new(1000)),\n            bulkheads: std::collections::HashMap::new(),\n        }\n    }\n\n    /// Configure retry strategy for an operation type\n    pub fn configure_retry(&mut self, operation_type: &str, config: RetryConfig) {\n        self.retry_configs.insert(operation_type.to_string(), config);\n    }\n\n    /// Configure circuit breaker for a service\n    pub fn configure_circuit_breaker(&mut self, service: &str, config: CircuitBreakerConfig) {\n        let circuit_breaker = Arc::new(CircuitBreaker::new(config));\n        self.circuit_breakers.insert(service.to_string(), circuit_breaker);\n    }\n\n    /// Configure bulkhead for a resource\n    pub fn configure_bulkhead(&mut self, resource: &str, max_concurrent: usize, timeout: Duration) {\n        let bulkhead = Arc::new(Bulkhead::new(resource.to_string(), max_concurrent, timeout));\n        self.bulkheads.insert(resource.to_string(), bulkhead);\n    }\n\n    /// Get retry strategy for operation type\n    pub fn get_retry_strategy(&self, operation_type: &str) -> RetryStrategy {\n        let config = self.retry_configs\n            .get(operation_type)\n            .cloned()\n            .unwrap_or_default();\n        RetryStrategy::new(config)\n    }\n\n    /// Get circuit breaker for service\n    pub fn get_circuit_breaker(&self, service: &str) -> Option<Arc<CircuitBreaker>> {\n        self.circuit_breakers.get(service).cloned()\n    }\n\n    /// Get dead letter queue\n    pub fn get_dead_letter_queue(&self) -> Arc<DeadLetterQueue> {\n        self.dead_letter_queue.clone()\n    }\n\n    /// Get bulkhead for resource\n    pub fn get_bulkhead(&self, resource: &str) -> Option<Arc<Bulkhead>> {\n        self.bulkheads.get(resource).cloned()\n    }\n}\n\nimpl Default for RecoveryManager {\n    fn default() -> Self {\n        let mut manager = Self::new();\n\n        // Configure default retry strategies\n        manager.configure_retry(\"message_handler\", RetryConfig::default());\n        manager.configure_retry(\"connection\", RetryConfig::conservative());\n        manager.configure_retry(\"validation\", RetryConfig::fast());\n\n        // Configure default circuit breakers\n        manager.configure_circuit_breaker(\"default\", CircuitBreakerConfig::default());\n\n        // Configure default bulkheads\n        manager.configure_bulkhead(\"message_processing\", 100, Duration::from_secs(30));\n        manager.configure_bulkhead(\"connection_pool\", 50, Duration::from_secs(10));\n\n        manager\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AuthModRs() {\n    return (\n        <File name=\"mod.rs\">\n            {`//! Authentication and authorization module\n//!\n//! This module provides JWT-based authentication, role-based access control,\n//! and middleware for securing AsyncAPI message handlers.\n\n#[cfg(feature = \"auth\")]\npub mod jwt;\n#[cfg(feature = \"auth\")]\npub mod middleware;\n#[cfg(feature = \"auth\")]\npub mod rbac;\n#[cfg(feature = \"auth\")]\npub mod config;\n\n#[cfg(feature = \"auth\")]\npub use config::AuthConfig;\n#[cfg(feature = \"auth\")]\npub use middleware::AuthMiddleware;\n#[cfg(feature = \"auth\")]\npub use jwt::{JwtValidator, Claims};\n#[cfg(feature = \"auth\")]\npub use rbac::{Role, Permission, RoleManager};\n\n#[cfg(not(feature = \"auth\"))]\npub struct AuthConfig;\n\n#[cfg(not(feature = \"auth\"))]\nimpl AuthConfig {\n    pub fn new() -> Self {\n        Self\n    }\n\n    pub fn validate(&self) -> crate::errors::AsyncApiResult<()> {\n        Ok(())\n    }\n}\n\n#[cfg(not(feature = \"auth\"))]\nimpl Clone for AuthConfig {\n    fn clone(&self) -> Self {\n        Self\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AuthConfigRs() {\n    return (\n        <File name=\"config.rs\">\n            {`//! Authentication configuration\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::time::Duration;\n\n/// Authentication configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuthConfig {\n    /// JWT configuration\n    pub jwt: JwtConfig,\n    /// Rate limiting configuration\n    pub rate_limiting: Option<RateLimitConfig>,\n    /// Session configuration\n    pub session: Option<SessionConfig>,\n    /// Required roles for access\n    pub required_roles: Vec<String>,\n    /// Required permissions for access\n    pub required_permissions: Vec<String>,\n    /// Whether to allow anonymous access\n    pub allow_anonymous: bool,\n}\n\n/// JWT configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JwtConfig {\n    /// JWT secret for HMAC algorithms\n    pub secret: Option<String>,\n    /// RSA private key PEM for signing (RS256)\n    pub private_key_pem: Option<String>,\n    /// RSA public key PEM for verification (RS256)\n    pub public_key_pem: Option<String>,\n    /// Expected issuer\n    pub issuer: Option<String>,\n    /// Expected audience\n    pub audience: Option<String>,\n    /// Token expiration time in seconds\n    pub expires_in: u64,\n    /// Leeway for time-based validations in seconds\n    pub leeway: u64,\n    /// Algorithm to use (HS256, RS256)\n    pub algorithm: JwtAlgorithm,\n}\n\n/// JWT algorithms\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum JwtAlgorithm {\n    /// HMAC with SHA-256\n    HS256,\n    /// RSA with SHA-256\n    RS256,\n}\n\n/// Rate limiting configuration for authentication\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RateLimitConfig {\n    /// Maximum number of authentication attempts per window\n    pub max_attempts: u32,\n    /// Time window for rate limiting\n    pub window_seconds: u64,\n    /// Lockout duration after exceeding rate limit\n    pub lockout_seconds: u64,\n}\n\n/// Session configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionConfig {\n    /// Session timeout in seconds\n    pub timeout_seconds: u64,\n    /// Whether to extend session on activity\n    pub extend_on_activity: bool,\n    /// Maximum concurrent sessions per user\n    pub max_concurrent_sessions: Option<u32>,\n}\n\nimpl Default for AuthConfig {\n    fn default() -> Self {\n        Self {\n            jwt: JwtConfig::default(),\n            rate_limiting: Some(RateLimitConfig::default()),\n            session: Some(SessionConfig::default()),\n            required_roles: Vec::new(),\n            required_permissions: Vec::new(),\n            allow_anonymous: false,\n        }\n    }\n}\n\nimpl Default for JwtConfig {\n    fn default() -> Self {\n        Self {\n            secret: None,\n            private_key_pem: None,\n            public_key_pem: None,\n            issuer: None,\n            audience: None,\n            expires_in: 3600, // 1 hour\n            leeway: 60,       // 1 minute\n            algorithm: JwtAlgorithm::HS256,\n        }\n    }\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -> Self {\n        Self {\n            max_attempts: 5,\n            window_seconds: 300,   // 5 minutes\n            lockout_seconds: 900,  // 15 minutes\n        }\n    }\n}\n\nimpl Default for SessionConfig {\n    fn default() -> Self {\n        Self {\n            timeout_seconds: 3600, // 1 hour\n            extend_on_activity: true,\n            max_concurrent_sessions: Some(5),\n        }\n    }\n}\n\nimpl AuthConfig {\n    /// Create a new authentication configuration\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Set JWT secret for HMAC algorithms\n    pub fn with_jwt_secret(mut self, secret: String) -> Self {\n        self.jwt.secret = Some(secret);\n        self.jwt.algorithm = JwtAlgorithm::HS256;\n        self\n    }\n\n    /// Set RSA key pair for RS256 algorithm\n    pub fn with_rsa_keys(mut self, private_key_pem: String, public_key_pem: String) -> Self {\n        self.jwt.private_key_pem = Some(private_key_pem);\n        self.jwt.public_key_pem = Some(public_key_pem);\n        self.jwt.algorithm = JwtAlgorithm::RS256;\n        self\n    }\n\n    /// Set RSA public key for verification only\n    pub fn with_rsa_public_key(mut self, public_key_pem: String) -> Self {\n        self.jwt.public_key_pem = Some(public_key_pem);\n        self.jwt.algorithm = JwtAlgorithm::RS256;\n        self\n    }\n\n    /// Set JWT issuer\n    pub fn with_issuer(mut self, issuer: String) -> Self {\n        self.jwt.issuer = Some(issuer);\n        self\n    }\n\n    /// Set JWT audience\n    pub fn with_audience(mut self, audience: String) -> Self {\n        self.jwt.audience = Some(audience);\n        self\n    }\n\n    /// Set token expiration time\n    pub fn with_expires_in(mut self, seconds: u64) -> Self {\n        self.jwt.expires_in = seconds;\n        self\n    }\n\n    /// Add required role\n    pub fn with_required_role(mut self, role: String) -> Self {\n        self.required_roles.push(role);\n        self\n    }\n\n    /// Add required permission\n    pub fn with_required_permission(mut self, permission: String) -> Self {\n        self.required_permissions.push(permission);\n        self\n    }\n\n    /// Allow anonymous access\n    pub fn allow_anonymous(mut self) -> Self {\n        self.allow_anonymous = true;\n        self\n    }\n\n    /// Disable rate limiting\n    pub fn without_rate_limiting(mut self) -> Self {\n        self.rate_limiting = None;\n        self\n    }\n\n    /// Configure rate limiting\n    pub fn with_rate_limiting(mut self, config: RateLimitConfig) -> Self {\n        self.rate_limiting = Some(config);\n        self\n    }\n\n    /// Configure session management\n    pub fn with_session_config(mut self, config: SessionConfig) -> Self {\n        self.session = Some(config);\n        self\n    }\n\n    /// Validate the authentication configuration\n    pub fn validate(&self) -> AsyncApiResult<()> {\n        // Validate JWT configuration\n        match self.jwt.algorithm {\n            JwtAlgorithm::HS256 => {\n                if self.jwt.secret.is_none() {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"JWT secret is required for HS256 algorithm\".to_string(),\n                        field: Some(\"jwt.secret\".to_string()),\n                        source: None,\n                    });\n                }\n\n                if let Some(ref secret) = self.jwt.secret {\n                    if secret.len() < 32 {\n                        return Err(AsyncApiError::Configuration {\n                            message: \"JWT secret should be at least 32 characters long\".to_string(),\n                            field: Some(\"jwt.secret\".to_string()),\n                            source: None,\n                        });\n                    }\n                }\n            }\n            JwtAlgorithm::RS256 => {\n                if self.jwt.public_key_pem.is_none() {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"RSA public key is required for RS256 algorithm\".to_string(),\n                        field: Some(\"jwt.public_key_pem\".to_string()),\n                        source: None,\n                    });\n                }\n            }\n        }\n\n        // Validate expiration time\n        if self.jwt.expires_in == 0 {\n            return Err(AsyncApiError::Configuration {\n                message: \"JWT expiration time must be greater than 0\".to_string(),\n                field: Some(\"jwt.expires_in\".to_string()),\n                source: None,\n            });\n        }\n\n        // Validate rate limiting configuration\n        if let Some(ref rate_limit) = self.rate_limiting {\n            if rate_limit.max_attempts == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Rate limit max_attempts must be greater than 0\".to_string(),\n                    field: Some(\"rate_limiting.max_attempts\".to_string()),\n                    source: None,\n                });\n            }\n\n            if rate_limit.window_seconds == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Rate limit window_seconds must be greater than 0\".to_string(),\n                    field: Some(\"rate_limiting.window_seconds\".to_string()),\n                    source: None,\n                });\n            }\n        }\n\n        // Validate session configuration\n        if let Some(ref session) = self.session {\n            if session.timeout_seconds == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Session timeout must be greater than 0\".to_string(),\n                    field: Some(\"session.timeout_seconds\".to_string()),\n                    source: None,\n                });\n            }\n\n            if let Some(max_sessions) = session.max_concurrent_sessions {\n                if max_sessions == 0 {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"Max concurrent sessions must be greater than 0\".to_string(),\n                        field: Some(\"session.max_concurrent_sessions\".to_string()),\n                        source: None,\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Create configuration from environment variables\n    pub fn from_env() -> AsyncApiResult<Self> {\n        let mut config = Self::default();\n\n        // JWT configuration\n        if let Ok(secret) = std::env::var(\"JWT_SECRET\") {\n            config.jwt.secret = Some(secret);\n            config.jwt.algorithm = JwtAlgorithm::HS256;\n        }\n\n        if let Ok(private_key) = std::env::var(\"JWT_PRIVATE_KEY_PEM\") {\n            config.jwt.private_key_pem = Some(private_key);\n            config.jwt.algorithm = JwtAlgorithm::RS256;\n        }\n\n        if let Ok(public_key) = std::env::var(\"JWT_PUBLIC_KEY_PEM\") {\n            config.jwt.public_key_pem = Some(public_key);\n            if config.jwt.private_key_pem.is_none() {\n                config.jwt.algorithm = JwtAlgorithm::RS256;\n            }\n        }\n\n        if let Ok(issuer) = std::env::var(\"JWT_ISSUER\") {\n            config.jwt.issuer = Some(issuer);\n        }\n\n        if let Ok(audience) = std::env::var(\"JWT_AUDIENCE\") {\n            config.jwt.audience = Some(audience);\n        }\n\n        if let Ok(expires_in) = std::env::var(\"JWT_EXPIRES_IN\") {\n            config.jwt.expires_in = expires_in.parse().map_err(|e| AsyncApiError::Configuration {\n                message: format!(\"Invalid JWT_EXPIRES_IN value: {}\", e),\n                field: Some(\"JWT_EXPIRES_IN\".to_string()),\n                source: Some(Box::new(e)),\n            })?;\n        }\n\n        // Rate limiting configuration\n        if let Ok(max_attempts) = std::env::var(\"AUTH_RATE_LIMIT_MAX_ATTEMPTS\") {\n            if let Some(ref mut rate_limit) = config.rate_limiting {\n                rate_limit.max_attempts = max_attempts.parse().map_err(|e| AsyncApiError::Configuration {\n                    message: format!(\"Invalid AUTH_RATE_LIMIT_MAX_ATTEMPTS value: {}\", e),\n                    field: Some(\"AUTH_RATE_LIMIT_MAX_ATTEMPTS\".to_string()),\n                    source: Some(Box::new(e)),\n                })?;\n            }\n        }\n\n        // Anonymous access\n        if let Ok(allow_anon) = std::env::var(\"AUTH_ALLOW_ANONYMOUS\") {\n            config.allow_anonymous = allow_anon.to_lowercase() == \"true\";\n        }\n\n        config.validate()?;\n        Ok(config)\n    }\n\n    /// Get the rate limit window as Duration\n    pub fn rate_limit_window(&self) -> Option<Duration> {\n        self.rate_limiting.as_ref().map(|rl| Duration::from_secs(rl.window_seconds))\n    }\n\n    /// Get the rate limit lockout duration as Duration\n    pub fn rate_limit_lockout(&self) -> Option<Duration> {\n        self.rate_limiting.as_ref().map(|rl| Duration::from_secs(rl.lockout_seconds))\n    }\n\n    /// Get the session timeout as Duration\n    pub fn session_timeout(&self) -> Option<Duration> {\n        self.session.as_ref().map(|s| Duration::from_secs(s.timeout_seconds))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = AuthConfig::default();\n        assert!(config.validate().is_err()); // Should fail without secret\n    }\n\n    #[test]\n    fn test_hmac_config() {\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string());\n\n        assert!(config.validate().is_ok());\n        assert_eq!(config.jwt.algorithm, JwtAlgorithm::HS256);\n    }\n\n    #[test]\n    fn test_config_validation() {\n        // Test short secret\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"short\".to_string());\n        assert!(config.validate().is_err());\n\n        // Test zero expiration\n        let mut config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string());\n        config.jwt.expires_in = 0;\n        assert!(config.validate().is_err());\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string())\n            .with_issuer(\"test-issuer\".to_string())\n            .with_audience(\"test-audience\".to_string())\n            .with_required_role(\"admin\".to_string())\n            .allow_anonymous();\n\n        assert!(config.validate().is_ok());\n        assert_eq!(config.jwt.issuer, Some(\"test-issuer\".to_string()));\n        assert_eq!(config.jwt.audience, Some(\"test-audience\".to_string()));\n        assert!(config.required_roles.contains(&\"admin\".to_string()));\n        assert!(config.allow_anonymous);\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AuthJwtRs() {\n    return (\n        <File name=\"jwt.rs\">\n            {`//! JWT token validation and claims handling\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse tracing::{debug, warn};\n\n/// JWT claims structure\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Claims {\n    /// Subject (user ID)\n    pub sub: String,\n    /// Issued at timestamp\n    pub iat: u64,\n    /// Expiration timestamp\n    pub exp: u64,\n    /// Issuer\n    pub iss: String,\n    /// Audience\n    pub aud: String,\n    /// User roles\n    pub roles: Vec<String>,\n    /// User permissions\n    pub permissions: Vec<String>,\n    /// Custom claims\n    #[serde(flatten)]\n    pub custom: serde_json::Map<String, serde_json::Value>,\n}\n\nimpl Claims {\n    /// Create new claims with expiration\n    pub fn new(\n        user_id: String,\n        issuer: String,\n        audience: String,\n        expires_in_seconds: u64,\n    ) -> AsyncApiResult<Self> {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| AsyncApiError::Authentication {\n                message: format!(\"Failed to get current time: {}\", e),\n                source: Some(Box::new(e)),\n            })?\n            .as_secs();\n\n        Ok(Self {\n            sub: user_id,\n            iat: now,\n            exp: now + expires_in_seconds,\n            iss: issuer,\n            aud: audience,\n            roles: Vec::new(),\n            permissions: Vec::new(),\n            custom: serde_json::Map::new(),\n        })\n    }\n\n    /// Add a role to the claims\n    pub fn with_role(mut self, role: String) -> Self {\n        self.roles.push(role);\n        self\n    }\n\n    /// Add multiple roles to the claims\n    pub fn with_roles(mut self, roles: Vec<String>) -> Self {\n        self.roles.extend(roles);\n        self\n    }\n\n    /// Add a permission to the claims\n    pub fn with_permission(mut self, permission: String) -> Self {\n        self.permissions.push(permission);\n        self\n    }\n\n    /// Add multiple permissions to the claims\n    pub fn with_permissions(mut self, permissions: Vec<String>) -> Self {\n        self.permissions.extend(permissions);\n        self\n    }\n\n    /// Add a custom claim\n    pub fn with_custom_claim<T: Serialize>(mut self, key: String, value: T) -> AsyncApiResult<Self> {\n        let json_value = serde_json::to_value(value).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Failed to serialize custom claim: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n        self.custom.insert(key, json_value);\n        Ok(self)\n    }\n\n    /// Check if the token has expired\n    pub fn is_expired(&self) -> bool {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_secs())\n            .unwrap_or(0);\n\n        self.exp <= now\n    }\n\n    /// Check if the claims contain a specific role\n    pub fn has_role(&self, role: &str) -> bool {\n        self.roles.contains(&role.to_string())\n    }\n\n    /// Check if the claims contain any of the specified roles\n    pub fn has_any_role(&self, roles: &[&str]) -> bool {\n        roles.iter().any(|role| self.has_role(role))\n    }\n\n    /// Check if the claims contain all of the specified roles\n    pub fn has_all_roles(&self, roles: &[&str]) -> bool {\n        roles.iter().all(|role| self.has_role(role))\n    }\n\n    /// Check if the claims contain a specific permission\n    pub fn has_permission(&self, permission: &str) -> bool {\n        self.permissions.contains(&permission.to_string())\n    }\n\n    /// Check if the claims contain any of the specified permissions\n    pub fn has_any_permission(&self, permissions: &[&str]) -> bool {\n        permissions.iter().any(|perm| self.has_permission(perm))\n    }\n\n    /// Get a custom claim value\n    pub fn get_custom_claim<T: for<'de> Deserialize<'de>>(&self, key: &str) -> AsyncApiResult<Option<T>> {\n        match self.custom.get(key) {\n            Some(value) => {\n                let result = serde_json::from_value(value.clone()).map_err(|e| AsyncApiError::Authentication {\n                    message: format!(\"Failed to deserialize custom claim '{}': {}\", key, e),\n                    source: Some(Box::new(e)),\n                })?;\n                Ok(Some(result))\n            }\n            None => Ok(None),\n        }\n    }\n}\n\n/// JWT token validator\npub struct JwtValidator {\n    decoding_key: DecodingKey,\n    validation: Validation,\n    encoding_key: Option<EncodingKey>,\n}\n\nimpl JwtValidator {\n    /// Create a new JWT validator with HMAC secret\n    pub fn new_hmac(secret: &[u8]) -> Self {\n        let mut validation = Validation::new(Algorithm::HS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false; // We'll validate audience manually if needed\n\n        Self {\n            decoding_key: DecodingKey::from_secret(secret),\n            validation,\n            encoding_key: Some(EncodingKey::from_secret(secret)),\n        }\n    }\n\n    /// Create a new JWT validator with RSA public key\n    pub fn new_rsa_public(public_key_pem: &[u8]) -> AsyncApiResult<Self> {\n        let decoding_key = DecodingKey::from_rsa_pem(public_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA public key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let mut validation = Validation::new(Algorithm::RS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false;\n\n        Ok(Self {\n            decoding_key,\n            validation,\n            encoding_key: None,\n        })\n    }\n\n    /// Create a new JWT validator with RSA key pair\n    pub fn new_rsa_keypair(private_key_pem: &[u8], public_key_pem: &[u8]) -> AsyncApiResult<Self> {\n        let decoding_key = DecodingKey::from_rsa_pem(public_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA public key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let encoding_key = EncodingKey::from_rsa_pem(private_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA private key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let mut validation = Validation::new(Algorithm::RS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false;\n\n        Ok(Self {\n            decoding_key,\n            validation,\n            encoding_key: Some(encoding_key),\n        })\n    }\n\n    /// Set required audience for validation\n    pub fn with_audience(mut self, audience: String) -> Self {\n        self.validation.validate_aud = true;\n        self.validation.aud = Some(HashSet::from([audience]));\n        self\n    }\n\n    /// Set required issuer for validation\n    pub fn with_issuer(mut self, issuer: String) -> Self {\n        self.validation.validate_iss = true;\n        self.validation.iss = Some(HashSet::from([issuer]));\n        self\n    }\n\n    /// Set leeway for time-based validations (in seconds)\n    pub fn with_leeway(mut self, leeway_seconds: u64) -> Self {\n        self.validation.leeway = leeway_seconds;\n        self\n    }\n\n    /// Validate and decode a JWT token\n    pub fn validate_token(&self, token: &str) -> AsyncApiResult<Claims> {\n        debug!(\"Validating JWT token\");\n\n        let token_data = decode::<Claims>(token, &self.decoding_key, &self.validation)\n            .map_err(|e| {\n                warn!(\"JWT validation failed: {}\", e);\n                AsyncApiError::Authentication {\n                    message: format!(\"Invalid JWT token: {}\", e),\n                    source: Some(Box::new(e)),\n                }\n            })?;\n\n        let claims = token_data.claims;\n\n        // Additional custom validations\n        if claims.is_expired() {\n            return Err(AsyncApiError::Authentication {\n                message: \"Token has expired\".to_string(),\n                source: None,\n            });\n        }\n\n        debug!(\"JWT token validated successfully for user: {}\", claims.sub);\n        Ok(claims)\n    }\n\n    /// Generate a new JWT token (requires encoding key)\n    pub fn generate_token(&self, claims: &Claims) -> AsyncApiResult<String> {\n        let encoding_key = self.encoding_key.as_ref().ok_or_else(|| AsyncApiError::Authentication {\n            message: \"No encoding key available for token generation\".to_string(),\n            source: None,\n        })?;\n\n        let header = Header::new(match encoding_key {\n            EncodingKey::Rsa { .. } => Algorithm::RS256,\n            _ => Algorithm::HS256,\n        });\n\n        encode(&header, claims, encoding_key).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Failed to generate JWT token: {}\", e),\n            source: Some(Box::new(e)),\n        })\n    }\n\n    /// Extract token from Authorization header\n    pub fn extract_bearer_token(auth_header: &str) -> AsyncApiResult<&str> {\n        if !auth_header.starts_with(\"Bearer \") {\n            return Err(AsyncApiError::Authentication {\n                message: \"Authorization header must start with 'Bearer '\".to_string(),\n                source: None,\n            });\n        }\n\n        let token = &auth_header[7..]; // Remove \"Bearer \" prefix\n        if token.is_empty() {\n            return Err(AsyncApiError::Authentication {\n                message: \"Empty bearer token\".to_string(),\n                source: None,\n            });\n        }\n\n        Ok(token)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_claims_creation() {\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap();\n\n        assert_eq!(claims.sub, \"user123\");\n        assert_eq!(claims.iss, \"test-issuer\");\n        assert_eq!(claims.aud, \"test-audience\");\n        assert!(!claims.is_expired());\n    }\n\n    #[test]\n    fn test_role_permissions() {\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap()\n        .with_role(\"admin\".to_string())\n        .with_permission(\"read:users\".to_string());\n\n        assert!(claims.has_role(\"admin\"));\n        assert!(!claims.has_role(\"user\"));\n        assert!(claims.has_permission(\"read:users\"));\n        assert!(!claims.has_permission(\"write:users\"));\n    }\n\n    #[test]\n    fn test_jwt_hmac_roundtrip() {\n        let secret = b\"test-secret-key\";\n        let validator = JwtValidator::new_hmac(secret);\n\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap();\n\n        let token = validator.generate_token(&claims).unwrap();\n        let decoded_claims = validator.validate_token(&token).unwrap();\n\n        assert_eq!(claims.sub, decoded_claims.sub);\n        assert_eq!(claims.iss, decoded_claims.iss);\n        assert_eq!(claims.aud, decoded_claims.aud);\n    }\n\n    #[test]\n    fn test_bearer_token_extraction() {\n        let auth_header = \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\";\n        let token = JwtValidator::extract_bearer_token(auth_header).unwrap();\n        assert_eq!(token, \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\");\n\n        let invalid_header = \"Basic dXNlcjpwYXNz\";\n        assert!(JwtValidator::extract_bearer_token(invalid_header).is_err());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AuthMiddlewareRs() {\n    return (\n        <File name=\"middleware.rs\">\n            {`//! Authentication middleware for message processing\n\nuse crate::auth::{AuthConfig, JwtValidator, Claims};\nuse crate::context::{RequestContext, ExecutionContext};\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse crate::middleware::Middleware;\nuse async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse tracing::{debug, warn, error};\n\n/// Authentication middleware\npub struct AuthMiddleware {\n    config: AuthConfig,\n    jwt_validator: JwtValidator,\n    rate_limiter: Option<RateLimiter>,\n    session_manager: Option<SessionManager>,\n}\n\nimpl AuthMiddleware {\n    /// Create new authentication middleware\n    pub fn new(config: AuthConfig) -> AsyncApiResult<Self> {\n        let jwt_validator = Self::create_jwt_validator(&config)?;\n\n        let rate_limiter = if let Some(ref rate_config) = config.rate_limiting {\n            Some(RateLimiter::new(\n                rate_config.max_attempts,\n                Duration::from_secs(rate_config.window_seconds),\n                Duration::from_secs(rate_config.lockout_seconds),\n            ))\n        } else {\n            None\n        };\n\n        let session_manager = if let Some(ref session_config) = config.session {\n            Some(SessionManager::new(\n                Duration::from_secs(session_config.timeout_seconds),\n                session_config.extend_on_activity,\n                session_config.max_concurrent_sessions,\n            ))\n        } else {\n            None\n        };\n\n        Ok(Self {\n            config,\n            jwt_validator,\n            rate_limiter,\n            session_manager,\n        })\n    }\n\n    /// Create JWT validator from configuration\n    fn create_jwt_validator(config: &AuthConfig) -> AsyncApiResult<JwtValidator> {\n        let mut validator = match config.jwt.algorithm {\n            crate::auth::config::JwtAlgorithm::HS256 => {\n                let secret = config.jwt.secret.as_ref().ok_or_else(|| AsyncApiError::Configuration {\n                    message: \"JWT secret is required for HS256\".to_string(),\n                    field: Some(\"jwt.secret\".to_string()),\n                    source: None,\n                })?;\n                JwtValidator::new_hmac(secret.as_bytes())\n            }\n            crate::auth::config::JwtAlgorithm::RS256 => {\n                let public_key = config.jwt.public_key_pem.as_ref().ok_or_else(|| AsyncApiError::Configuration {\n                    message: \"RSA public key is required for RS256\".to_string(),\n                    field: Some(\"jwt.public_key_pem\".to_string()),\n                    source: None,\n                })?;\n\n                if let Some(private_key) = &config.jwt.private_key_pem {\n                    JwtValidator::new_rsa_keypair(private_key.as_bytes(), public_key.as_bytes())?\n                } else {\n                    JwtValidator::new_rsa_public(public_key.as_bytes())?\n                }\n            }\n        };\n\n        // Configure validator with issuer and audience if specified\n        if let Some(ref issuer) = config.jwt.issuer {\n            validator = validator.with_issuer(issuer.clone());\n        }\n\n        if let Some(ref audience) = config.jwt.audience {\n            validator = validator.with_audience(audience.clone());\n        }\n\n        validator = validator.with_leeway(config.jwt.leeway);\n\n        Ok(validator)\n    }\n\n    /// Extract authentication token from context\n    fn extract_token(&self, context: &RequestContext) -> AsyncApiResult<Option<String>> {\n        // Try to get token from headers\n        if let Some(auth_header) = context.get_header(\"authorization\") {\n            let token = JwtValidator::extract_bearer_token(auth_header)?;\n            return Ok(Some(token.to_string()));\n        }\n\n        // Try to get token from metadata\n        if let Some(token) = context.get_metadata(\"auth_token\") {\n            return Ok(Some(token.clone()));\n        }\n\n        // Try to get token from custom properties\n        if let Some(token) = context.get_property(\"jwt_token\") {\n            return Ok(Some(token.clone()));\n        }\n\n        Ok(None)\n    }\n\n    /// Validate user permissions\n    fn validate_permissions(&self, claims: &Claims) -> AsyncApiResult<()> {\n        // Check required roles\n        if !self.config.required_roles.is_empty() {\n            let has_required_role = self.config.required_roles.iter()\n                .any(|role| claims.has_role(role));\n\n            if !has_required_role {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"User lacks required roles: {:?}\", self.config.required_roles),\n                    required_permissions: self.config.required_roles.clone(),\n                    user_permissions: claims.roles.clone(),\n                });\n            }\n        }\n\n        // Check required permissions\n        if !self.config.required_permissions.is_empty() {\n            let has_required_permission = self.config.required_permissions.iter()\n                .any(|perm| claims.has_permission(perm));\n\n            if !has_required_permission {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"User lacks required permissions: {:?}\", self.config.required_permissions),\n                    required_permissions: self.config.required_permissions.clone(),\n                    user_permissions: claims.permissions.clone(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Middleware for AuthMiddleware {\n    fn name(&self) -> &'static str {\n        \"AuthMiddleware\"\n    }\n\n    async fn process(\n        &self,\n        context: &mut RequestContext,\n        _execution_context: &ExecutionContext,\n    ) -> AsyncApiResult<()> {\n        debug!(\"Processing authentication middleware\");\n\n        // Check rate limiting first\n        if let Some(ref rate_limiter) = self.rate_limiter {\n            let client_id = context.get_client_id().unwrap_or(\"unknown\".to_string());\n            if !rate_limiter.check_rate_limit(&client_id).await {\n                warn!(\"Rate limit exceeded for client: {}\", client_id);\n                return Err(AsyncApiError::RateLimit {\n                    message: \"Authentication rate limit exceeded\".to_string(),\n                    retry_after: Some(self.config.rate_limit_lockout().unwrap_or(Duration::from_secs(900))),\n                });\n            }\n        }\n\n        // Extract authentication token\n        let token = match self.extract_token(context)? {\n            Some(token) => token,\n            None => {\n                if self.config.allow_anonymous {\n                    debug!(\"No authentication token found, allowing anonymous access\");\n                    context.set_property(\"authenticated\".to_string(), \"false\".to_string());\n                    return Ok(());\n                } else {\n                    return Err(AsyncApiError::Authentication {\n                        message: \"No authentication token provided\".to_string(),\n                        source: None,\n                    });\n                }\n            }\n        };\n\n        // Validate JWT token\n        let claims = match self.jwt_validator.validate_token(&token) {\n            Ok(claims) => claims,\n            Err(e) => {\n                warn!(\"JWT validation failed: {}\", e);\n\n                // Record failed attempt for rate limiting\n                if let Some(ref rate_limiter) = self.rate_limiter {\n                    let client_id = context.get_client_id().unwrap_or(\"unknown\".to_string());\n                    rate_limiter.record_failed_attempt(&client_id).await;\n                }\n\n                return Err(e);\n            }\n        };\n\n        // Validate permissions\n        self.validate_permissions(&claims)?;\n\n        // Check session if session management is enabled\n        if let Some(ref session_manager) = self.session_manager {\n            session_manager.validate_session(&claims.sub, &token).await?;\n        }\n\n        // Store authentication information in context\n        context.set_property(\"authenticated\".to_string(), \"true\".to_string());\n        context.set_property(\"user_id\".to_string(), claims.sub.clone());\n        context.set_property(\"user_roles\".to_string(), claims.roles.join(\",\"));\n        context.set_property(\"user_permissions\".to_string(), claims.permissions.join(\",\"));\n\n        // Store claims for use by handlers\n        context.set_auth_claims(claims);\n\n        debug!(\"Authentication successful for user: {}\", context.get_property(\"user_id\").unwrap_or(&\"unknown\".to_string()));\n        Ok(())\n    }\n}\n\n/// Rate limiter for authentication attempts\nstruct RateLimiter {\n    max_attempts: u32,\n    window: Duration,\n    lockout: Duration,\n    attempts: Arc<RwLock<HashMap<String, AttemptRecord>>>,\n}\n\n#[derive(Debug, Clone)]\nstruct AttemptRecord {\n    count: u32,\n    window_start: Instant,\n    locked_until: Option<Instant>,\n}\n\nimpl RateLimiter {\n    fn new(max_attempts: u32, window: Duration, lockout: Duration) -> Self {\n        Self {\n            max_attempts,\n            window,\n            lockout,\n            attempts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    async fn check_rate_limit(&self, client_id: &str) -> bool {\n        let mut attempts = self.attempts.write().await;\n        let now = Instant::now();\n\n        let record = attempts.entry(client_id.to_string()).or_insert(AttemptRecord {\n            count: 0,\n            window_start: now,\n            locked_until: None,\n        });\n\n        // Check if client is locked out\n        if let Some(locked_until) = record.locked_until {\n            if now < locked_until {\n                return false;\n            } else {\n                // Lockout expired, reset\n                record.locked_until = None;\n                record.count = 0;\n                record.window_start = now;\n            }\n        }\n\n        // Check if we need to reset the window\n        if now.duration_since(record.window_start) > self.window {\n            record.count = 0;\n            record.window_start = now;\n        }\n\n        record.count < self.max_attempts\n    }\n\n    async fn record_failed_attempt(&self, client_id: &str) {\n        let mut attempts = self.attempts.write().await;\n        let now = Instant::now();\n\n        let record = attempts.entry(client_id.to_string()).or_insert(AttemptRecord {\n            count: 0,\n            window_start: now,\n            locked_until: None,\n        });\n\n        record.count += 1;\n\n        if record.count >= self.max_attempts {\n            record.locked_until = Some(now + self.lockout);\n            warn!(\"Client {} locked out due to too many failed authentication attempts\", client_id);\n        }\n    }\n}\n\n/// Session manager for tracking user sessions\nstruct SessionManager {\n    timeout: Duration,\n    extend_on_activity: bool,\n    max_concurrent_sessions: Option<u32>,\n    sessions: Arc<RwLock<HashMap<String, Vec<SessionInfo>>>>,\n}\n\n#[derive(Debug, Clone)]\nstruct SessionInfo {\n    token_hash: String,\n    created_at: Instant,\n    last_activity: Instant,\n}\n\nimpl SessionManager {\n    fn new(timeout: Duration, extend_on_activity: bool, max_concurrent_sessions: Option<u32>) -> Self {\n        Self {\n            timeout,\n            extend_on_activity,\n            max_concurrent_sessions,\n            sessions: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    async fn validate_session(&self, user_id: &str, token: &str) -> AsyncApiResult<()> {\n        let mut sessions = self.sessions.write().await;\n        let now = Instant::now();\n        let token_hash = self.hash_token(token);\n\n        let user_sessions = sessions.entry(user_id.to_string()).or_insert_with(Vec::new);\n\n        // Remove expired sessions\n        user_sessions.retain(|session| {\n            now.duration_since(session.last_activity) <= self.timeout\n        });\n\n        // Find current session\n        if let Some(session) = user_sessions.iter_mut().find(|s| s.token_hash == token_hash) {\n            // Check if session is expired\n            if now.duration_since(session.last_activity) > self.timeout {\n                return Err(AsyncApiError::Authentication {\n                    message: \"Session has expired\".to_string(),\n                    source: None,\n                });\n            }\n\n            // Extend session if configured\n            if self.extend_on_activity {\n                session.last_activity = now;\n            }\n\n            Ok(())\n        } else {\n            // New session\n            if let Some(max_sessions) = self.max_concurrent_sessions {\n                if user_sessions.len() >= max_sessions as usize {\n                    // Remove oldest session\n                    user_sessions.sort_by_key(|s| s.created_at);\n                    user_sessions.remove(0);\n                }\n            }\n\n            user_sessions.push(SessionInfo {\n                token_hash,\n                created_at: now,\n                last_activity: now,\n            });\n\n            Ok(())\n        }\n    }\n\n    fn hash_token(&self, token: &str) -> String {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        token.hash(&mut hasher);\n        format!(\"{:x}\", hasher.finish())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::AuthConfig;\n\n    #[tokio::test]\n    async fn test_rate_limiter() {\n        let rate_limiter = RateLimiter::new(3, Duration::from_secs(60), Duration::from_secs(300));\n        let client_id = \"test_client\";\n\n        // Should allow initial attempts\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n\n        // Record failed attempts\n        rate_limiter.record_failed_attempt(client_id).await;\n        rate_limiter.record_failed_attempt(client_id).await;\n        rate_limiter.record_failed_attempt(client_id).await;\n\n        // Should be locked out now\n        assert!(!rate_limiter.check_rate_limit(client_id).await);\n    }\n\n    #[tokio::test]\n    async fn test_session_manager() {\n        let session_manager = SessionManager::new(\n            Duration::from_secs(3600),\n            true,\n            Some(2),\n        );\n\n        let user_id = \"test_user\";\n        let token1 = \"token1\";\n        let token2 = \"token2\";\n\n        // Validate new sessions\n        assert!(session_manager.validate_session(user_id, token1).await.is_ok());\n        assert!(session_manager.validate_session(user_id, token2).await.is_ok());\n\n        // Validate existing sessions\n        assert!(session_manager.validate_session(user_id, token1).await.is_ok());\n        assert!(session_manager.validate_session(user_id, token2).await.is_ok());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AuthRbacRs() {\n    return (\n        <File name=\"rbac.rs\">\n            {`//! Role-Based Access Control (RBAC) system\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, warn};\n\n/// A role in the RBAC system\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct Role {\n    /// Role name\n    pub name: String,\n    /// Role description\n    pub description: String,\n    /// Permissions granted by this role\n    pub permissions: HashSet<Permission>,\n    /// Parent roles (for role inheritance)\n    pub parent_roles: HashSet<String>,\n    /// Whether this role is active\n    pub active: bool,\n}\n\nimpl Role {\n    /// Create a new role\n    pub fn new(name: &str, description: &str) -> Self {\n        Self {\n            name: name.to_string(),\n            description: description.to_string(),\n            permissions: HashSet::new(),\n            parent_roles: HashSet::new(),\n            active: true,\n        }\n    }\n\n    /// Add a permission to this role\n    pub fn with_permission(mut self, permission: Permission) -> Self {\n        self.permissions.insert(permission);\n        self\n    }\n\n    /// Add multiple permissions to this role\n    pub fn with_permissions(mut self, permissions: Vec<Permission>) -> Self {\n        self.permissions.extend(permissions);\n        self\n    }\n\n    /// Add a parent role for inheritance\n    pub fn with_parent_role(mut self, parent_role: &str) -> Self {\n        self.parent_roles.insert(parent_role.to_string());\n        self\n    }\n\n    /// Check if this role has a specific permission\n    pub fn has_permission(&self, permission: &Permission) -> bool {\n        self.permissions.contains(permission)\n    }\n\n    /// Get all permissions including inherited ones\n    pub fn get_all_permissions(&self, role_manager: &RoleManager) -> HashSet<Permission> {\n        let mut all_permissions = self.permissions.clone();\n\n        // Add permissions from parent roles\n        for parent_name in &self.parent_roles {\n            if let Some(parent_role) = role_manager.get_role(parent_name) {\n                all_permissions.extend(parent_role.get_all_permissions(role_manager));\n            }\n        }\n\n        all_permissions\n    }\n}\n\n/// A permission in the RBAC system\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct Permission {\n    /// Permission name (e.g., \"read:users\", \"write:messages\")\n    pub name: String,\n    /// Resource this permission applies to\n    pub resource: String,\n    /// Action this permission allows\n    pub action: String,\n    /// Optional conditions for this permission\n    pub conditions: Option<PermissionConditions>,\n}\n\nimpl Permission {\n    /// Create a new permission\n    pub fn new(resource: &str, action: &str) -> Self {\n        Self {\n            name: format!(\"{}:{}\", action, resource),\n            resource: resource.to_string(),\n            action: action.to_string(),\n            conditions: None,\n        }\n    }\n\n    /// Create a permission with conditions\n    pub fn with_conditions(mut self, conditions: PermissionConditions) -> Self {\n        self.conditions = Some(conditions);\n        self\n    }\n\n    /// Check if this permission matches a required permission\n    pub fn matches(&self, required: &Permission) -> bool {\n        // Basic name matching\n        if self.name == required.name {\n            return true;\n        }\n\n        // Wildcard matching\n        if self.action == \"*\" && self.resource == required.resource {\n            return true;\n        }\n\n        if self.resource == \"*\" && self.action == required.action {\n            return true;\n        }\n\n        if self.action == \"*\" && self.resource == \"*\" {\n            return true;\n        }\n\n        false\n    }\n}\n\n/// Conditions that can be applied to permissions\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct PermissionConditions {\n    /// Time-based conditions\n    pub time_restrictions: Option<TimeRestrictions>,\n    /// IP-based conditions\n    pub ip_restrictions: Option<Vec<String>>,\n    /// Custom conditions\n    pub custom_conditions: HashMap<String, String>,\n}\n\n/// Time-based restrictions for permissions\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct TimeRestrictions {\n    /// Start time (hour of day, 0-23)\n    pub start_hour: Option<u8>,\n    /// End time (hour of day, 0-23)\n    pub end_hour: Option<u8>,\n    /// Days of week (0=Sunday, 6=Saturday)\n    pub allowed_days: Option<Vec<u8>>,\n}\n\n/// Role manager for RBAC operations\npub struct RoleManager {\n    roles: Arc<RwLock<HashMap<String, Role>>>,\n    user_roles: Arc<RwLock<HashMap<String, HashSet<String>>>>,\n}\n\nimpl RoleManager {\n    /// Create a new role manager\n    pub fn new() -> Self {\n        Self {\n            roles: Arc::new(RwLock::new(HashMap::new())),\n            user_roles: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Create a role manager with default roles\n    pub async fn with_default_roles() -> Self {\n        let manager = Self::new();\n        manager.setup_default_roles().await;\n        manager\n    }\n\n    /// Set up default roles for common use cases\n    async fn setup_default_roles(&self) {\n        // Admin role with all permissions\n        let admin_role = Role::new(\"admin\", \"Administrator with full access\")\n            .with_permission(Permission::new(\"*\", \"*\"));\n\n        // User role with basic permissions\n        let user_role = Role::new(\"user\", \"Regular user with basic access\")\n            .with_permission(Permission::new(\"messages\", \"read\"))\n            .with_permission(Permission::new(\"profile\", \"read\"))\n            .with_permission(Permission::new(\"profile\", \"write\"));\n\n        // Guest role with read-only access\n        let guest_role = Role::new(\"guest\", \"Guest user with read-only access\")\n            .with_permission(Permission::new(\"messages\", \"read\"));\n\n        // Moderator role inheriting from user\n        let moderator_role = Role::new(\"moderator\", \"Moderator with additional permissions\")\n            .with_parent_role(\"user\")\n            .with_permission(Permission::new(\"messages\", \"write\"))\n            .with_permission(Permission::new(\"messages\", \"delete\"));\n\n        self.add_role(admin_role).await.ok();\n        self.add_role(user_role).await.ok();\n        self.add_role(guest_role).await.ok();\n        self.add_role(moderator_role).await.ok();\n    }\n\n    /// Add a role to the system\n    pub async fn add_role(&self, role: Role) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if roles.contains_key(&role.name) {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' already exists\", role.name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Adding role: {}\", role.name);\n        roles.insert(role.name.clone(), role);\n        Ok(())\n    }\n\n    /// Get a role by name\n    pub fn get_role(&self, name: &str) -> Option<Role> {\n        // This is a simplified synchronous version for internal use\n        // In a real implementation, you might want to use async here too\n        if let Ok(roles) = self.roles.try_read() {\n            roles.get(name).cloned()\n        } else {\n            None\n        }\n    }\n\n    /// Get a role by name (async version)\n    pub async fn get_role_async(&self, name: &str) -> Option<Role> {\n        let roles = self.roles.read().await;\n        roles.get(name).cloned()\n    }\n\n    /// Update a role\n    pub async fn update_role(&self, role: Role) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if !roles.contains_key(&role.name) {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' does not exist\", role.name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Updating role: {}\", role.name);\n        roles.insert(role.name.clone(), role);\n        Ok(())\n    }\n\n    /// Remove a role\n    pub async fn remove_role(&self, name: &str) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if roles.remove(name).is_none() {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' does not exist\", name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Removed role: {}\", name);\n\n        // Remove role from all users\n        let mut user_roles = self.user_roles.write().await;\n        for user_role_set in user_roles.values_mut() {\n            user_role_set.remove(name);\n        }\n\n        Ok(())\n    }\n\n    /// Assign a role to a user\n    pub async fn assign_role_to_user(&self, user_id: &str, role_name: &str) -> AsyncApiResult<()> {\n        // Check if role exists\n        {\n            let roles = self.roles.read().await;\n            if !roles.contains_key(role_name) {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"Role '{}' does not exist\", role_name),\n                    required_permissions: vec![],\n                    user_permissions: vec![],\n                });\n            }\n        }\n\n        let mut user_roles = self.user_roles.write().await;\n        let user_role_set = user_roles.entry(user_id.to_string()).or_insert_with(HashSet::new);\n        user_role_set.insert(role_name.to_string());\n\n        debug!(\"Assigned role '{}' to user '{}'\", role_name, user_id);\n        Ok(())\n    }\n\n    /// Remove a role from a user\n    pub async fn remove_role_from_user(&self, user_id: &str, role_name: &str) -> AsyncApiResult<()> {\n        let mut user_roles = self.user_roles.write().await;\n\n        if let Some(user_role_set) = user_roles.get_mut(user_id) {\n            user_role_set.remove(role_name);\n            debug!(\"Removed role '{}' from user '{}'\", role_name, user_id);\n        }\n\n        Ok(())\n    }\n\n    /// Get all roles for a user\n    pub async fn get_user_roles(&self, user_id: &str) -> Vec<Role> {\n        let user_roles = self.user_roles.read().await;\n        let roles = self.roles.read().await;\n\n        if let Some(role_names) = user_roles.get(user_id) {\n            role_names.iter()\n                .filter_map(|name| roles.get(name).cloned())\n                .collect()\n        } else {\n            Vec::new()\n        }\n    }\n\n    /// Get all permissions for a user (including inherited)\n    pub async fn get_user_permissions(&self, user_id: &str) -> HashSet<Permission> {\n        let user_roles = self.get_user_roles(user_id).await;\n        let mut all_permissions = HashSet::new();\n\n        for role in user_roles {\n            all_permissions.extend(role.get_all_permissions(self));\n        }\n\n        all_permissions\n    }\n\n    /// Check if a user has a specific permission\n    pub async fn user_has_permission(&self, user_id: &str, required_permission: &Permission) -> bool {\n        let user_permissions = self.get_user_permissions(user_id).await;\n\n        for permission in &user_permissions {\n            if permission.matches(required_permission) {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Check if a user has any of the required permissions\n    pub async fn user_has_any_permission(&self, user_id: &str, required_permissions: &[Permission]) -> bool {\n        for permission in required_permissions {\n            if self.user_has_permission(user_id, permission).await {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Check if a user has all of the required permissions\n    pub async fn user_has_all_permissions(&self, user_id: &str, required_permissions: &[Permission]) -> bool {\n        for permission in required_permissions {\n            if !self.user_has_permission(user_id, permission).await {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// List all roles\n    pub async fn list_roles(&self) -> Vec<Role> {\n        let roles = self.roles.read().await;\n        roles.values().cloned().collect()\n    }\n\n    /// Get role statistics\n    pub async fn get_statistics(&self) -> RoleStatistics {\n        let roles = self.roles.read().await;\n        let user_roles = self.user_roles.read().await;\n\n        RoleStatistics {\n            total_roles: roles.len(),\n            total_users_with_roles: user_roles.len(),\n            active_roles: roles.values().filter(|r| r.active).count(),\n            roles_by_name: roles.keys().cloned().collect(),\n        }\n    }\n}\n\nimpl Default for RoleManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Statistics about the RBAC system\n#[derive(Debug, Clone, Serialize)]\npub struct RoleStatistics {\n    pub total_roles: usize,\n    pub total_users_with_roles: usize,\n    pub active_roles: usize,\n    pub roles_by_name: Vec<String>,\n}\n\n/// Helper macros for creating permissions\n#[macro_export]\nmacro_rules! permission {\n    ($resource:expr, $action:expr) => {\n        Permission::new($resource, $action)\n    };\n}\n\n#[macro_export]\nmacro_rules! role {\n    ($name:expr, $description:expr) => {\n        Role::new($name, $description)\n    };\n    ($name:expr, $description:expr, [$($permission:expr),*]) => {\n        Role::new($name, $description)\n            $(.with_permission($permission))*\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_role_creation() {\n        let role = Role::new(\"test_role\", \"Test role\")\n            .with_permission(Permission::new(\"messages\", \"read\"))\n            .with_permission(Permission::new(\"users\", \"write\"));\n\n        assert_eq!(role.name, \"test_role\");\n        assert_eq!(role.permissions.len(), 2);\n        assert!(role.has_permission(&Permission::new(\"messages\", \"read\")));\n    }\n\n    #[tokio::test]\n    async fn test_permission_matching() {\n        let wildcard_permission = Permission::new(\"*\", \"read\");\n        let specific_permission = Permission::new(\"messages\", \"read\");\n\n        assert!(wildcard_permission.matches(&specific_permission));\n        assert!(specific_permission.matches(&specific_permission));\n    }\n\n    #[tokio::test]\n    async fn test_role_manager() {\n        let manager = RoleManager::new();\n\n        let role = Role::new(\"test_role\", \"Test role\")\n            .with_permission(Permission::new(\"messages\", \"read\"));\n\n        manager.add_role(role).await.unwrap();\n        manager.assign_role_to_user(\"user1\", \"test_role\").await.unwrap();\n\n        let user_roles = manager.get_user_roles(\"user1\").await;\n        assert_eq!(user_roles.len(), 1);\n        assert_eq!(user_roles[0].name, \"test_role\");\n\n        let has_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"messages\", \"read\")\n        ).await;\n        assert!(has_permission);\n    }\n\n    #[tokio::test]\n    async fn test_role_inheritance() {\n        let manager = RoleManager::new();\n\n        let parent_role = Role::new(\"parent\", \"Parent role\")\n            .with_permission(Permission::new(\"base\", \"read\"));\n\n        let child_role = Role::new(\"child\", \"Child role\")\n            .with_parent_role(\"parent\")\n            .with_permission(Permission::new(\"extra\", \"write\"));\n\n        manager.add_role(parent_role).await.unwrap();\n        manager.add_role(child_role).await.unwrap();\n        manager.assign_role_to_user(\"user1\", \"child\").await.unwrap();\n\n        // User should have permissions from both parent and child roles\n        let has_parent_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"base\", \"read\")\n        ).await;\n        let has_child_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"extra\", \"write\")\n        ).await;\n\n        assert!(has_parent_permission);\n        assert!(has_child_permission);\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function TransportMod({ asyncapi }) {\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    // Generate module declarations based on detected protocols\n    let moduleDeclarations = 'pub mod factory;\\n';\n\n    if (protocols.has('mqtt') || protocols.has('mqtts')) {\n        moduleDeclarations += 'pub mod mqtt;\\n';\n    }\n    if (protocols.has('kafka')) {\n        moduleDeclarations += 'pub mod kafka;\\n';\n    }\n    if (protocols.has('amqp') || protocols.has('amqps')) {\n        moduleDeclarations += 'pub mod amqp;\\n';\n    }\n    if (protocols.has('ws') || protocols.has('wss')) {\n        moduleDeclarations += 'pub mod websocket;\\n';\n    }\n    if (protocols.has('http') || protocols.has('https')) {\n        moduleDeclarations += 'pub mod http;\\n';\n    }\n\n    return (\n        <File name=\"mod.rs\">\n            {`//! Transport layer abstraction for AsyncAPI protocols\n//!\n//! This module provides a unified interface for different transport protocols\n//! including MQTT, Kafka, AMQP, WebSocket, and HTTP.\n#![allow(dead_code, unused_imports)]\n\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError};\nuse crate::models::AsyncApiMessage;\n\n${moduleDeclarations}\n\n/// Transport configuration for different protocols\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TransportConfig {\n    pub protocol: String,\n    pub host: String,\n    pub port: u16,\n    pub username: Option<String>,\n    pub password: Option<String>,\n    pub tls: bool,\n    pub additional_config: HashMap<String, String>,\n}\n\n/// Connection state for transport implementations\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ConnectionState {\n    Disconnected,\n    Connecting,\n    Connected,\n    Reconnecting,\n    Failed,\n}\n\n/// Transport statistics for monitoring\n#[derive(Debug, Clone, Default)]\npub struct TransportStats {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub bytes_sent: u64,\n    pub bytes_received: u64,\n    pub connection_attempts: u64,\n    pub last_error: Option<String>,\n}\n\n/// Message metadata for transport operations\n#[derive(Debug, Clone)]\npub struct MessageMetadata {\n    pub channel: String,\n    pub operation: String,\n    pub content_type: Option<String>,\n    pub headers: HashMap<String, String>,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n}\n\n/// Transport message wrapper\n#[derive(Debug, Clone)]\npub struct TransportMessage {\n    pub metadata: MessageMetadata,\n    pub payload: Vec<u8>,\n}\n\n/// Trait for transport implementations\n#[async_trait]\npub trait Transport: Send + Sync {\n    /// Connect to the transport\n    async fn connect(&mut self) -> AsyncApiResult<()>;\n\n    /// Disconnect from the transport\n    async fn disconnect(&mut self) -> AsyncApiResult<()>;\n\n    /// Check if transport is connected\n    fn is_connected(&self) -> bool;\n\n    /// Get current connection state\n    fn connection_state(&self) -> ConnectionState;\n\n    /// Send a message through the transport\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()>;\n\n    /// Subscribe to a channel/topic\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()>;\n\n    /// Unsubscribe from a channel/topic\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()>;\n\n    /// Start listening for messages (non-blocking)\n    async fn start_listening(&mut self) -> AsyncApiResult<()>;\n\n    /// Stop listening for messages\n    async fn stop_listening(&mut self) -> AsyncApiResult<()>;\n\n    /// Get transport statistics\n    fn get_stats(&self) -> TransportStats;\n\n    /// Health check for the transport\n    async fn health_check(&self) -> AsyncApiResult<bool>;\n\n    /// Get protocol name\n    fn protocol(&self) -> &str;\n}\n\n/// Message handler trait for processing incoming messages\n#[async_trait]\npub trait MessageHandler: Send + Sync {\n    async fn handle_message(&self, message: TransportMessage) -> AsyncApiResult<()>;\n}\n\n/// Transport manager for coordinating multiple transports\npub struct TransportManager {\n    transports: Arc<RwLock<HashMap<String, Box<dyn Transport>>>>,\n    handlers: Arc<RwLock<HashMap<String, Arc<dyn MessageHandler>>>>,\n    stats: Arc<RwLock<HashMap<String, TransportStats>>>,\n}\n\nimpl TransportManager {\n    /// Create a new transport manager\n    pub fn new() -> Self {\n        Self {\n            transports: Arc::new(RwLock::new(HashMap::new())),\n            handlers: Arc::new(RwLock::new(HashMap::new())),\n            stats: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Add a transport to the manager\n    pub async fn add_transport(&self, name: String, transport: Box<dyn Transport>) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        let protocol = transport.protocol().to_string();\n        transports.insert(name.clone(), transport);\n\n        // Initialize stats\n        let mut stats = self.stats.write().await;\n        stats.insert(name.clone(), TransportStats::default());\n\n        tracing::info!(\"Added {} transport: {}\", protocol, name);\n        Ok(())\n    }\n\n    /// Remove a transport from the manager\n    pub async fn remove_transport(&self, name: &str) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        if let Some(mut transport) = transports.remove(name) {\n            transport.disconnect().await?;\n        }\n\n        let mut stats = self.stats.write().await;\n        stats.remove(name);\n\n        tracing::info!(\"Removed transport: {}\", name);\n        Ok(())\n    }\n\n    /// Register a message handler for a channel\n    pub async fn register_handler(&self, channel: String, handler: Arc<dyn MessageHandler>) {\n        let mut handlers = self.handlers.write().await;\n        handlers.insert(channel.clone(), handler);\n        tracing::info!(\"Registered handler for channel: {}\", channel);\n    }\n\n    /// Connect all transports\n    pub async fn connect_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.connect().await {\n                Ok(_) => tracing::info!(\"Connected transport: {}\", name),\n                Err(e) => {\n                    tracing::error!(\"Failed to connect transport {}: {}\", name, e);\n                    return Err(e);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Disconnect all transports\n    pub async fn disconnect_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.disconnect().await {\n                Ok(_) => tracing::info!(\"Disconnected transport: {}\", name),\n                Err(e) => tracing::error!(\"Failed to disconnect transport {}: {}\", name, e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Start listening on all transports\n    pub async fn start_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.start_listening().await {\n                Ok(_) => tracing::info!(\"Started listening on transport: {}\", name),\n                Err(e) => {\n                    tracing::error!(\"Failed to start listening on transport {}: {}\", name, e);\n                    return Err(e);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Stop listening on all transports\n    pub async fn stop_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.stop_listening().await {\n                Ok(_) => tracing::info!(\"Stopped listening on transport: {}\", name),\n                Err(e) => tracing::error!(\"Failed to stop listening on transport {}: {}\", name, e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Get aggregated statistics from all transports\n    pub async fn get_all_stats(&self) -> HashMap<String, TransportStats> {\n        let transports = self.transports.read().await;\n        let mut all_stats = HashMap::new();\n\n        for (name, transport) in transports.iter() {\n            all_stats.insert(name.clone(), transport.get_stats());\n        }\n\n        all_stats\n    }\n\n    /// Perform health check on all transports\n    pub async fn health_check_all(&self) -> HashMap<String, bool> {\n        let transports = self.transports.read().await;\n        let mut health_status = HashMap::new();\n\n        for (name, transport) in transports.iter() {\n            let is_healthy = transport.health_check().await.unwrap_or(false);\n            health_status.insert(name.clone(), is_healthy);\n        }\n\n        health_status\n    }\n}\n\nimpl Default for TransportManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function TransportFactory({ asyncapi }) {\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    // Generate imports based on detected protocols\n    let imports = '';\n\n    if (protocols.has('mqtt') || protocols.has('mqtts')) {\n        imports += 'use crate::transport::mqtt::MqttTransport;\\n';\n    }\n    if (protocols.has('kafka')) {\n        imports += 'use crate::transport::kafka::KafkaTransport;\\n';\n    }\n    if (protocols.has('amqp') || protocols.has('amqps')) {\n        imports += 'use crate::transport::amqp::AmqpTransport;\\n';\n    }\n    if (protocols.has('ws') || protocols.has('wss')) {\n        imports += 'use crate::transport::websocket::WebSocketTransport;\\n';\n    }\n    if (protocols.has('http') || protocols.has('https')) {\n        imports += 'use crate::transport::http::HttpTransport;\\n';\n    }\n\n    return (\n        <File name=\"factory.rs\">\n            {`//! Transport factory for creating transport instances based on protocol\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{Transport, TransportConfig};\n${imports}\n\n/// Factory for creating transport instances based on protocol\npub struct TransportFactory;\n\nimpl TransportFactory {\n    /// Create a transport instance based on the protocol\n    pub fn create_transport(config: TransportConfig) -> AsyncApiResult<Box<dyn Transport>> {\n        match config.protocol.to_lowercase().as_str() {${protocols.has('mqtt') || protocols.has('mqtts') ? `\n            \"mqtt\" | \"mqtts\" => {\n                let transport = MqttTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('kafka') ? `\n            \"kafka\" => {\n                let transport = KafkaTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('amqp') || protocols.has('amqps') ? `\n            \"amqp\" | \"amqps\" => {\n                let transport = AmqpTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('ws') || protocols.has('wss') ? `\n            \"ws\" | \"wss\" | \"websocket\" => {\n                let transport = WebSocketTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('http') || protocols.has('https') ? `\n            \"http\" | \"https\" => {\n                let transport = HttpTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}\n            _ => Err(AsyncApiError::new(\n                format!(\"Unsupported protocol: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            )),\n        }\n    }\n\n    /// Create multiple transports from a configuration map\n    pub fn create_transports(\n        configs: HashMap<String, TransportConfig>,\n    ) -> AsyncApiResult<HashMap<String, Box<dyn Transport>>> {\n        let mut transports = HashMap::new();\n\n        for (name, config) in configs {\n            let transport = Self::create_transport(config)?;\n            transports.insert(name, transport);\n        }\n\n        Ok(transports)\n    }\n\n    /// Get supported protocols\n    pub fn supported_protocols() -> Vec<&'static str> {\n        vec![\"mqtt\", \"mqtts\", \"kafka\", \"amqp\", \"amqps\", \"ws\", \"wss\", \"websocket\", \"http\", \"https\"]\n    }\n\n    /// Check if a protocol is supported\n    pub fn is_protocol_supported(protocol: &str) -> bool {\n        Self::supported_protocols().contains(&protocol.to_lowercase().as_str())\n    }\n\n    /// Create transport configuration from AsyncAPI server specification\n    pub fn config_from_server(\n        _server_name: &str,\n        protocol: &str,\n        host: &str,\n        port: u16,\n        additional_config: HashMap<String, String>,\n    ) -> TransportConfig {\n        TransportConfig {\n            protocol: protocol.to_string(),\n            host: host.to_string(),\n            port,\n            username: additional_config.get(\"username\").cloned(),\n            password: additional_config.get(\"password\").cloned(),\n            tls: protocol.ends_with('s') || additional_config.get(\"tls\").map_or(false, |v| v == \"true\"),\n            additional_config,\n        }\n    }\n\n    /// Validate transport configuration\n    pub fn validate_config(config: &TransportConfig) -> AsyncApiResult<()> {\n        // Check if protocol is supported\n        if !Self::is_protocol_supported(&config.protocol) {\n            return Err(AsyncApiError::new(\n                format!(\"Unsupported protocol: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Validate host\n        if config.host.is_empty() {\n            return Err(AsyncApiError::new(\n                \"Host cannot be empty\".to_string(),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Validate port\n        if config.port == 0 {\n            return Err(AsyncApiError::new(\n                \"Port cannot be zero\".to_string(),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Protocol-specific validation\n        match config.protocol.to_lowercase().as_str() {\n            \"mqtt\" | \"mqtts\" => {\n                // MQTT-specific validation\n                if config.port < 1024 && !config.additional_config.contains_key(\"allow_privileged_ports\") {\n                    tracing::warn!(\"Using privileged port {} for MQTT\", config.port);\n                }\n            }\n            \"kafka\" => {\n                // Kafka-specific validation\n                if config.port != 9092 && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for Kafka\", config.port);\n                }\n            }\n            \"amqp\" | \"amqps\" => {\n                // AMQP-specific validation\n                let default_port = if config.protocol == \"amqps\" { 5671 } else { 5672 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for AMQP\", config.port);\n                }\n            }\n            \"ws\" | \"wss\" | \"websocket\" => {\n                // WebSocket-specific validation\n                let default_port = if config.protocol == \"wss\" { 443 } else { 80 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for WebSocket\", config.port);\n                }\n            }\n            \"http\" | \"https\" => {\n                // HTTP-specific validation\n                let default_port = if config.protocol == \"https\" { 443 } else { 80 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for HTTP\", config.port);\n                }\n            }\n            _ => {\n                // This should not happen due to earlier validation\n                return Err(AsyncApiError::new(\n                    format!(\"Unknown protocol for validation: {}\", config.protocol),\n                    ErrorCategory::Configuration,\n                    None,\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Create default configuration for a protocol\n    pub fn default_config(protocol: &str) -> AsyncApiResult<TransportConfig> {\n        let (default_port, tls) = match protocol.to_lowercase().as_str() {\n            \"mqtt\" => (1883, false),\n            \"mqtts\" => (8883, true),\n            \"kafka\" => (9092, false),\n            \"amqp\" => (5672, false),\n            \"amqps\" => (5671, true),\n            \"ws\" | \"websocket\" => (80, false),\n            \"wss\" => (443, true),\n            \"http\" => (80, false),\n            \"https\" => (443, true),\n            _ => {\n                return Err(AsyncApiError::new(\n                    format!(\"Unsupported protocol: {}\", protocol),\n                    ErrorCategory::Configuration,\n                    None,\n                ));\n            }\n        };\n\n        Ok(TransportConfig {\n            protocol: protocol.to_string(),\n            host: \"localhost\".to_string(),\n            port: default_port,\n            username: None,\n            password: None,\n            tls,\n            additional_config: HashMap::new(),\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_supported_protocols() {\n        let protocols = TransportFactory::supported_protocols();\n        assert!(protocols.contains(&\"mqtt\"));\n        assert!(protocols.contains(&\"kafka\"));\n        assert!(protocols.contains(&\"amqp\"));\n        assert!(protocols.contains(&\"ws\"));\n        assert!(protocols.contains(&\"http\"));\n    }\n\n    #[test]\n    fn test_is_protocol_supported() {\n        assert!(TransportFactory::is_protocol_supported(\"mqtt\"));\n        assert!(TransportFactory::is_protocol_supported(\"MQTT\"));\n        assert!(TransportFactory::is_protocol_supported(\"kafka\"));\n        assert!(!TransportFactory::is_protocol_supported(\"unknown\"));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = TransportFactory::default_config(\"mqtt\").unwrap();\n        assert_eq!(config.protocol, \"mqtt\");\n        assert_eq!(config.host, \"localhost\");\n        assert_eq!(config.port, 1883);\n        assert!(!config.tls);\n\n        let config = TransportFactory::default_config(\"mqtts\").unwrap();\n        assert_eq!(config.protocol, \"mqtts\");\n        assert_eq!(config.port, 8883);\n        assert!(config.tls);\n    }\n\n    #[test]\n    fn test_validate_config() {\n        let mut config = TransportFactory::default_config(\"mqtt\").unwrap();\n        assert!(TransportFactory::validate_config(&config).is_ok());\n\n        // Test invalid protocol\n        config.protocol = \"invalid\".to_string();\n        assert!(TransportFactory::validate_config(&config).is_err());\n\n        // Test empty host\n        config.protocol = \"mqtt\".to_string();\n        config.host = \"\".to_string();\n        assert!(TransportFactory::validate_config(&config).is_err());\n\n        // Test zero port\n        config.host = \"localhost\".to_string();\n        config.port = 0;\n        assert!(TransportFactory::validate_config(&config).is_err());\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function MqttTransport({ asyncapi }) {\n    // Check if MQTT protocol is used\n    const servers = asyncapi.servers();\n    let hasMqtt = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['mqtt', 'mqtts'].includes(protocol.toLowerCase())) {\n                hasMqtt = true;\n            }\n        });\n    }\n\n    // Only generate file if MQTT is used\n    if (!hasMqtt) {\n        return null;\n    }\n\n    return (\n        <File name=\"mqtt.rs\">\n            {`//! MQTT transport implementation\n\nuse async_trait::async_trait;\nuse rumqttc::{AsyncClient, Event, EventLoop, MqttOptions, Packet, QoS};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// MQTT transport implementation\npub struct MqttTransport {\n    config: TransportConfig,\n    client: Option<AsyncClient>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<HashMap<String, QoS>>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl MqttTransport {\n    /// Create a new MQTT transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"mqtt\" && config.protocol != \"mqtts\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for MQTT transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            client: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create MQTT options from configuration\n    fn create_mqtt_options(&self) -> AsyncApiResult<MqttOptions> {\n        let client_id = self.config.additional_config\n            .get(\"client_id\")\n            .cloned()\n            .unwrap_or_else(|| format!(\"asyncapi-client-{}\", uuid::Uuid::new_v4()));\n\n        let mut mqtt_options = MqttOptions::new(client_id, &self.config.host, self.config.port);\n\n        // Set credentials if provided\n        if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            mqtt_options.set_credentials(username, password);\n        }\n\n        // Configure TLS if enabled\n        if self.config.tls {\n            let tls_config = rumqttc::TlsConfiguration::Simple {\n                ca: vec![],\n                alpn: None,\n                client_auth: None,\n            };\n            mqtt_options.set_transport(rumqttc::Transport::Tls(tls_config));\n        }\n\n        // Set keep alive interval\n        if let Some(keep_alive) = self.config.additional_config\n            .get(\"keep_alive\")\n            .and_then(|v| v.parse::<u64>().ok())\n        {\n            mqtt_options.set_keep_alive(Duration::from_secs(keep_alive));\n        } else {\n            mqtt_options.set_keep_alive(Duration::from_secs(60));\n        }\n\n        // Set clean session\n        let clean_session = self.config.additional_config\n            .get(\"clean_session\")\n            .map(|v| v.parse::<bool>().unwrap_or(true))\n            .unwrap_or(true);\n        mqtt_options.set_clean_session(clean_session);\n\n        // Set max packet size\n        if let Some(max_packet_size) = self.config.additional_config\n            .get(\"max_packet_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            mqtt_options.set_max_packet_size(max_packet_size, max_packet_size);\n        }\n\n        Ok(mqtt_options)\n    }\n\n    /// Start the MQTT event loop\n    async fn start_event_loop(&mut self, mut event_loop: EventLoop) -> AsyncApiResult<()> {\n        let connection_state = Arc::clone(&self.connection_state);\n        let stats_arc = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        tokio::spawn(async move {\n            loop {\n                tokio::select! {\n                    event = event_loop.poll() => {\n                        match event {\n                            Ok(Event::Incoming(Packet::Publish(publish))) => {\n                                {\n                                    let mut stats = stats_arc.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += publish.payload.len() as u64;\n                                }\n\n                                if let Some(handler) = &message_handler {\n                                    let mut headers = HashMap::new();\n                                    headers.insert(\"topic\".to_string(), publish.topic.clone());\n                                    headers.insert(\"qos\".to_string(), format!(\"{:?}\", publish.qos));\n                                    headers.insert(\"retain\".to_string(), publish.retain.to_string());\n                                    headers.insert(\"dup\".to_string(), publish.dup.to_string());\n\n                                    let metadata = MessageMetadata {\n                                        channel: publish.topic.clone(),\n                                        operation: \"receive\".to_string(),\n                                        content_type: Some(\"application/octet-stream\".to_string()),\n                                        headers,\n                                        timestamp: chrono::Utc::now(),\n                                    };\n\n                                    let transport_message = TransportMessage {\n                                        metadata,\n                                        payload: publish.payload.to_vec(),\n                                    };\n\n                                    if let Err(e) = handler.handle_message(transport_message).await {\n                                        tracing::error!(\"Failed to handle MQTT message: {}\", e);\n                                        let mut error_stats = stats_arc.write().await;\n                                        error_stats.last_error = Some(e.to_string());\n                                    }\n                                }\n                            }\n                            Ok(Event::Incoming(Packet::ConnAck(_))) => {\n                                *connection_state.write().await = ConnectionState::Connected;\n                                tracing::info!(\"MQTT connection established\");\n                            }\n                            Ok(Event::Incoming(Packet::Disconnect)) => {\n                                *connection_state.write().await = ConnectionState::Disconnected;\n                                tracing::info!(\"MQTT disconnected\");\n                            }\n                            Ok(Event::Outgoing(_)) => {\n                                // Handle outgoing packets if needed\n                            }\n                            Err(e) => {\n                                tracing::error!(\"MQTT event loop error: {}\", e);\n                                *connection_state.write().await = ConnectionState::Failed;\n                                let mut stats = stats_arc.write().await;\n                                stats.last_error = Some(e.to_string());\n                                break;\n                            }\n                            _ => {\n                                // Handle other packet types\n                            }\n                        }\n                    }\n                    _ = shutdown_rx.recv() => {\n                        tracing::info!(\"MQTT event loop shutdown requested\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for MqttTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let mqtt_options = self.create_mqtt_options()?;\n        let (client, event_loop) = AsyncClient::new(mqtt_options, 10);\n\n        self.client = Some(client);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        // Start event loop\n        self.start_event_loop(event_loop).await?;\n\n        tracing::info!(\"MQTT transport connection initiated\");\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        if let Some(client) = &self.client {\n            if let Err(e) = client.disconnect().await {\n                tracing::warn!(\"Error disconnecting MQTT client: {}\", e);\n            }\n        }\n\n        self.client = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"MQTT transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let topic = &message.metadata.channel;\n        let qos = message.metadata.headers\n            .get(\"qos\")\n            .and_then(|q| match q.as_str() {\n                \"0\" => Some(QoS::AtMostOnce),\n                \"1\" => Some(QoS::AtLeastOnce),\n                \"2\" => Some(QoS::ExactlyOnce),\n                _ => None,\n            })\n            .unwrap_or(QoS::AtMostOnce);\n\n        let retain = message.metadata.headers\n            .get(\"retain\")\n            .map(|r| r.parse::<bool>().unwrap_or(false))\n            .unwrap_or(false);\n\n        let payload_len = message.payload.len();\n\n        client\n            .publish(topic, qos, retain, message.payload)\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to publish MQTT message: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += payload_len as u64;\n\n        tracing::debug!(\"Published MQTT message to topic: {}\", topic);\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let qos = QoS::AtMostOnce; // Default QoS, could be configurable\n\n        client.subscribe(channel, qos).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to subscribe to MQTT topic: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.insert(channel.to_string(), qos);\n\n        tracing::info!(\"Subscribed to MQTT topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        client.unsubscribe(channel).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to unsubscribe from MQTT topic: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.remove(channel);\n\n        tracing::info!(\"Unsubscribed from MQTT topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // MQTT listening is handled by the event loop, which is started in connect()\n        tracing::info!(\"MQTT transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for MqttTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function KafkaTransport({ asyncapi }) {\n    // Check if Kafka protocol is used\n    const servers = asyncapi.servers();\n    let hasKafka = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && protocol.toLowerCase() === 'kafka') {\n                hasKafka = true;\n            }\n        });\n    }\n\n    // Only generate file if Kafka is used\n    if (!hasKafka) {\n        return null;\n    }\n\n    return (\n        <File name=\"kafka.rs\">\n            {`//! Kafka transport implementation\n\nuse async_trait::async_trait;\nuse rdkafka::config::ClientConfig;\nuse rdkafka::consumer::{Consumer, StreamConsumer};\nuse rdkafka::producer::{FutureProducer, FutureRecord};\nuse rdkafka::{Message, TopicPartitionList};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse tokio_stream::StreamExt;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// Kafka transport implementation\npub struct KafkaTransport {\n    config: TransportConfig,\n    producer: Option<FutureProducer>,\n    consumer: Option<StreamConsumer>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<Vec<String>>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl KafkaTransport {\n    /// Create a new Kafka transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"kafka\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for Kafka transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            producer: None,\n            consumer: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(Vec::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create Kafka client configuration\n    fn create_client_config(&self) -> ClientConfig {\n        let mut config = ClientConfig::new();\n\n        // Set bootstrap servers\n        let bootstrap_servers = format!(\"{}:{}\", self.config.host, self.config.port);\n        config.set(\"bootstrap.servers\", &bootstrap_servers);\n\n        // Set security configuration\n        if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            config.set(\"security.protocol\", \"SASL_PLAINTEXT\");\n            config.set(\"sasl.mechanism\", \"PLAIN\");\n            config.set(\"sasl.username\", username);\n            config.set(\"sasl.password\", password);\n        }\n\n        if self.config.tls {\n            if self.config.username.is_some() {\n                config.set(\"security.protocol\", \"SASL_SSL\");\n            } else {\n                config.set(\"security.protocol\", \"SSL\");\n            }\n        }\n\n        // Set additional configuration\n        for (key, value) in &self.config.additional_config {\n            config.set(key, value);\n        }\n\n        // Set default configurations if not provided\n        if !self.config.additional_config.contains_key(\"client.id\") {\n            let client_id = format!(\"asyncapi-client-{}\", uuid::Uuid::new_v4());\n            config.set(\"client.id\", &client_id);\n        }\n\n        config\n    }\n\n    /// Create producer configuration\n    fn create_producer_config(&self) -> ClientConfig {\n        let mut config = self.create_client_config();\n\n        // Producer-specific settings\n        config.set(\"message.timeout.ms\", \"30000\");\n        config.set(\"queue.buffering.max.messages\", \"100000\");\n        config.set(\"queue.buffering.max.ms\", \"1000\");\n        config.set(\"batch.num.messages\", \"1000\");\n\n        // Set compression if specified\n        if let Some(compression) = self.config.additional_config.get(\"compression.type\") {\n            config.set(\"compression.type\", compression);\n        } else {\n            config.set(\"compression.type\", \"snappy\");\n        }\n\n        config\n    }\n\n    /// Create consumer configuration\n    fn create_consumer_config(&self) -> ClientConfig {\n        let mut config = self.create_client_config();\n\n        // Consumer-specific settings\n        let group_id = self.config.additional_config\n            .get(\"group.id\")\n            .cloned()\n            .unwrap_or_else(|| format!(\"asyncapi-group-{}\", uuid::Uuid::new_v4()));\n        config.set(\"group.id\", &group_id);\n\n        config.set(\"enable.auto.commit\", \"true\");\n        config.set(\"auto.commit.interval.ms\", \"5000\");\n        config.set(\"session.timeout.ms\", \"30000\");\n        config.set(\"heartbeat.interval.ms\", \"10000\");\n\n        // Set auto offset reset\n        let auto_offset_reset = self.config.additional_config\n            .get(\"auto.offset.reset\")\n            .map(|s| s.as_str())\n            .unwrap_or(\"latest\");\n        config.set(\"auto.offset.reset\", auto_offset_reset);\n\n        config\n    }\n\n    /// Start consuming messages\n    async fn start_consumer_loop(&mut self) -> AsyncApiResult<()> {\n        if let Some(consumer) = &self.consumer {\n            let consumer = consumer.clone();\n            let connection_state = Arc::clone(&self.connection_state);\n            let stats = Arc::clone(&self.stats);\n            let message_handler = self.message_handler.clone();\n            let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n            self.shutdown_tx = Some(shutdown_tx);\n\n            tokio::spawn(async move {\n                let mut message_stream = consumer.stream();\n\n                loop {\n                    tokio::select! {\n                        message_result = message_stream.next() => {\n                            match message_result {\n                                Some(Ok(message)) => {\n                                    let mut stats = stats.write().await;\n                                    stats.messages_received += 1;\n                                    if let Some(payload) = message.payload() {\n                                        stats.bytes_received += payload.len() as u64;\n                                    }\n                                    drop(stats);\n\n                                    if let Some(handler) = &message_handler {\n                                        let topic = message.topic().to_string();\n                                        let partition = message.partition();\n                                        let offset = message.offset();\n\n                                        let mut headers = HashMap::new();\n                                        headers.insert(\"partition\".to_string(), partition.to_string());\n                                        headers.insert(\"offset\".to_string(), offset.to_string());\n\n                                        if let Some(key) = message.key() {\n                                            if let Ok(key_str) = std::str::from_utf8(key) {\n                                                headers.insert(\"key\".to_string(), key_str.to_string());\n                                            }\n                                        }\n\n                                        if let Some(kafka_headers) = message.headers() {\n                                            for header in kafka_headers.iter() {\n                                                if let Ok(value_str) = std::str::from_utf8(header.value) {\n                                                    headers.insert(header.key.to_string(), value_str.to_string());\n                                                }\n                                            }\n                                        }\n\n                                        let metadata = MessageMetadata {\n                                            channel: topic,\n                                            operation: \"receive\".to_string(),\n                                            content_type: Some(\"application/octet-stream\".to_string()),\n                                            headers,\n                                            timestamp: chrono::Utc::now(),\n                                        };\n\n                                        let payload = message.payload().unwrap_or(&[]).to_vec();\n                                        let transport_message = TransportMessage { metadata, payload };\n\n                                        if let Err(e) = handler.handle_message(transport_message).await {\n                                            tracing::error!(\"Failed to handle Kafka message: {}\", e);\n                                            let mut stats = stats.write().await;\n                                            stats.last_error = Some(e.to_string());\n                                        }\n                                    }\n                                }\n                                Some(Err(e)) => {\n                                    tracing::error!(\"Kafka consumer error: {}\", e);\n                                    let mut stats = stats.write().await;\n                                    stats.last_error = Some(e.to_string());\n                                }\n                                None => {\n                                    tracing::info!(\"Kafka consumer stream ended\");\n                                    break;\n                                }\n                            }\n                        }\n                        _ = shutdown_rx.recv() => {\n                            tracing::info!(\"Kafka consumer shutdown requested\");\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for KafkaTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        // Create producer\n        let producer_config = self.create_producer_config();\n        let producer: FutureProducer = producer_config.create().map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create Kafka producer: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        // Create consumer\n        let consumer_config = self.create_consumer_config();\n        let consumer: StreamConsumer = consumer_config.create().map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create Kafka consumer: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        self.producer = Some(producer);\n        self.consumer = Some(consumer);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        // Start consumer loop\n        self.start_consumer_loop().await?;\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"Kafka transport connected successfully\");\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        self.producer = None;\n        self.consumer = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"Kafka transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        matches!(\n            *self.connection_state.try_read().unwrap_or_else(|_| {\n                std::sync::RwLockReadGuard::map(\n                    std::sync::RwLock::new(ConnectionState::Disconnected).read().unwrap(),\n                    |state| state\n                )\n            }),\n            ConnectionState::Connected\n        )\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        *self.connection_state.try_read().unwrap_or_else(|_| {\n            std::sync::RwLockReadGuard::map(\n                std::sync::RwLock::new(ConnectionState::Disconnected).read().unwrap(),\n                |state| state\n            )\n        })\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        let producer = self.producer.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"Kafka producer not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let mut record = FutureRecord::to(&message.metadata.channel)\n            .payload(&message.payload);\n\n        // Set key if provided\n        if let Some(key) = message.metadata.headers.get(\"key\") {\n            record = record.key(key);\n        }\n\n        // Set partition if provided\n        if let Some(partition_str) = message.metadata.headers.get(\"partition\") {\n            if let Ok(partition) = partition_str.parse::<i32>() {\n                record = record.partition(partition);\n            }\n        }\n\n        // Set headers\n        let mut kafka_headers = rdkafka::message::OwnedHeaders::new();\n        for (key, value) in &message.metadata.headers {\n            if key != \"key\" && key != \"partition\" {\n                kafka_headers = kafka_headers.insert(rdkafka::message::Header {\n                    key,\n                    value: Some(value),\n                });\n            }\n        }\n        record = record.headers(kafka_headers);\n\n        // Send message with timeout\n        let timeout = Duration::from_secs(30);\n        producer.send(record, timeout).await.map_err(|(e, _)| {\n            AsyncApiError::new(\n                format!(\"Failed to send Kafka message: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        tracing::debug!(\"Sent Kafka message to topic: {}\", message.metadata.channel);\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let consumer = self.consumer.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"Kafka consumer not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        consumer.subscribe(&[channel]).map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to subscribe to Kafka topic {}: {}\", channel, e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        if !subscriptions.contains(&channel.to_string()) {\n            subscriptions.push(channel.to_string());\n        }\n\n        tracing::info!(\"Subscribed to Kafka topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let consumer = self.consumer.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"Kafka consumer not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        // Kafka doesn't have direct unsubscribe for individual topics\n        // We need to resubscribe to remaining topics\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.retain(|topic| topic != channel);\n\n        if subscriptions.is_empty() {\n            consumer.unsubscribe();\n        } else {\n            let topics: Vec<&str> = subscriptions.iter().map(|s| s.as_str()).collect();\n            consumer.subscribe(&topics).map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to resubscribe to Kafka topics: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n        }\n\n        tracing::info!(\"Unsubscribed from Kafka topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // Kafka listening is handled by the consumer loop, which is started in connect()\n        tracing::info!(\"Kafka transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        // For Kafka, we can check if producer and consumer are available\n        Ok(self.is_connected() && self.producer.is_some() && self.consumer.is_some())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for KafkaTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function AmqpTransport({ asyncapi }) {\n    // Check if AMQP protocol is used\n    const servers = asyncapi.servers();\n    let hasAmqp = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['amqp', 'amqps'].includes(protocol.toLowerCase())) {\n                hasAmqp = true;\n            }\n        });\n    }\n\n    // Only generate file if AMQP is used\n    if (!hasAmqp) {\n        return null;\n    }\n\n    return (\n        <File name=\"amqp.rs\">\n            {`//! AMQP transport implementation\n\nuse async_trait::async_trait;\nuse lapin::{\n    options::*, types::FieldTable, BasicProperties, Channel, Connection, ConnectionProperties,\n    Consumer, ExchangeKind,\n};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse tokio_stream::StreamExt;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// AMQP transport implementation\npub struct AmqpTransport {\n    config: TransportConfig,\n    connection: Option<Connection>,\n    channel: Option<Channel>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<HashMap<String, String>>>, // queue_name -> routing_key\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl AmqpTransport {\n    /// Create a new AMQP transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"amqp\" && config.protocol != \"amqps\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for AMQP transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            connection: None,\n            channel: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create AMQP connection URI\n    fn create_connection_uri(&self) -> String {\n        let scheme = if self.config.tls { \"amqps\" } else { \"amqp\" };\n        let auth = if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            format!(\"{}:{}@\", username, password)\n        } else {\n            String::new()\n        };\n\n        let vhost = self.config.additional_config\n            .get(\"vhost\")\n            .map(|v| format!(\"/{}\", v))\n            .unwrap_or_else(|| \"/\".to_string());\n\n        format!(\"{}://{}{}:{}{}\", scheme, auth, self.config.host, self.config.port, vhost)\n    }\n\n    /// Get exchange name from configuration\n    fn get_exchange_name(&self) -> String {\n        self.config.additional_config\n            .get(\"exchange\")\n            .cloned()\n            .unwrap_or_else(|| \"asyncapi\".to_string())\n    }\n\n    /// Get exchange type from configuration\n    fn get_exchange_type(&self) -> ExchangeKind {\n        match self.config.additional_config\n            .get(\"exchange_type\")\n            .map(|s| s.as_str())\n            .unwrap_or(\"topic\")\n        {\n            \"direct\" => ExchangeKind::Direct,\n            \"fanout\" => ExchangeKind::Fanout,\n            \"headers\" => ExchangeKind::Headers,\n            _ => ExchangeKind::Topic,\n        }\n    }\n\n    /// Start consuming messages from a queue\n    async fn start_consumer(&mut self, queue_name: &str) -> AsyncApiResult<()> {\n        let channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not available\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let consumer = channel\n            .basic_consume(\n                queue_name,\n                &format!(\"asyncapi-consumer-{}\", uuid::Uuid::new_v4()),\n                BasicConsumeOptions::default(),\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to create AMQP consumer: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let connection_state = Arc::clone(&self.connection_state);\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        tokio::spawn(async move {\n            let mut consumer_stream = consumer;\n\n            loop {\n                tokio::select! {\n                    delivery_result = consumer_stream.next() => {\n                        match delivery_result {\n                            Some(Ok(delivery)) => {\n                                let mut stats = stats.write().await;\n                                stats.messages_received += 1;\n                                stats.bytes_received += delivery.data.len() as u64;\n                                drop(stats);\n\n                                if let Some(handler) = &message_handler {\n                                    let mut headers = HashMap::new();\n\n                                    // Add AMQP-specific metadata\n                                    headers.insert(\"exchange\".to_string(), delivery.exchange.to_string());\n                                    headers.insert(\"routing_key\".to_string(), delivery.routing_key.to_string());\n                                    headers.insert(\"delivery_tag\".to_string(), delivery.delivery_tag.to_string());\n                                    headers.insert(\"redelivered\".to_string(), delivery.redelivered.to_string());\n\n                                    // Add message properties\n                                    if let Some(properties) = &delivery.properties {\n                                        if let Some(content_type) = &properties.content_type() {\n                                            headers.insert(\"content_type\".to_string(), content_type.to_string());\n                                        }\n                                        if let Some(content_encoding) = &properties.content_encoding() {\n                                            headers.insert(\"content_encoding\".to_string(), content_encoding.to_string());\n                                        }\n                                        if let Some(message_id) = &properties.message_id() {\n                                            headers.insert(\"message_id\".to_string(), message_id.to_string());\n                                        }\n                                        if let Some(correlation_id) = &properties.correlation_id() {\n                                            headers.insert(\"correlation_id\".to_string(), correlation_id.to_string());\n                                        }\n                                        if let Some(reply_to) = &properties.reply_to() {\n                                            headers.insert(\"reply_to\".to_string(), reply_to.to_string());\n                                        }\n                                        if let Some(user_id) = &properties.user_id() {\n                                            headers.insert(\"user_id\".to_string(), user_id.to_string());\n                                        }\n                                        if let Some(app_id) = &properties.app_id() {\n                                            headers.insert(\"app_id\".to_string(), app_id.to_string());\n                                        }\n\n                                        // Add custom headers\n                                        if let Some(amqp_headers) = properties.headers() {\n                                            for (key, value) in amqp_headers.iter() {\n                                                if let Ok(value_str) = std::str::from_utf8(&value.to_string().as_bytes()) {\n                                                    headers.insert(key.to_string(), value_str.to_string());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    let metadata = MessageMetadata {\n                                        channel: delivery.routing_key.to_string(),\n                                        operation: \"receive\".to_string(),\n                                        content_type: delivery.properties\n                                            .as_ref()\n                                            .and_then(|p| p.content_type())\n                                            .map(|ct| ct.to_string())\n                                            .or_else(|| Some(\"application/octet-stream\".to_string())),\n                                        headers,\n                                        timestamp: chrono::Utc::now(),\n                                    };\n\n                                    let transport_message = TransportMessage {\n                                        metadata,\n                                        payload: delivery.data.to_vec(),\n                                    };\n\n                                    if let Err(e) = handler.handle_message(transport_message).await {\n                                        tracing::error!(\"Failed to handle AMQP message: {}\", e);\n                                        let mut stats = stats.write().await;\n                                        stats.last_error = Some(e.to_string());\n                                    }\n\n                                    // Acknowledge the message\n                                    if let Err(e) = delivery.ack(BasicAckOptions::default()).await {\n                                        tracing::error!(\"Failed to acknowledge AMQP message: {}\", e);\n                                    }\n                                }\n                            }\n                            Some(Err(e)) => {\n                                tracing::error!(\"AMQP consumer error: {}\", e);\n                                let mut stats = stats.write().await;\n                                stats.last_error = Some(e.to_string());\n                            }\n                            None => {\n                                tracing::info!(\"AMQP consumer stream ended\");\n                                break;\n                            }\n                        }\n                    }\n                    _ = shutdown_rx.recv() => {\n                        tracing::info!(\"AMQP consumer shutdown requested\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for AmqpTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let connection_uri = self.create_connection_uri();\n        let connection_properties = ConnectionProperties::default();\n\n        let connection = Connection::connect(&connection_uri, connection_properties)\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to connect to AMQP broker: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let channel = connection.create_channel().await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create AMQP channel: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        // Declare exchange if configured\n        let exchange_name = self.get_exchange_name();\n        let exchange_type = self.get_exchange_type();\n\n        channel\n            .exchange_declare(\n                &exchange_name,\n                exchange_type,\n                ExchangeDeclareOptions {\n                    durable: true,\n                    ..Default::default()\n                },\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to declare AMQP exchange: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        self.connection = Some(connection);\n        self.channel = Some(channel);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"AMQP transport connected successfully\");\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        if let Some(channel) = &self.channel {\n            if let Err(e) = channel.close(200, \"Normal shutdown\").await {\n                tracing::warn!(\"Error closing AMQP channel: {}\", e);\n            }\n        }\n\n        if let Some(connection) = &self.connection {\n            if let Err(e) = connection.close(200, \"Normal shutdown\").await {\n                tracing::warn!(\"Error closing AMQP connection: {}\", e);\n            }\n        }\n\n        self.channel = None;\n        self.connection = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"AMQP transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n            && self.connection.as_ref().map_or(false, |c| c.status().connected())\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        let channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let exchange_name = self.get_exchange_name();\n        let routing_key = &message.metadata.channel;\n\n        // Create basic properties\n        let mut properties = BasicProperties::default();\n\n        if let Some(content_type) = &message.metadata.content_type {\n            properties = properties.with_content_type(content_type.clone().into());\n        }\n\n        // Set properties from headers\n        if let Some(message_id) = message.metadata.headers.get(\"message_id\") {\n            properties = properties.with_message_id(message_id.clone().into());\n        }\n        if let Some(correlation_id) = message.metadata.headers.get(\"correlation_id\") {\n            properties = properties.with_correlation_id(correlation_id.clone().into());\n        }\n        if let Some(reply_to) = message.metadata.headers.get(\"reply_to\") {\n            properties = properties.with_reply_to(reply_to.clone().into());\n        }\n\n        // Add custom headers\n        let mut field_table = FieldTable::default();\n        for (key, value) in &message.metadata.headers {\n            if ![\"message_id\", \"correlation_id\", \"reply_to\", \"content_type\"].contains(&key.as_str()) {\n                field_table.insert(key.clone().into(), value.clone().into());\n            }\n        }\n        if !field_table.is_empty() {\n            properties = properties.with_headers(field_table);\n        }\n\n        channel\n            .basic_publish(\n                &exchange_name,\n                routing_key,\n                BasicPublishOptions::default(),\n                &message.payload,\n                properties,\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to publish AMQP message: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        tracing::debug!(\"Published AMQP message to routing key: {}\", routing_key);\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let amqp_channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let exchange_name = self.get_exchange_name();\n        let queue_name = format!(\"asyncapi-queue-{}\", uuid::Uuid::new_v4());\n\n        // Declare queue\n        let queue = amqp_channel\n            .queue_declare(\n                &queue_name,\n                QueueDeclareOptions {\n                    auto_delete: true,\n                    ..Default::default()\n                },\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to declare AMQP queue: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        // Bind queue to exchange\n        amqp_channel\n            .queue_bind(\n                &queue_name,\n                &exchange_name,\n                channel,\n                QueueBindOptions::default(),\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to bind AMQP queue: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        // Start consuming\n        self.start_consumer(&queue_name).await?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.insert(queue_name, channel.to_string());\n\n        tracing::info!(\"Subscribed to AMQP routing key: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let amqp_channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        let queue_to_remove = subscriptions\n            .iter()\n            .find(|(_, routing_key)| routing_key.as_str() == channel)\n            .map(|(queue_name, _)| queue_name.clone());\n\n        if let Some(queue_name) = queue_to_remove {\n            // Delete the queue\n            amqp_channel\n                .queue_delete(&queue_name, QueueDeleteOptions::default())\n                .await\n                .map_err(|e| {\n                    AsyncApiError::new(\n                        format!(\"Failed to delete AMQP queue: {}\", e),\n                        ErrorCategory::Network,\n                        Some(Box::new(e)),\n                    )\n                })?;\n\n            subscriptions.remove(&queue_name);\n        }\n\n        tracing::info!(\"Unsubscribed from AMQP routing key: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // AMQP listening is handled by the consumer, which is started in subscribe()\n        tracing::info!(\"AMQP transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for AmqpTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function WebSocketTransport({ asyncapi, params }) {\n    // Check if WebSocket protocol is used\n    const servers = asyncapi.servers();\n    let hasWebSocket = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['ws', 'wss', 'websocket'].includes(protocol.toLowerCase())) {\n                hasWebSocket = true;\n            }\n        });\n    }\n\n    // Only generate file if WebSocket is used\n    if (!hasWebSocket) {\n        return null;\n    }\n\n    const useAsyncStd = params.useAsyncStd === 'true' || params.useAsyncStd === true;\n\n    return (\n        <File name=\"websocket.rs\">\n            {`//! WebSocket transport implementation\n\nuse async_trait::async_trait;\n${useAsyncStd ? `\nuse async_tungstenite::{\n    async_std::connect_async, async_std::connect_async_with_config,\n    tungstenite::{Message, protocol::WebSocketConfig},\n    WebSocketStream,\n};\nuse async_std::net::TcpStream;\n` : `\nuse tokio_tungstenite::{\n    connect_async, connect_async_with_config,\n    tungstenite::{Message, protocol::WebSocketConfig},\n    WebSocketStream, MaybeTlsStream,\n};\nuse tokio::net::TcpStream;\n`}\nuse futures_util::{SinkExt, StreamExt};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse url::Url;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n${useAsyncStd ? `\ntype WsStream = WebSocketStream<TcpStream>;\n` : `\ntype WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;\n`}\n\n/// WebSocket transport implementation\npub struct WebSocketTransport {\n    config: TransportConfig,\n    ws_stream: Option<WsStream>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<Vec<String>>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl WebSocketTransport {\n    /// Create a new WebSocket transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if ![\"ws\", \"wss\", \"websocket\"].contains(&config.protocol.as_str()) {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for WebSocket transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            ws_stream: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(Vec::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create WebSocket URL from configuration\n    fn create_websocket_url(&self) -> AsyncApiResult<Url> {\n        let scheme = match self.config.protocol.as_str() {\n            \"wss\" => \"wss\",\n            \"ws\" | \"websocket\" => if self.config.tls { \"wss\" } else { \"ws\" },\n            _ => \"ws\",\n        };\n\n        let path = self.config.additional_config\n            .get(\"path\")\n            .map(|p| p.as_str())\n            .unwrap_or(\"/\");\n\n        let url_str = format!(\"{}://{}:{}{}\", scheme, self.config.host, self.config.port, path);\n\n        Url::parse(&url_str).map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Invalid WebSocket URL: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })\n    }\n\n    /// Create WebSocket configuration\n    fn create_ws_config(&self) -> WebSocketConfig {\n        let mut config = WebSocketConfig::default();\n\n        // Set max message size if specified\n        if let Some(max_message_size) = self.config.additional_config\n            .get(\"max_message_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            config.max_message_size = Some(max_message_size);\n        }\n\n        // Set max frame size if specified\n        if let Some(max_frame_size) = self.config.additional_config\n            .get(\"max_frame_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            config.max_frame_size = Some(max_frame_size);\n        }\n\n        config\n    }\n\n    /// Start the WebSocket message loop\n    async fn start_message_loop(&mut self) -> AsyncApiResult<()> {\n        if let Some(ws_stream) = self.ws_stream.take() {\n            let (mut ws_sender, mut ws_receiver) = ws_stream.split();\n            let connection_state = Arc::clone(&self.connection_state);\n            let stats = Arc::clone(&self.stats);\n            let message_handler = self.message_handler.clone();\n            let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n            self.shutdown_tx = Some(shutdown_tx);\n\n            // Store the sender for sending messages\n            let (msg_tx, mut msg_rx) = mpsc::channel::<Message>(100);\n\n            // Spawn sender task\n            let sender_stats = Arc::clone(&stats);\n            tokio::spawn(async move {\n                loop {\n                    tokio::select! {\n                        message = msg_rx.recv() => {\n                            match message {\n                                Some(msg) => {\n                                    if let Err(e) = ws_sender.send(msg).await {\n                                        tracing::error!(\"Failed to send WebSocket message: {}\", e);\n                                        let mut stats = sender_stats.write().await;\n                                        stats.last_error = Some(e.to_string());\n                                        break;\n                                    }\n                                }\n                                None => break,\n                            }\n                        }\n                        _ = shutdown_rx.recv() => {\n                            tracing::info!(\"WebSocket sender shutdown requested\");\n                            break;\n                        }\n                    }\n                }\n            });\n\n            // Spawn receiver task\n            tokio::spawn(async move {\n                loop {\n                    match ws_receiver.next().await {\n                        Some(Ok(message)) => {\n                            match message {\n                                Message::Text(text) => {\n                                    let mut stats = stats.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += text.len() as u64;\n                                    drop(stats);\n\n                                    if let Some(handler) = &message_handler {\n                                        let metadata = MessageMetadata {\n                                            channel: \"websocket\".to_string(),\n                                            operation: \"receive\".to_string(),\n                                            content_type: Some(\"text/plain\".to_string()),\n                                            headers: HashMap::new(),\n                                            timestamp: chrono::Utc::now(),\n                                        };\n\n                                        let transport_message = TransportMessage {\n                                            metadata,\n                                            payload: text.into_bytes(),\n                                        };\n\n                                        if let Err(e) = handler.handle_message(transport_message).await {\n                                            tracing::error!(\"Failed to handle WebSocket text message: {}\", e);\n                                            let mut stats = stats.write().await;\n                                            stats.last_error = Some(e.to_string());\n                                        }\n                                    }\n                                }\n                                Message::Binary(data) => {\n                                    let mut stats = stats.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += data.len() as u64;\n                                    drop(stats);\n\n                                    if let Some(handler) = &message_handler {\n                                        let metadata = MessageMetadata {\n                                            channel: \"websocket\".to_string(),\n                                            operation: \"receive\".to_string(),\n                                            content_type: Some(\"application/octet-stream\".to_string()),\n                                            headers: HashMap::new(),\n                                            timestamp: chrono::Utc::now(),\n                                        };\n\n                                        let transport_message = TransportMessage {\n                                            metadata,\n                                            payload: data,\n                                        };\n\n                                        if let Err(e) = handler.handle_message(transport_message).await {\n                                            tracing::error!(\"Failed to handle WebSocket binary message: {}\", e);\n                                            let mut stats = stats.write().await;\n                                            stats.last_error = Some(e.to_string());\n                                        }\n                                    }\n                                }\n                                Message::Ping(data) => {\n                                    tracing::debug!(\"Received WebSocket ping\");\n                                    // Pong is automatically sent by tungstenite\n                                }\n                                Message::Pong(_) => {\n                                    tracing::debug!(\"Received WebSocket pong\");\n                                }\n                                Message::Close(_) => {\n                                    tracing::info!(\"WebSocket connection closed by peer\");\n                                    *connection_state.write().await = ConnectionState::Disconnected;\n                                    break;\n                                }\n                                Message::Frame(_) => {\n                                    // Raw frames are handled internally\n                                }\n                            }\n                        }\n                        Some(Err(e)) => {\n                            tracing::error!(\"WebSocket receiver error: {}\", e);\n                            *connection_state.write().await = ConnectionState::Failed;\n                            let mut stats = stats.write().await;\n                            stats.last_error = Some(e.to_string());\n                            break;\n                        }\n                        None => {\n                            tracing::info!(\"WebSocket receiver stream ended\");\n                            *connection_state.write().await = ConnectionState::Disconnected;\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for WebSocketTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let url = self.create_websocket_url()?;\n        let ws_config = self.create_ws_config();\n\n        // Create connection request with optional headers\n        let mut request = url.clone().into_client_request().map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create WebSocket request: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        // Add authentication headers if provided\n        if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            let auth_value = base64::encode(format!(\"{}:{}\", username, password));\n            request.headers_mut().insert(\n                \"Authorization\",\n                format!(\"Basic {}\", auth_value).parse().unwrap(),\n            );\n        }\n\n        // Add custom headers\n        for (key, value) in &self.config.additional_config {\n            if key.starts_with(\"header_\") {\n                let header_name = &key[7..]; // Remove \"header_\" prefix\n                if let Ok(header_value) = value.parse() {\n                    request.headers_mut().insert(header_name, header_value);\n                }\n            }\n        }\n\n        // Connect to WebSocket\n        let (ws_stream, _) = if ws_config == WebSocketConfig::default() {\n            connect_async(request).await\n        } else {\n            connect_async_with_config(request, Some(ws_config)).await\n        }.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to connect to WebSocket: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        self.ws_stream = Some(ws_stream);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        // Start message loop\n        self.start_message_loop().await?;\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"WebSocket transport connected successfully to {}\", url);\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        self.ws_stream = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"WebSocket transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        if !self.is_connected() {\n            return Err(AsyncApiError::new(\n                \"WebSocket not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            ));\n        }\n\n        // Determine message type based on content type\n        let ws_message = match message.metadata.content_type.as_deref() {\n            Some(\"text/plain\") | Some(\"application/json\") | Some(\"text/json\") => {\n                let text = String::from_utf8(message.payload).map_err(|e| {\n                    AsyncApiError::new(\n                        format!(\"Invalid UTF-8 in text message: {}\", e),\n                        ErrorCategory::Validation,\n                        Some(Box::new(e)),\n                    )\n                })?;\n                Message::Text(text)\n            }\n            _ => Message::Binary(message.payload.clone()),\n        };\n\n        // For this implementation, we would need to store the sender channel\n        // This is a simplified version - in practice, you'd want to store the sender\n        // from the message loop and use it here\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        tracing::debug!(\"Sent WebSocket message\");\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        // WebSocket doesn't have traditional subscription model\n        // This could be used to track which channels we're interested in\n        let mut subscriptions = self.subscriptions.write().await;\n        if !subscriptions.contains(&channel.to_string()) {\n            subscriptions.push(channel.to_string());\n        }\n\n        tracing::info!(\"Subscribed to WebSocket channel: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.retain(|c| c != channel);\n\n        tracing::info!(\"Unsubscribed from WebSocket channel: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // WebSocket listening is handled by the message loop, which is started in connect()\n        tracing::info!(\"WebSocket transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for WebSocketTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n","export default function HttpTransport({ asyncapi, params }) {\n    // Check if HTTP protocol is used\n    const servers = asyncapi.servers();\n    let hasHttp = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['http', 'https'].includes(protocol.toLowerCase())) {\n                hasHttp = true;\n            }\n        });\n    }\n\n    // Only generate file if HTTP is used\n    if (!hasHttp) {\n        return null;\n    }\n\n    const useAsyncStd = params.useAsyncStd === 'true' || params.useAsyncStd === true;\n\n    return (\n        <File name=\"http.rs\">\n            {`//! HTTP transport implementation\n\nuse async_trait::async_trait;\n${useAsyncStd ? `\nuse tide::{Request, Response, Server as TideServer, StatusCode};\nuse async_std::task;\n` : `\nuse axum::{\n    extract::{Path, Query, State},\n    http::{HeaderMap, StatusCode, Method},\n    response::{Json, Response as AxumResponse},\n    routing::{get, post, put, delete},\n    Router,\n};\nuse tower::ServiceBuilder;\nuse tokio::net::TcpListener;\n`}\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse serde_json::Value;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// HTTP transport implementation\npub struct HttpTransport {\n    config: TransportConfig,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    routes: Arc<RwLock<HashMap<String, String>>>, // path -> method\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n    ${useAsyncStd ? 'server: Option<TideServer<()>>,' : 'server_handle: Option<tokio::task::JoinHandle<()>>,'}\n}\n\nimpl HttpTransport {\n    /// Create a new HTTP transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"http\" && config.protocol != \"https\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for HTTP transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            routes: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n            ${useAsyncStd ? 'server: None,' : 'server_handle: None,'}\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Get server address\n    fn get_server_address(&self) -> String {\n        format!(\"{}:{}\", self.config.host, self.config.port)\n    }\n\n    ${useAsyncStd ? `\n    /// Create Tide server\n    async fn create_tide_server(&self) -> AsyncApiResult<TideServer<()>> {\n        let mut app = tide::new();\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n\n        // Add middleware for logging and stats\n        app.with(tide::log::LogMiddleware::new());\n\n        // Generic handler for all routes\n        let handler = move |mut req: Request<()>| {\n            let stats = Arc::clone(&stats);\n            let message_handler = message_handler.clone();\n\n            async move {\n                let mut stats = stats.write().await;\n                stats.messages_received += 1;\n                drop(stats);\n\n                let method = req.method().to_string();\n                let path = req.url().path().to_string();\n                let query = req.url().query().unwrap_or(\"\").to_string();\n\n                // Extract headers\n                let mut headers = HashMap::new();\n                for (name, value) in req.iter() {\n                    if let Ok(value_str) = value.to_str() {\n                        headers.insert(name.to_string(), value_str.to_string());\n                    }\n                }\n\n                // Read body\n                let body = match req.body_bytes().await {\n                    Ok(bytes) => bytes,\n                    Err(e) => {\n                        tracing::error!(\"Failed to read request body: {}\", e);\n                        return Response::builder(StatusCode::BadRequest)\n                            .body(\"Failed to read request body\")\n                            .build();\n                    }\n                };\n\n                let mut stats = stats.write().await;\n                stats.bytes_received += body.len() as u64;\n                drop(stats);\n\n                if let Some(handler) = &message_handler {\n                    let metadata = MessageMetadata {\n                        channel: path.clone(),\n                        operation: method.clone(),\n                        content_type: headers.get(\"content-type\").cloned(),\n                        headers: headers.clone(),\n                        timestamp: chrono::Utc::now(),\n                    };\n\n                    let transport_message = TransportMessage {\n                        metadata,\n                        payload: body,\n                    };\n\n                    match handler.handle_message(transport_message).await {\n                        Ok(_) => {\n                            Response::builder(StatusCode::Ok)\n                                .body(\"Message processed successfully\")\n                                .build()\n                        }\n                        Err(e) => {\n                            tracing::error!(\"Failed to handle HTTP message: {}\", e);\n                            let mut stats = stats.write().await;\n                            stats.last_error = Some(e.to_string());\n                            Response::builder(StatusCode::InternalServerError)\n                                .body(\"Failed to process message\")\n                                .build()\n                        }\n                    }\n                } else {\n                    Response::builder(StatusCode::Ok)\n                        .body(\"No handler configured\")\n                        .build()\n                }\n            }\n        };\n\n        // Add routes for common HTTP methods\n        app.at(\"/*\").get(handler.clone());\n        app.at(\"/*\").post(handler.clone());\n        app.at(\"/*\").put(handler.clone());\n        app.at(\"/*\").delete(handler.clone());\n        app.at(\"/*\").patch(handler);\n\n        Ok(app)\n    }\n    ` : `\n    /// Create Axum router\n    async fn create_axum_router(&self) -> AsyncApiResult<Router> {\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n\n        // Create shared state\n        let app_state = AppState {\n            stats,\n            message_handler,\n        };\n\n        let router = Router::new()\n            .route(\"/*path\", get(handle_request))\n            .route(\"/*path\", post(handle_request))\n            .route(\"/*path\", put(handle_request))\n            .route(\"/*path\", delete(handle_request))\n            .route(\"/\", get(handle_request))\n            .route(\"/\", post(handle_request))\n            .route(\"/\", put(handle_request))\n            .route(\"/\", delete(handle_request))\n            .with_state(app_state)\n            .layer(\n                ServiceBuilder::new()\n                    .layer(axum::middleware::from_fn(logging_middleware))\n            );\n\n        Ok(router)\n    }\n    `}\n}\n\n${useAsyncStd ? '' : `\n#[derive(Clone)]\nstruct AppState {\n    stats: Arc<RwLock<TransportStats>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n}\n\nasync fn handle_request(\n    State(state): State<AppState>,\n    method: Method,\n    Path(path): Path<String>,\n    Query(query): Query<HashMap<String, String>>,\n    headers: HeaderMap,\n    body: axum::body::Bytes,\n) -> Result<AxumResponse<String>, StatusCode> {\n    let mut stats = state.stats.write().await;\n    stats.messages_received += 1;\n    stats.bytes_received += body.len() as u64;\n    drop(stats);\n\n    // Extract headers\n    let mut header_map = HashMap::new();\n    for (name, value) in headers.iter() {\n        if let Ok(value_str) = value.to_str() {\n            header_map.insert(name.to_string(), value_str.to_string());\n        }\n    }\n\n    // Add query parameters to headers\n    for (key, value) in query {\n        header_map.insert(format!(\"query_{}\", key), value);\n    }\n\n    if let Some(handler) = &state.message_handler {\n        let metadata = MessageMetadata {\n            channel: format!(\"/{}\", path),\n            operation: method.to_string(),\n            content_type: header_map.get(\"content-type\").cloned(),\n            headers: header_map,\n            timestamp: chrono::Utc::now(),\n        };\n\n        let transport_message = TransportMessage {\n            metadata,\n            payload: body.to_vec(),\n        };\n\n        match handler.handle_message(transport_message).await {\n            Ok(_) => Ok(AxumResponse::new(\"Message processed successfully\".to_string())),\n            Err(e) => {\n                tracing::error!(\"Failed to handle HTTP message: {}\", e);\n                let mut stats = state.stats.write().await;\n                stats.last_error = Some(e.to_string());\n                Err(StatusCode::INTERNAL_SERVER_ERROR)\n            }\n        }\n    } else {\n        Ok(AxumResponse::new(\"No handler configured\".to_string()))\n    }\n}\n\nasync fn logging_middleware(\n    request: axum::http::Request<axum::body::Body>,\n    next: axum::middleware::Next,\n) -> axum::response::Response {\n    let method = request.method().clone();\n    let uri = request.uri().clone();\n\n    tracing::info!(\"HTTP {} {}\", method, uri);\n\n    let response = next.run(request).await;\n\n    tracing::info!(\"HTTP {} {} -> {}\", method, uri, response.status());\n\n    response\n}\n`}\n\n#[async_trait]\nimpl Transport for HttpTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let address = self.get_server_address();\n\n        ${useAsyncStd ? `\n        let server = self.create_tide_server().await?;\n        self.server = Some(server);\n\n        let server_clone = self.server.as_ref().unwrap().clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        // Start server in background task\n        task::spawn(async move {\n            tokio::select! {\n                result = server_clone.listen(&address) => {\n                    if let Err(e) = result {\n                        tracing::error!(\"HTTP server error: {}\", e);\n                    }\n                }\n                _ = shutdown_rx.recv() => {\n                    tracing::info!(\"HTTP server shutdown requested\");\n                }\n            }\n        });\n        ` : `\n        let router = self.create_axum_router().await?;\n        let listener = TcpListener::bind(&address).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to bind HTTP server to {}: {}\", address, e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        // Start server in background task\n        let server_handle = tokio::spawn(async move {\n            tokio::select! {\n                result = axum::serve(listener, router) => {\n                    if let Err(e) = result {\n                        tracing::error!(\"HTTP server error: {}\", e);\n                    }\n                }\n                _ = shutdown_rx.recv() => {\n                    tracing::info!(\"HTTP server shutdown requested\");\n                }\n            }\n        });\n\n        self.server_handle = Some(server_handle);\n        `}\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"HTTP transport started on {}\", address);\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        ${useAsyncStd ? `\n        self.server = None;\n        ` : `\n        if let Some(handle) = self.server_handle.take() {\n            handle.abort();\n        }\n        `}\n\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n        tracing::info!(\"HTTP transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        // HTTP transport is primarily for receiving messages (server mode)\n        // Sending would require making HTTP client requests\n        tracing::warn!(\"HTTP transport send_message not implemented - use HTTP client for outbound requests\");\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        // HTTP doesn't have traditional subscription model\n        // This could be used to register specific routes\n        let mut routes = self.routes.write().await;\n        routes.insert(channel.to_string(), \"GET\".to_string());\n\n        tracing::info!(\"Registered HTTP route: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let mut routes = self.routes.write().await;\n        routes.remove(channel);\n\n        tracing::info!(\"Unregistered HTTP route: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // HTTP listening is handled by the server, which is started in connect()\n        tracing::info!(\"HTTP transport is listening for requests\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for HttpTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n","/* eslint-disable no-unused-vars */\nimport { File } from '@asyncapi/generator-react-sdk';\n\n// Import all template components\nimport CargoToml from './Cargo.toml.js';\nimport ReadmeMd from './README.md.js';\nimport MainRs from './src/main.rs.js';\nimport ConfigRs from './src/config.rs.js';\nimport ErrorsRs from './src/errors.rs.js';\nimport ModelsRs from './src/models.rs.js';\nimport HandlersRs from './src/handlers.rs.js';\nimport ContextRs from './src/context.rs.js';\nimport RouterRs from './src/router.rs.js';\n// Import server module components\nimport ServerMod from './src/server/mod.rs.js';\nimport ServerBuilder from './src/server/builder.rs.js';\nimport MiddlewareRs from './src/middleware.rs.js';\nimport RecoveryRs from './src/recovery.rs.js';\n\n// Import auth module components\nimport AuthMod from './src/auth/mod.rs.js';\nimport AuthConfig from './src/auth/config.rs.js';\nimport AuthJwt from './src/auth/jwt.rs.js';\nimport AuthMiddleware from './src/auth/middleware.rs.js';\nimport AuthRbac from './src/auth/rbac.rs.js';\n\n// Import transport components\nimport TransportMod from './src/transport/mod.rs.js';\nimport TransportFactory from './src/transport/factory.rs.js';\nimport MqttTransport from './src/transport/mqtt.rs.js';\nimport KafkaTransport from './src/transport/kafka.rs.js';\nimport AmqpTransport from './src/transport/amqp.rs.js';\nimport WebSocketTransport from './src/transport/websocket.rs.js';\nimport HttpTransport from './src/transport/http.rs.js';\n\nexport default function ({ asyncapi, params }) {\n    return [\n        <CargoToml asyncapi={asyncapi} params={params} />,\n        <ReadmeMd asyncapi={asyncapi} params={params} />,\n        <MainRs asyncapi={asyncapi} params={params} />,\n        <ConfigRs asyncapi={asyncapi} params={params} />,\n        <ErrorsRs asyncapi={asyncapi} params={params} />,\n        <ModelsRs asyncapi={asyncapi} params={params} />,\n        <HandlersRs asyncapi={asyncapi} params={params} />,\n        <ContextRs asyncapi={asyncapi} params={params} />,\n        <RouterRs asyncapi={asyncapi} params={params} />,\n        <ServerMod asyncapi={asyncapi} params={params} />,\n        <ServerBuilder asyncapi={asyncapi} params={params} />,\n        <MiddlewareRs asyncapi={asyncapi} params={params} />,\n        <RecoveryRs asyncapi={asyncapi} params={params} />,\n        <AuthMod asyncapi={asyncapi} params={params} />,\n        <AuthConfig asyncapi={asyncapi} params={params} />,\n        <AuthJwt asyncapi={asyncapi} params={params} />,\n        <AuthMiddleware asyncapi={asyncapi} params={params} />,\n        <AuthRbac asyncapi={asyncapi} params={params} />,\n        <TransportMod asyncapi={asyncapi} params={params} />,\n        <TransportFactory asyncapi={asyncapi} params={params} />,\n        <MqttTransport asyncapi={asyncapi} params={params} />,\n        <KafkaTransport asyncapi={asyncapi} params={params} />,\n        <AmqpTransport asyncapi={asyncapi} params={params} />,\n        <WebSocketTransport asyncapi={asyncapi} params={params} />,\n        <HttpTransport asyncapi={asyncapi} params={params} />\n    ];\n}\n"],"names":["MainRs","asyncapi","_params","info","title","servers","protocols","Set","Object","entries","forEach","_name","server","protocol","add","toLowerCase","_jsx","File","name","children","ConfigRs","toRustIdentifier","str","identifier","replace","test","rustKeywords","includes","toRustTypeName","split","map","part","charAt","toUpperCase","slice","join","toRustFieldName","getDefaultPort","serverConfigs","push","fieldName","typeName","host","description","defaultPort","ErrorsRs","Array","from","protocolTitle","ModelsRs","components","messageSchemas","messageTypes","messages","message","payload","payloadSchema","json","e","rustName","jsonSchemaToRustType","schema","type","format","itemType","items","generateMessageStruct","properties","fields","fieldSchema","rustType","optional","required","finalType","rustFieldName","size","HandlersRs","channels","channelData","channelName","channel","operations","channelOps","opName","operation","action","address","op","ContextRs","RouterRs","ServerModRs","ServerBuilderRs","MiddlewareRs","RecoveryRs","AuthModRs","AuthConfigRs","AuthJwtRs","AuthMiddlewareRs","AuthRbacRs","TransportMod","moduleDeclarations","has","TransportFactory","_","imports","MqttTransport","hasMqtt","KafkaTransport","hasKafka","AmqpTransport","hasAmqp","WebSocketTransport","params","hasWebSocket","useAsyncStd","HttpTransport","hasHttp","CargoToml","ReadmeMd","ServerMod","ServerBuilder","AuthMod","AuthConfig","AuthJwt","AuthMiddleware","AuthRbac"],"mappings":"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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE2B,KAAK,CAACC,IAAI,CAACzC,SAAS,CAAC,CAACwB,GAAG,CAACjB,QAAQ,IAAI;AAC5B,MAAA,MAAMmC,aAAa,GAAGnC,QAAQ,CAACmB,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGpB,QAAQ,CAACqB,KAAK,CAAC,CAAC,CAAC,CAAA;MAE1E,OAAO,CAAA;AACnB,IAAA,EAAMc,aAAa,CAAA;AACnB;AACA,SAAA,EAAWA,aAAa,CAAA;AACxB,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMnC,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAMA,EAAAA,QAAQ,KAAK,OAAO,GAAG,CAAA;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAMA,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAA,EAAOA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,GAAI,CAAA;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAA,EAAOA,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,GAAI,CAAA;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA;AACA,KAAA,EAAOmC,aAAa,CAAA;AACpB;AACA;AACA;AACA,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcnC,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AACpC,YAAA,EAAcmC,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA8C,4CAAA,CAAA,GAAG,EAAE,CAAA;AAC9E,YAAcnC,EAAAA,QAAQ,KAAK,OAAO,GAAG,CAAA;AACrC,YAAA,EAAcmC,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA6C,2CAAA,CAAA,GAAG,EAAE,CAAA;AAC7E,YAAcnC,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AACpC,YAAA,EAAcmC,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA4C,0CAAA,CAAA,GAAG,EAAE,CAAA;AAC5E,YAAA,EAAenC,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,GAAI,CAAA;AAC1D,YAAA,EAAcmC,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA+C,6CAAA,CAAA,GAAG,EAAE,CAAA;AAC/E,YAAA,EAAenC,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,GAAI,CAAA;AAC9D,YAAA,EAAcmC,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA8C,4CAAA,CAAA,GAAG,EAAE,CAAA;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAA,EAAYA,aAAa,CAAA;AACzB,mBAAA,EAAqBA,aAAa,CAAA;AAClC;AACA;AACA,uBAAA,EAAyBnC,QAAQ,CAAA;AACjC;AACA;AACA;AACA;AACA,CAAE,CAAA,CAAA;AACM,KAAC,CAAC,CAACsB,IAAI,CAAC,IAAI,CAAC,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE2D,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA;AAC7B,gBAAkBA,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AAC9B;AACA,WAAa8D,EAAAA,OAAO,CAACrB,QAAQ,CAAA;AAC7B;AACA;AACA;AACA,KAAOqB,EAAAA,OAAO,CAACrB,QAAQ,CAAA;AACvB;AACA;AACA;AACA;AACA,EAAEqB,OAAO,CAACC,UAAU,CAACnD,GAAG,CAACyD,EAAE,IAAI,CAAA;AAC/B,eAAA,EAAiBA,EAAE,CAACF,MAAM,CAAkBL,eAAAA,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AACxD;AACA,mBAAqB8D,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AACjC,qBAAuBqE,EAAAA,EAAE,CAACrE,IAAI,CAAA;AAC9B;AACA;AACA,wBAA0BqE,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA6B4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAAgD4B,EAAAA,EAAE,CAACF,MAAM,CAAA;AACzD,qBAAuBE,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAqCqB,EAAAA,OAAO,CAACrB,QAAQ,CAAA;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAiB4B,EAAAA,EAAE,CAACF,MAAM,CAAA;AAC1B,wBAA0BE,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAA2EqB,EAAAA,OAAO,CAACrB,QAAQ,CAAA;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAkC4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AAC7C;AACA;AACA,4BAA8B4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAkD4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AAC7D;AACA;AACA,4CAA8C4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACzD;AACA;AACA;AACA,oCAAsC4B,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACjD;AACA;AACA;AACA;AACA;AACA,KAAA,CAAM,CAAC,CAACxB,IAAI,CAAC,IAAI,CAAC,CAAA;AAClB,CAAA,CAAE,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC,CAAA;AACd;AACA;AACA;AACA;AACA,IAAM2C,EAAAA,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA,IAAA,EAAOA,OAAO,CAACxC,SAAS,KAAKwC,OAAO,CAACrB,QAAQ,CAAG,CAAA,CAAA,CAAC,CAACxB,IAAI,CAAC,QAAQ,CAAC,CAAA;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAc2C,EAAAA,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA,EAAGA,OAAO,CAACxC,SAAS,KAAKwC,OAAO,CAACrB,QAAQ,CAAkC,gCAAA,CAAA,CAAC,CAACxB,IAAI,CAAC,gBAAgB,CAAC,CAAA;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA,YAAc2C,EAAAA,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA,EAAGA,OAAO,CAACxC,SAAS,KAAKwC,OAAO,CAACrB,QAAQ,CAAkC,gCAAA,CAAA,CAAC,CAACxB,IAAI,CAAC,gBAAgB,CAAC,CAAA;AAC5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAc2C,EAAAA,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA,CAAA,EAAIA,OAAO,CAAC9D,IAAI,CAAA;AACzD;AACA,oBAAsB8D,EAAAA,OAAO,CAACC,UAAU,CAACnD,GAAG,CAACyD,EAAE,IAAI,CAAA,CAAA,EAAIA,EAAE,CAACrE,IAAI,CAAA;AAC9D,6BAAA,EAA+B8D,OAAO,CAACxC,SAAS,CAAW+C,QAAAA,EAAAA,EAAE,CAAC5B,QAAQ,CAAA;AACtE,sBAAA,CAAuB,CAAC,CAACxB,IAAI,CAAC,wBAAwB,CAAC,CAAA;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAA,CAAe,CAAC,CAACA,IAAI,CAAC,gBAAgB,CAAC,CAAA;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACnfe,SAASqD,SAASA,GAAG;EAChC,oBACIxE,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,YAAY;AAAAC,IAAAA,QAAA,EAClB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACnsBA;AACe,SAASsE,QAAQA,CAAC;AAAExF,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAC3C;AACA,EAAA,MAAM4E,QAAQ,GAAG5E,QAAQ,CAAC4E,QAAQ,EAAE,CAAA;EACpC,MAAMC,WAAW,GAAG,EAAE,CAAA;AAEtB,EAAA,IAAID,QAAQ,EAAE;AACVrE,IAAAA,MAAM,CAACC,OAAO,CAACoE,QAAQ,CAAC,CAACnE,OAAO,CAAC,CAAC,CAACqE,WAAW,EAAEC,OAAO,CAAC,KAAK;MACzD,MAAMC,UAAU,GAAGD,OAAO,CAACC,UAAU,IAAID,OAAO,CAACC,UAAU,EAAE,CAAA;MAC7D,MAAMC,UAAU,GAAG,EAAE,CAAA;AAErB,MAAA,IAAID,UAAU,EAAE;AACZzE,QAAAA,MAAM,CAACC,OAAO,CAACwE,UAAU,CAAC,CAACvE,OAAO,CAAC,CAAC,CAACyE,MAAM,EAAEC,SAAS,CAAC,KAAK;UACxD,MAAMC,MAAM,GAAGD,SAAS,CAACC,MAAM,IAAID,SAAS,CAACC,MAAM,EAAE,CAAA;UACrDH,UAAU,CAAC3C,IAAI,CAAC;AACZrB,YAAAA,IAAI,EAAEiE,MAAM;YACZE,MAAM;AACNL,YAAAA,OAAO,EAAED,WAAAA;AACb,WAAC,CAAC,CAAA;AACN,SAAC,CAAC,CAAA;AACN,OAAA;MAEAD,WAAW,CAACvC,IAAI,CAAC;AACbrB,QAAAA,IAAI,EAAE6D,WAAW;AACjBE,QAAAA,UAAU,EAAEC,UAAAA;AAChB,OAAC,CAAC,CAAA;AACN,KAAC,CAAC,CAAA;AACN,GAAA;EAEA,oBACIlE,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,WAAW;AAAAC,IAAAA,QAAA,EACjB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAU2D,WAAW,CAAChD,GAAG,CAACkD,OAAO,IAAI,CAAA;AACrC,sBAAwBA,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AACpC,QAAA,EAAU8D,OAAO,CAACC,UAAU,CAACnD,GAAG,CAACyD,EAAE,IAAI,CAAA;AACvC;AACA,sBAAwBP,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AACpC,wBAA0BqE,EAAAA,EAAE,CAACrE,IAAI,CAAA;AACjC;AACA;AACA,0BAA4B8D,EAAAA,OAAO,CAAC9D,IAAI,CAAA;AACxC,4BAA8BqE,EAAAA,EAAE,CAACrE,IAAI,CAAA;AACrC;AACA;AACA;AACA;AACA,kBAAA,CAAmB,CAAC,CAACiB,IAAI,CAAC,YAAY,CAAC,CAAA;AACvC,QAAA,CAAS,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACx2Be,SAASuD,WAAWA,GAAG;EAClC,oBACI1E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC/Se,SAASwE,eAAeA,GAAG;EACtC,oBACI3E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,YAAY;AAAAC,IAAAA,QAAA,EAClB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC/Te,SAASyE,YAAYA,GAAG;EACnC,oBACI5E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,eAAe;AAAAC,IAAAA,QAAA,EACrB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACroBe,SAAS0E,UAAUA,GAAG;EACjC,oBACI7E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,aAAa;AAAAC,IAAAA,QAAA,EACnB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC9oBe,SAAS2E,SAASA,GAAG;EAChC,oBACI9E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACjDe,SAAS4E,YAAYA,GAAG;EACnC,oBACI/E,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,WAAW;AAAAC,IAAAA,QAAA,EACjB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACrae,SAAS6E,SAASA,GAAG;EAChC,oBACIhF,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC3We,SAAS8E,gBAAgBA,GAAG;EACvC,oBACIjF,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,eAAe;AAAAC,IAAAA,QAAA,EACrB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACtbe,SAAS+E,UAAUA,GAAG;EACjC,oBACIlF,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACrfe,SAASgF,YAAYA,CAAC;AAAElG,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAC/C;AACA,EAAA,MAAMI,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;AAClC,EAAA,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAE,CAAA;AAE3B,EAAA,IAAIF,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,EAAE;QACVP,SAAS,CAACQ,GAAG,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,CAAA;AACzC,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAIqF,kBAAkB,GAAG,oBAAoB,CAAA;AAE7C,EAAA,IAAI9F,SAAS,CAAC+F,GAAG,CAAC,MAAM,CAAC,IAAI/F,SAAS,CAAC+F,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;AACA,EAAA,IAAI9F,SAAS,CAAC+F,GAAG,CAAC,OAAO,CAAC,EAAE;AACxBD,IAAAA,kBAAkB,IAAI,kBAAkB,CAAA;AAC5C,GAAA;AACA,EAAA,IAAI9F,SAAS,CAAC+F,GAAG,CAAC,MAAM,CAAC,IAAI/F,SAAS,CAAC+F,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;AACA,EAAA,IAAI9F,SAAS,CAAC+F,GAAG,CAAC,IAAI,CAAC,IAAI/F,SAAS,CAAC+F,GAAG,CAAC,KAAK,CAAC,EAAE;AAC7CD,IAAAA,kBAAkB,IAAI,sBAAsB,CAAA;AAChD,GAAA;AACA,EAAA,IAAI9F,SAAS,CAAC+F,GAAG,CAAC,MAAM,CAAC,IAAI/F,SAAS,CAAC+F,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;EAEA,oBACIpF,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEiF,kBAAkB,CAAA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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A;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACnSe,SAASI,aAAaA,CAAC;AAAExG,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAChD;AACA,EAAA,MAAMI,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;EAClC,IAAIqG,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAIrG,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACc,QAAQ,CAACd,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChE2F,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;EAEA,oBACI1F,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC1Ye,SAASwF,cAAcA,CAAC;AAAE1G,EAAAA,QAAAA;AAAS,CAAC,EAAE;AACjD;AACA,EAAA,MAAMI,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;EAClC,IAAIuG,QAAQ,GAAG,KAAK,CAAA;AAEpB,EAAA,IAAIvG,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;MACrD,IAAIA,QAAQ,IAAIA,QAAQ,CAACE,WAAW,EAAE,KAAK,OAAO,EAAE;AAChD6F,QAAAA,QAAQ,GAAG,IAAI,CAAA;AACnB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,QAAQ,EAAE;AACX,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;EAEA,oBACI5F,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,UAAU;AAAAC,IAAAA,QAAA,EAChB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC9de,SAAS0F,aAAaA,CAAC;AAAE5G,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAChD;AACA,EAAA,MAAMI,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;EAClC,IAAIyG,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAIzG,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACc,QAAQ,CAACd,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChE+F,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;EAEA,oBACI9F,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC9iBe,SAAS4F,kBAAkBA,CAAC;EAAE9G,QAAQ;AAAE+G,EAAAA,MAAAA;AAAO,CAAC,EAAE;AAC7D;AACA,EAAA,MAAM3G,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;EAClC,IAAI4G,YAAY,GAAG,KAAK,CAAA;AAExB,EAAA,IAAI5G,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,CAAC,CAACc,QAAQ,CAACd,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AACzEkG,QAAAA,YAAY,GAAG,IAAI,CAAA;AACvB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,YAAY,EAAE;AACf,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;AAEA,EAAA,MAAMC,WAAW,GAAGF,MAAM,CAACE,WAAW,KAAK,MAAM,IAAIF,MAAM,CAACE,WAAW,KAAK,IAAI,CAAA;EAEhF,oBACIlG,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,cAAc;AAAAC,IAAAA,QAAA,EACpB,CAAA;AACb;AACA;AACA,EAAE+F,WAAW,GAAG,CAAA;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,CAAA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,WAAW,GAAG,CAAA;AAChB;AACA,CAAC,GAAG,CAAA;AACJ;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;ACjde,SAASC,aAAaA,CAAC;EAAElH,QAAQ;AAAE+G,EAAAA,MAAAA;AAAO,CAAC,EAAE;AACxD;AACA,EAAA,MAAM3G,OAAO,GAAGJ,QAAQ,CAACI,OAAO,EAAE,CAAA;EAClC,IAAI+G,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAI/G,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACc,QAAQ,CAACd,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChEqG,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;AAEA,EAAA,MAAMF,WAAW,GAAGF,MAAM,CAACE,WAAW,KAAK,MAAM,IAAIF,MAAM,CAACE,WAAW,KAAK,IAAI,CAAA;EAEhF,oBACIlG,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA,EAAE+F,WAAW,GAAG,CAAA;AAChB;AACA;AACA,CAAC,GAAG,CAAA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,EAAMA,WAAW,GAAG,iCAAiC,GAAG,qDAAqD,CAAA;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAA,EAAcA,WAAW,GAAG,eAAe,GAAG,sBAAsB,CAAA;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,EAAMA,WAAW,GAAG,CAAA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,CAAK,GAAG,CAAA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAK,CAAA,CAAA;AACL;AACA;AACA,EAAEA,WAAW,GAAG,EAAE,GAAG,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAUA,WAAW,GAAG,CAAA;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,CAAS,GAAG,CAAA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAS,CAAA,CAAA;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAUA,WAAW,GAAG,CAAA;AACxB;AACA,QAAA,CAAS,GAAG,CAAA;AACZ;AACA;AACA;AACA,QAAS,CAAA,CAAA;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;AC9ae,cAAU,EAAA;EAAEjH,QAAQ;AAAE+G,EAAAA,MAAAA;AAAO,CAAC,EAAE;EAC3C,OAAO,cACHhG,cAAA,CAACqG,UAAS,EAAA;AAACpH,IAAAA,QAAQ,EAAEA,QAAS;AAAC+G,IAAAA,MAAM,EAAEA,MAAAA;AAAO,GAAE,CAAC,eACjDhG,cAAA,CAACsG,SAAQ,EAAA;AAACrH,IAAAA,QAAQ,EAAEA,QAAS;AAAC+G,IAAAA,MAAM,EAAEA,MAAAA;AAAO,GAAE,CAAC,eAChDhG,cAAA,CAAChB,MAAM,EAAA;AAACC,IAAAA,QAAQ,EAAEA,QAAS;AAAC+G,IAAAA,MAAM,EAAEA,MAAAA;AAAO,GAAE,CAAC,eAC9ChG,cAAA,CAACI,QAAQ,EAAA;AAAC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"}