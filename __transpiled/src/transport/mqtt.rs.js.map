{"version":3,"file":"mqtt.rs.js","sources":["../../../template/src/transport/mqtt.rs.js"],"sourcesContent":["export default function MqttTransport({ asyncapi }) {\n    // Check if MQTT protocol is used\n    const servers = asyncapi.servers();\n    let hasMqtt = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['mqtt', 'mqtts'].includes(protocol.toLowerCase())) {\n                hasMqtt = true;\n            }\n        });\n    }\n\n    // Only generate file if MQTT is used\n    if (!hasMqtt) {\n        return null;\n    }\n\n    return (\n        <File name=\"mqtt.rs\">\n            {`//! MQTT transport implementation\n\nuse async_trait::async_trait;\nuse rumqttc::{AsyncClient, Event, EventLoop, MqttOptions, Packet, QoS};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// MQTT transport implementation\npub struct MqttTransport {\n    config: TransportConfig,\n    client: Option<AsyncClient>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<HashMap<String, QoS>>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl MqttTransport {\n    /// Create a new MQTT transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"mqtt\" && config.protocol != \"mqtts\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for MQTT transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            client: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create MQTT options from configuration\n    fn create_mqtt_options(&self) -> AsyncApiResult<MqttOptions> {\n        let client_id = self.config.additional_config\n            .get(\"client_id\")\n            .cloned()\n            .unwrap_or_else(|| format!(\"asyncapi-client-{}\", uuid::Uuid::new_v4()));\n\n        let mut mqtt_options = MqttOptions::new(client_id, &self.config.host, self.config.port);\n\n        // Set credentials if provided\n        if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            mqtt_options.set_credentials(username, password);\n        }\n\n        // Configure TLS if enabled\n        if self.config.tls {\n            let tls_config = rumqttc::TlsConfiguration::Simple {\n                ca: vec![],\n                alpn: None,\n                client_auth: None,\n            };\n            mqtt_options.set_transport(rumqttc::Transport::Tls(tls_config));\n        }\n\n        // Set keep alive interval\n        if let Some(keep_alive) = self.config.additional_config\n            .get(\"keep_alive\")\n            .and_then(|v| v.parse::<u64>().ok())\n        {\n            mqtt_options.set_keep_alive(Duration::from_secs(keep_alive));\n        } else {\n            mqtt_options.set_keep_alive(Duration::from_secs(60));\n        }\n\n        // Set clean session\n        let clean_session = self.config.additional_config\n            .get(\"clean_session\")\n            .map(|v| v.parse::<bool>().unwrap_or(true))\n            .unwrap_or(true);\n        mqtt_options.set_clean_session(clean_session);\n\n        // Set max packet size\n        if let Some(max_packet_size) = self.config.additional_config\n            .get(\"max_packet_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            mqtt_options.set_max_packet_size(max_packet_size, max_packet_size);\n        }\n\n        Ok(mqtt_options)\n    }\n\n    /// Start the MQTT event loop\n    async fn start_event_loop(&mut self, mut event_loop: EventLoop) -> AsyncApiResult<()> {\n        let connection_state = Arc::clone(&self.connection_state);\n        let stats_arc = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        tokio::spawn(async move {\n            loop {\n                tokio::select! {\n                    event = event_loop.poll() => {\n                        match event {\n                            Ok(Event::Incoming(Packet::Publish(publish))) => {\n                                {\n                                    let mut stats = stats_arc.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += publish.payload.len() as u64;\n                                }\n\n                                if let Some(handler) = &message_handler {\n                                    let mut headers = HashMap::new();\n                                    headers.insert(\"topic\".to_string(), publish.topic.clone());\n                                    headers.insert(\"qos\".to_string(), format!(\"{:?}\", publish.qos));\n                                    headers.insert(\"retain\".to_string(), publish.retain.to_string());\n                                    headers.insert(\"dup\".to_string(), publish.dup.to_string());\n\n                                    let metadata = MessageMetadata {\n                                        channel: publish.topic.clone(),\n                                        operation: \"receive\".to_string(),\n                                        content_type: Some(\"application/octet-stream\".to_string()),\n                                        headers,\n                                        timestamp: chrono::Utc::now(),\n                                    };\n\n                                    let transport_message = TransportMessage {\n                                        metadata,\n                                        payload: publish.payload.to_vec(),\n                                    };\n\n                                    if let Err(e) = handler.handle_message(transport_message).await {\n                                        tracing::error!(\"Failed to handle MQTT message: {}\", e);\n                                        let mut error_stats = stats_arc.write().await;\n                                        error_stats.last_error = Some(e.to_string());\n                                    }\n                                }\n                            }\n                            Ok(Event::Incoming(Packet::ConnAck(_))) => {\n                                *connection_state.write().await = ConnectionState::Connected;\n                                tracing::info!(\"MQTT connection established\");\n                            }\n                            Ok(Event::Incoming(Packet::Disconnect)) => {\n                                *connection_state.write().await = ConnectionState::Disconnected;\n                                tracing::info!(\"MQTT disconnected\");\n                            }\n                            Ok(Event::Outgoing(_)) => {\n                                // Handle outgoing packets if needed\n                            }\n                            Err(e) => {\n                                tracing::error!(\"MQTT event loop error: {}\", e);\n                                *connection_state.write().await = ConnectionState::Failed;\n                                let mut stats = stats_arc.write().await;\n                                stats.last_error = Some(e.to_string());\n                                break;\n                            }\n                            _ => {\n                                // Handle other packet types\n                            }\n                        }\n                    }\n                    _ = shutdown_rx.recv() => {\n                        tracing::info!(\"MQTT event loop shutdown requested\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for MqttTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let mqtt_options = self.create_mqtt_options()?;\n        let (client, event_loop) = AsyncClient::new(mqtt_options, 10);\n\n        self.client = Some(client);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        // Start event loop\n        self.start_event_loop(event_loop).await?;\n\n        tracing::info!(\"MQTT transport connection initiated\");\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        if let Some(client) = &self.client {\n            if let Err(e) = client.disconnect().await {\n                tracing::warn!(\"Error disconnecting MQTT client: {}\", e);\n            }\n        }\n\n        self.client = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"MQTT transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let topic = &message.metadata.channel;\n        let qos = message.metadata.headers\n            .get(\"qos\")\n            .and_then(|q| match q.as_str() {\n                \"0\" => Some(QoS::AtMostOnce),\n                \"1\" => Some(QoS::AtLeastOnce),\n                \"2\" => Some(QoS::ExactlyOnce),\n                _ => None,\n            })\n            .unwrap_or(QoS::AtMostOnce);\n\n        let retain = message.metadata.headers\n            .get(\"retain\")\n            .map(|r| r.parse::<bool>().unwrap_or(false))\n            .unwrap_or(false);\n\n        let payload_len = message.payload.len();\n\n        client\n            .publish(topic, qos, retain, message.payload)\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to publish MQTT message: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += payload_len as u64;\n\n        tracing::debug!(\"Published MQTT message to topic: {}\", topic);\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let qos = QoS::AtMostOnce; // Default QoS, could be configurable\n\n        client.subscribe(channel, qos).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to subscribe to MQTT topic: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.insert(channel.to_string(), qos);\n\n        tracing::info!(\"Subscribed to MQTT topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let client = self.client.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"MQTT client not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        client.unsubscribe(channel).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to unsubscribe from MQTT topic: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.remove(channel);\n\n        tracing::info!(\"Unsubscribed from MQTT topic: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // MQTT listening is handled by the event loop, which is started in connect()\n        tracing::info!(\"MQTT transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for MqttTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["MqttTransport","asyncapi","servers","hasMqtt","Object","entries","forEach","_name","server","protocol","includes","toLowerCase","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,aAAaA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAChD;AACA,EAAA,MAAMC,OAAO,GAAGD,QAAQ,CAACC,OAAO,EAAE,CAAA;EAClC,IAAIC,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAID,OAAO,EAAE;AACTE,IAAAA,MAAM,CAACC,OAAO,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACC,QAAQ,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChER,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;EAEA,oBACIS,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}