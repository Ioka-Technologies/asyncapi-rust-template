{"version":3,"file":"http.rs.js","sources":["../../../template/src/transport/http.rs.js"],"sourcesContent":["export default function HttpTransport({ asyncapi, params }) {\n    // Check if HTTP protocol is used\n    const servers = asyncapi.servers();\n    let hasHttp = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['http', 'https'].includes(protocol.toLowerCase())) {\n                hasHttp = true;\n            }\n        });\n    }\n\n    // Only generate file if HTTP is used\n    if (!hasHttp) {\n        return null;\n    }\n\n    const useAsyncStd = params.useAsyncStd === 'true' || params.useAsyncStd === true;\n\n    return (\n        <File name=\"http.rs\">\n            {`//! HTTP transport implementation\n\nuse async_trait::async_trait;\n${useAsyncStd ? `\nuse tide::{Request, Response, Server as TideServer, StatusCode};\nuse async_std::task;\n` : `\nuse axum::{\n    extract::{Path, Query, State},\n    http::{HeaderMap, StatusCode, Method},\n    response::{Json, Response as AxumResponse},\n    routing::{get, post, put, delete},\n    Router,\n};\nuse tower::ServiceBuilder;\nuse tokio::net::TcpListener;\n`}\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse serde_json::Value;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// HTTP transport implementation\npub struct HttpTransport {\n    config: TransportConfig,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    routes: Arc<RwLock<HashMap<String, String>>>, // path -> method\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n    ${useAsyncStd ? 'server: Option<TideServer<()>>,' : 'server_handle: Option<tokio::task::JoinHandle<()>>,'}\n}\n\nimpl HttpTransport {\n    /// Create a new HTTP transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"http\" && config.protocol != \"https\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for HTTP transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            routes: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n            ${useAsyncStd ? 'server: None,' : 'server_handle: None,'}\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Get server address\n    fn get_server_address(&self) -> String {\n        format!(\"{}:{}\", self.config.host, self.config.port)\n    }\n\n    ${useAsyncStd ? `\n    /// Create Tide server\n    async fn create_tide_server(&self) -> AsyncApiResult<TideServer<()>> {\n        let mut app = tide::new();\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n\n        // Add middleware for logging and stats\n        app.with(tide::log::LogMiddleware::new());\n\n        // Generic handler for all routes\n        let handler = move |mut req: Request<()>| {\n            let stats = Arc::clone(&stats);\n            let message_handler = message_handler.clone();\n\n            async move {\n                let mut stats = stats.write().await;\n                stats.messages_received += 1;\n                drop(stats);\n\n                let method = req.method().to_string();\n                let path = req.url().path().to_string();\n                let query = req.url().query().unwrap_or(\"\").to_string();\n\n                // Extract headers\n                let mut headers = HashMap::new();\n                for (name, value) in req.iter() {\n                    if let Ok(value_str) = value.to_str() {\n                        headers.insert(name.to_string(), value_str.to_string());\n                    }\n                }\n\n                // Read body\n                let body = match req.body_bytes().await {\n                    Ok(bytes) => bytes,\n                    Err(e) => {\n                        tracing::error!(\"Failed to read request body: {}\", e);\n                        return Response::builder(StatusCode::BadRequest)\n                            .body(\"Failed to read request body\")\n                            .build();\n                    }\n                };\n\n                let mut stats = stats.write().await;\n                stats.bytes_received += body.len() as u64;\n                drop(stats);\n\n                if let Some(handler) = &message_handler {\n                    let metadata = MessageMetadata {\n                        channel: path.clone(),\n                        operation: method.clone(),\n                        content_type: headers.get(\"content-type\").cloned(),\n                        headers: headers.clone(),\n                        timestamp: chrono::Utc::now(),\n                    };\n\n                    let transport_message = TransportMessage {\n                        metadata,\n                        payload: body,\n                    };\n\n                    match handler.handle_message(transport_message).await {\n                        Ok(_) => {\n                            Response::builder(StatusCode::Ok)\n                                .body(\"Message processed successfully\")\n                                .build()\n                        }\n                        Err(e) => {\n                            tracing::error!(\"Failed to handle HTTP message: {}\", e);\n                            let mut stats = stats.write().await;\n                            stats.last_error = Some(e.to_string());\n                            Response::builder(StatusCode::InternalServerError)\n                                .body(\"Failed to process message\")\n                                .build()\n                        }\n                    }\n                } else {\n                    Response::builder(StatusCode::Ok)\n                        .body(\"No handler configured\")\n                        .build()\n                }\n            }\n        };\n\n        // Add routes for common HTTP methods\n        app.at(\"/*\").get(handler.clone());\n        app.at(\"/*\").post(handler.clone());\n        app.at(\"/*\").put(handler.clone());\n        app.at(\"/*\").delete(handler.clone());\n        app.at(\"/*\").patch(handler);\n\n        Ok(app)\n    }\n    ` : `\n    /// Create Axum router\n    async fn create_axum_router(&self) -> AsyncApiResult<Router> {\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n\n        // Create shared state\n        let app_state = AppState {\n            stats,\n            message_handler,\n        };\n\n        let router = Router::new()\n            .route(\"/*path\", get(handle_request))\n            .route(\"/*path\", post(handle_request))\n            .route(\"/*path\", put(handle_request))\n            .route(\"/*path\", delete(handle_request))\n            .route(\"/\", get(handle_request))\n            .route(\"/\", post(handle_request))\n            .route(\"/\", put(handle_request))\n            .route(\"/\", delete(handle_request))\n            .with_state(app_state)\n            .layer(\n                ServiceBuilder::new()\n                    .layer(axum::middleware::from_fn(logging_middleware))\n            );\n\n        Ok(router)\n    }\n    `}\n}\n\n${useAsyncStd ? '' : `\n#[derive(Clone)]\nstruct AppState {\n    stats: Arc<RwLock<TransportStats>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n}\n\nasync fn handle_request(\n    State(state): State<AppState>,\n    method: Method,\n    Path(path): Path<String>,\n    Query(query): Query<HashMap<String, String>>,\n    headers: HeaderMap,\n    body: axum::body::Bytes,\n) -> Result<AxumResponse<String>, StatusCode> {\n    let mut stats = state.stats.write().await;\n    stats.messages_received += 1;\n    stats.bytes_received += body.len() as u64;\n    drop(stats);\n\n    // Extract headers\n    let mut header_map = HashMap::new();\n    for (name, value) in headers.iter() {\n        if let Ok(value_str) = value.to_str() {\n            header_map.insert(name.to_string(), value_str.to_string());\n        }\n    }\n\n    // Add query parameters to headers\n    for (key, value) in query {\n        header_map.insert(format!(\"query_{}\", key), value);\n    }\n\n    if let Some(handler) = &state.message_handler {\n        let metadata = MessageMetadata {\n            channel: format!(\"/{}\", path),\n            operation: method.to_string(),\n            content_type: header_map.get(\"content-type\").cloned(),\n            headers: header_map,\n            timestamp: chrono::Utc::now(),\n        };\n\n        let transport_message = TransportMessage {\n            metadata,\n            payload: body.to_vec(),\n        };\n\n        match handler.handle_message(transport_message).await {\n            Ok(_) => Ok(AxumResponse::new(\"Message processed successfully\".to_string())),\n            Err(e) => {\n                tracing::error!(\"Failed to handle HTTP message: {}\", e);\n                let mut stats = state.stats.write().await;\n                stats.last_error = Some(e.to_string());\n                Err(StatusCode::INTERNAL_SERVER_ERROR)\n            }\n        }\n    } else {\n        Ok(AxumResponse::new(\"No handler configured\".to_string()))\n    }\n}\n\nasync fn logging_middleware(\n    request: axum::http::Request<axum::body::Body>,\n    next: axum::middleware::Next,\n) -> axum::response::Response {\n    let method = request.method().clone();\n    let uri = request.uri().clone();\n\n    tracing::info!(\"HTTP {} {}\", method, uri);\n\n    let response = next.run(request).await;\n\n    tracing::info!(\"HTTP {} {} -> {}\", method, uri, response.status());\n\n    response\n}\n`}\n\n#[async_trait]\nimpl Transport for HttpTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let address = self.get_server_address();\n\n        ${useAsyncStd ? `\n        let server = self.create_tide_server().await?;\n        self.server = Some(server);\n\n        let server_clone = self.server.as_ref().unwrap().clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        // Start server in background task\n        task::spawn(async move {\n            tokio::select! {\n                result = server_clone.listen(&address) => {\n                    if let Err(e) = result {\n                        tracing::error!(\"HTTP server error: {}\", e);\n                    }\n                }\n                _ = shutdown_rx.recv() => {\n                    tracing::info!(\"HTTP server shutdown requested\");\n                }\n            }\n        });\n        ` : `\n        let router = self.create_axum_router().await?;\n        let listener = TcpListener::bind(&address).await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to bind HTTP server to {}: {}\", address, e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        // Start server in background task\n        let server_handle = tokio::spawn(async move {\n            tokio::select! {\n                result = axum::serve(listener, router) => {\n                    if let Err(e) = result {\n                        tracing::error!(\"HTTP server error: {}\", e);\n                    }\n                }\n                _ = shutdown_rx.recv() => {\n                    tracing::info!(\"HTTP server shutdown requested\");\n                }\n            }\n        });\n\n        self.server_handle = Some(server_handle);\n        `}\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"HTTP transport started on {}\", address);\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        ${useAsyncStd ? `\n        self.server = None;\n        ` : `\n        if let Some(handle) = self.server_handle.take() {\n            handle.abort();\n        }\n        `}\n\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n        tracing::info!(\"HTTP transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        // HTTP transport is primarily for receiving messages (server mode)\n        // Sending would require making HTTP client requests\n        tracing::warn!(\"HTTP transport send_message not implemented - use HTTP client for outbound requests\");\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        // HTTP doesn't have traditional subscription model\n        // This could be used to register specific routes\n        let mut routes = self.routes.write().await;\n        routes.insert(channel.to_string(), \"GET\".to_string());\n\n        tracing::info!(\"Registered HTTP route: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let mut routes = self.routes.write().await;\n        routes.remove(channel);\n\n        tracing::info!(\"Unregistered HTTP route: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // HTTP listening is handled by the server, which is started in connect()\n        tracing::info!(\"HTTP transport is listening for requests\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for HttpTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["HttpTransport","asyncapi","params","servers","hasHttp","Object","entries","forEach","_name","server","protocol","includes","toLowerCase","useAsyncStd","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,aAAaA,CAAC;EAAEC,QAAQ;AAAEC,EAAAA,MAAAA;AAAO,CAAC,EAAE;AACxD;AACA,EAAA,MAAMC,OAAO,GAAGF,QAAQ,CAACE,OAAO,EAAE,CAAA;EAClC,IAAIC,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAID,OAAO,EAAE;AACTE,IAAAA,MAAM,CAACC,OAAO,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACC,QAAQ,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChER,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;AAEA,EAAA,MAAMS,WAAW,GAAGX,MAAM,CAACW,WAAW,KAAK,MAAM,IAAIX,MAAM,CAACW,WAAW,KAAK,IAAI,CAAA;EAEhF,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA,EAAEJ,WAAW,GAAG,CAAA;AAChB;AACA;AACA,CAAC,GAAG,CAAA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,EAAMA,WAAW,GAAG,iCAAiC,GAAG,qDAAqD,CAAA;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAA,EAAcA,WAAW,GAAG,eAAe,GAAG,sBAAsB,CAAA;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,EAAMA,WAAW,GAAG,CAAA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAA,CAAK,GAAG,CAAA;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAK,CAAA,CAAA;AACL;AACA;AACA,EAAEA,WAAW,GAAG,EAAE,GAAG,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAUA,WAAW,GAAG,CAAA;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,CAAS,GAAG,CAAA;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAS,CAAA,CAAA;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAUA,WAAW,GAAG,CAAA;AACxB;AACA,QAAA,CAAS,GAAG,CAAA;AACZ;AACA;AACA;AACA,QAAS,CAAA,CAAA;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}