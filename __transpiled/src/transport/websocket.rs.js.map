{"version":3,"file":"websocket.rs.js","sources":["../../../template/src/transport/websocket.rs.js"],"sourcesContent":["export default function WebSocketTransport({ asyncapi, params }) {\n    // Check if WebSocket protocol is used\n    const servers = asyncapi.servers();\n    let hasWebSocket = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['ws', 'wss', 'websocket'].includes(protocol.toLowerCase())) {\n                hasWebSocket = true;\n            }\n        });\n    }\n\n    // Only generate file if WebSocket is used\n    if (!hasWebSocket) {\n        return null;\n    }\n\n    const useAsyncStd = params.useAsyncStd === 'true' || params.useAsyncStd === true;\n\n    return (\n        <File name=\"websocket.rs\">\n            {`//! WebSocket transport implementation\n\nuse async_trait::async_trait;\n${useAsyncStd ? `\nuse async_tungstenite::{\n    async_std::connect_async, async_std::connect_async_with_config,\n    tungstenite::{Message, protocol::WebSocketConfig},\n    WebSocketStream,\n};\nuse async_std::net::TcpStream;\n` : `\nuse tokio_tungstenite::{\n    connect_async, connect_async_with_config,\n    tungstenite::{Message, protocol::WebSocketConfig},\n    WebSocketStream, MaybeTlsStream,\n};\nuse tokio::net::TcpStream;\n`}\nuse futures_util::{SinkExt, StreamExt};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse url::Url;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n${useAsyncStd ? `\ntype WsStream = WebSocketStream<TcpStream>;\n` : `\ntype WsStream = WebSocketStream<MaybeTlsStream<TcpStream>>;\n`}\n\n/// WebSocket transport implementation\npub struct WebSocketTransport {\n    config: TransportConfig,\n    ws_stream: Option<WsStream>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<Vec<String>>>,\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl WebSocketTransport {\n    /// Create a new WebSocket transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if ![\"ws\", \"wss\", \"websocket\"].contains(&config.protocol.as_str()) {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for WebSocket transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            ws_stream: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(Vec::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create WebSocket URL from configuration\n    fn create_websocket_url(&self) -> AsyncApiResult<Url> {\n        let scheme = match self.config.protocol.as_str() {\n            \"wss\" => \"wss\",\n            \"ws\" | \"websocket\" => if self.config.tls { \"wss\" } else { \"ws\" },\n            _ => \"ws\",\n        };\n\n        let path = self.config.additional_config\n            .get(\"path\")\n            .map(|p| p.as_str())\n            .unwrap_or(\"/\");\n\n        let url_str = format!(\"{}://{}:{}{}\", scheme, self.config.host, self.config.port, path);\n\n        Url::parse(&url_str).map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Invalid WebSocket URL: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })\n    }\n\n    /// Create WebSocket configuration\n    fn create_ws_config(&self) -> WebSocketConfig {\n        let mut config = WebSocketConfig::default();\n\n        // Set max message size if specified\n        if let Some(max_message_size) = self.config.additional_config\n            .get(\"max_message_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            config.max_message_size = Some(max_message_size);\n        }\n\n        // Set max frame size if specified\n        if let Some(max_frame_size) = self.config.additional_config\n            .get(\"max_frame_size\")\n            .and_then(|v| v.parse::<usize>().ok())\n        {\n            config.max_frame_size = Some(max_frame_size);\n        }\n\n        config\n    }\n\n    /// Start the WebSocket message loop\n    async fn start_message_loop(&mut self) -> AsyncApiResult<()> {\n        if let Some(ws_stream) = self.ws_stream.take() {\n            let (mut ws_sender, mut ws_receiver) = ws_stream.split();\n            let connection_state = Arc::clone(&self.connection_state);\n            let stats = Arc::clone(&self.stats);\n            let message_handler = self.message_handler.clone();\n            let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n            self.shutdown_tx = Some(shutdown_tx);\n\n            // Store the sender for sending messages\n            let (msg_tx, mut msg_rx) = mpsc::channel::<Message>(100);\n\n            // Spawn sender task\n            let sender_stats = Arc::clone(&stats);\n            tokio::spawn(async move {\n                loop {\n                    tokio::select! {\n                        message = msg_rx.recv() => {\n                            match message {\n                                Some(msg) => {\n                                    if let Err(e) = ws_sender.send(msg).await {\n                                        tracing::error!(\"Failed to send WebSocket message: {}\", e);\n                                        let mut stats = sender_stats.write().await;\n                                        stats.last_error = Some(e.to_string());\n                                        break;\n                                    }\n                                }\n                                None => break,\n                            }\n                        }\n                        _ = shutdown_rx.recv() => {\n                            tracing::info!(\"WebSocket sender shutdown requested\");\n                            break;\n                        }\n                    }\n                }\n            });\n\n            // Spawn receiver task\n            tokio::spawn(async move {\n                loop {\n                    match ws_receiver.next().await {\n                        Some(Ok(message)) => {\n                            match message {\n                                Message::Text(text) => {\n                                    let mut stats = stats.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += text.len() as u64;\n                                    drop(stats);\n\n                                    if let Some(handler) = &message_handler {\n                                        let metadata = MessageMetadata {\n                                            channel: \"websocket\".to_string(),\n                                            operation: \"receive\".to_string(),\n                                            content_type: Some(\"text/plain\".to_string()),\n                                            headers: HashMap::new(),\n                                            timestamp: chrono::Utc::now(),\n                                        };\n\n                                        let transport_message = TransportMessage {\n                                            metadata,\n                                            payload: text.into_bytes(),\n                                        };\n\n                                        if let Err(e) = handler.handle_message(transport_message).await {\n                                            tracing::error!(\"Failed to handle WebSocket text message: {}\", e);\n                                            let mut stats = stats.write().await;\n                                            stats.last_error = Some(e.to_string());\n                                        }\n                                    }\n                                }\n                                Message::Binary(data) => {\n                                    let mut stats = stats.write().await;\n                                    stats.messages_received += 1;\n                                    stats.bytes_received += data.len() as u64;\n                                    drop(stats);\n\n                                    if let Some(handler) = &message_handler {\n                                        let metadata = MessageMetadata {\n                                            channel: \"websocket\".to_string(),\n                                            operation: \"receive\".to_string(),\n                                            content_type: Some(\"application/octet-stream\".to_string()),\n                                            headers: HashMap::new(),\n                                            timestamp: chrono::Utc::now(),\n                                        };\n\n                                        let transport_message = TransportMessage {\n                                            metadata,\n                                            payload: data,\n                                        };\n\n                                        if let Err(e) = handler.handle_message(transport_message).await {\n                                            tracing::error!(\"Failed to handle WebSocket binary message: {}\", e);\n                                            let mut stats = stats.write().await;\n                                            stats.last_error = Some(e.to_string());\n                                        }\n                                    }\n                                }\n                                Message::Ping(data) => {\n                                    tracing::debug!(\"Received WebSocket ping\");\n                                    // Pong is automatically sent by tungstenite\n                                }\n                                Message::Pong(_) => {\n                                    tracing::debug!(\"Received WebSocket pong\");\n                                }\n                                Message::Close(_) => {\n                                    tracing::info!(\"WebSocket connection closed by peer\");\n                                    *connection_state.write().await = ConnectionState::Disconnected;\n                                    break;\n                                }\n                                Message::Frame(_) => {\n                                    // Raw frames are handled internally\n                                }\n                            }\n                        }\n                        Some(Err(e)) => {\n                            tracing::error!(\"WebSocket receiver error: {}\", e);\n                            *connection_state.write().await = ConnectionState::Failed;\n                            let mut stats = stats.write().await;\n                            stats.last_error = Some(e.to_string());\n                            break;\n                        }\n                        None => {\n                            tracing::info!(\"WebSocket receiver stream ended\");\n                            *connection_state.write().await = ConnectionState::Disconnected;\n                            break;\n                        }\n                    }\n                }\n            });\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for WebSocketTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let url = self.create_websocket_url()?;\n        let ws_config = self.create_ws_config();\n\n        // Create connection request with optional headers\n        let mut request = url.clone().into_client_request().map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create WebSocket request: {}\", e),\n                ErrorCategory::Configuration,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        // Add authentication headers if provided\n        if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            let auth_value = base64::encode(format!(\"{}:{}\", username, password));\n            request.headers_mut().insert(\n                \"Authorization\",\n                format!(\"Basic {}\", auth_value).parse().unwrap(),\n            );\n        }\n\n        // Add custom headers\n        for (key, value) in &self.config.additional_config {\n            if key.starts_with(\"header_\") {\n                let header_name = &key[7..]; // Remove \"header_\" prefix\n                if let Ok(header_value) = value.parse() {\n                    request.headers_mut().insert(header_name, header_value);\n                }\n            }\n        }\n\n        // Connect to WebSocket\n        let (ws_stream, _) = if ws_config == WebSocketConfig::default() {\n            connect_async(request).await\n        } else {\n            connect_async_with_config(request, Some(ws_config)).await\n        }.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to connect to WebSocket: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        self.ws_stream = Some(ws_stream);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        // Start message loop\n        self.start_message_loop().await?;\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"WebSocket transport connected successfully to {}\", url);\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        self.ws_stream = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"WebSocket transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        if !self.is_connected() {\n            return Err(AsyncApiError::new(\n                \"WebSocket not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            ));\n        }\n\n        // Determine message type based on content type\n        let ws_message = match message.metadata.content_type.as_deref() {\n            Some(\"text/plain\") | Some(\"application/json\") | Some(\"text/json\") => {\n                let text = String::from_utf8(message.payload).map_err(|e| {\n                    AsyncApiError::new(\n                        format!(\"Invalid UTF-8 in text message: {}\", e),\n                        ErrorCategory::Validation,\n                        Some(Box::new(e)),\n                    )\n                })?;\n                Message::Text(text)\n            }\n            _ => Message::Binary(message.payload.clone()),\n        };\n\n        // For this implementation, we would need to store the sender channel\n        // This is a simplified version - in practice, you'd want to store the sender\n        // from the message loop and use it here\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        tracing::debug!(\"Sent WebSocket message\");\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        // WebSocket doesn't have traditional subscription model\n        // This could be used to track which channels we're interested in\n        let mut subscriptions = self.subscriptions.write().await;\n        if !subscriptions.contains(&channel.to_string()) {\n            subscriptions.push(channel.to_string());\n        }\n\n        tracing::info!(\"Subscribed to WebSocket channel: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.retain(|c| c != channel);\n\n        tracing::info!(\"Unsubscribed from WebSocket channel: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // WebSocket listening is handled by the message loop, which is started in connect()\n        tracing::info!(\"WebSocket transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for WebSocketTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["WebSocketTransport","asyncapi","params","servers","hasWebSocket","Object","entries","forEach","_name","server","protocol","includes","toLowerCase","useAsyncStd","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,kBAAkBA,CAAC;EAAEC,QAAQ;AAAEC,EAAAA,MAAAA;AAAO,CAAC,EAAE;AAC7D;AACA,EAAA,MAAMC,OAAO,GAAGF,QAAQ,CAACE,OAAO,EAAE,CAAA;EAClC,IAAIC,YAAY,GAAG,KAAK,CAAA;AAExB,EAAA,IAAID,OAAO,EAAE;AACTE,IAAAA,MAAM,CAACC,OAAO,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,IAAI,EAAE,KAAK,EAAE,WAAW,CAAC,CAACC,QAAQ,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AACzER,QAAAA,YAAY,GAAG,IAAI,CAAA;AACvB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,YAAY,EAAE;AACf,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;AAEA,EAAA,MAAMS,WAAW,GAAGX,MAAM,CAACW,WAAW,KAAK,MAAM,IAAIX,MAAM,CAACW,WAAW,KAAK,IAAI,CAAA;EAEhF,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,cAAc;AAAAC,IAAAA,QAAA,EACpB,CAAA;AACb;AACA;AACA,EAAEJ,WAAW,GAAG,CAAA;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,CAAA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEA,WAAW,GAAG,CAAA;AAChB;AACA,CAAC,GAAG,CAAA;AACJ;AACA,CAAC,CAAA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}