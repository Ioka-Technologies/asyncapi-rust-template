{"version":3,"file":"mod.rs.js","sources":["../../../template/src/transport/mod.rs.js"],"sourcesContent":["export default function TransportMod({ asyncapi }) {\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    // Generate module declarations based on detected protocols\n    let moduleDeclarations = 'pub mod factory;\\n';\n\n    if (protocols.has('mqtt') || protocols.has('mqtts')) {\n        moduleDeclarations += 'pub mod mqtt;\\n';\n    }\n    if (protocols.has('kafka')) {\n        moduleDeclarations += 'pub mod kafka;\\n';\n    }\n    if (protocols.has('amqp') || protocols.has('amqps')) {\n        moduleDeclarations += 'pub mod amqp;\\n';\n    }\n    if (protocols.has('ws') || protocols.has('wss')) {\n        moduleDeclarations += 'pub mod websocket;\\n';\n    }\n    if (protocols.has('http') || protocols.has('https')) {\n        moduleDeclarations += 'pub mod http;\\n';\n    }\n\n    return (\n        <File name=\"mod.rs\">\n            {`//! Transport layer abstraction for AsyncAPI protocols\n//!\n//! This module provides a unified interface for different transport protocols\n//! including MQTT, Kafka, AMQP, WebSocket, and HTTP.\n#![allow(dead_code, unused_imports)]\n\nuse async_trait::async_trait;\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError};\nuse crate::models::AsyncApiMessage;\n\n${moduleDeclarations}\n\n/// Transport configuration for different protocols\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct TransportConfig {\n    pub protocol: String,\n    pub host: String,\n    pub port: u16,\n    pub username: Option<String>,\n    pub password: Option<String>,\n    pub tls: bool,\n    pub additional_config: HashMap<String, String>,\n}\n\n/// Connection state for transport implementations\n#[derive(Debug, Clone, Copy, PartialEq)]\npub enum ConnectionState {\n    Disconnected,\n    Connecting,\n    Connected,\n    Reconnecting,\n    Failed,\n}\n\n/// Transport statistics for monitoring\n#[derive(Debug, Clone, Default)]\npub struct TransportStats {\n    pub messages_sent: u64,\n    pub messages_received: u64,\n    pub bytes_sent: u64,\n    pub bytes_received: u64,\n    pub connection_attempts: u64,\n    pub last_error: Option<String>,\n}\n\n/// Message metadata for transport operations\n#[derive(Debug, Clone)]\npub struct MessageMetadata {\n    pub channel: String,\n    pub operation: String,\n    pub content_type: Option<String>,\n    pub headers: HashMap<String, String>,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n}\n\n/// Transport message wrapper\n#[derive(Debug, Clone)]\npub struct TransportMessage {\n    pub metadata: MessageMetadata,\n    pub payload: Vec<u8>,\n}\n\n/// Trait for transport implementations\n#[async_trait]\npub trait Transport: Send + Sync {\n    /// Connect to the transport\n    async fn connect(&mut self) -> AsyncApiResult<()>;\n\n    /// Disconnect from the transport\n    async fn disconnect(&mut self) -> AsyncApiResult<()>;\n\n    /// Check if transport is connected\n    fn is_connected(&self) -> bool;\n\n    /// Get current connection state\n    fn connection_state(&self) -> ConnectionState;\n\n    /// Send a message through the transport\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()>;\n\n    /// Subscribe to a channel/topic\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()>;\n\n    /// Unsubscribe from a channel/topic\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()>;\n\n    /// Start listening for messages (non-blocking)\n    async fn start_listening(&mut self) -> AsyncApiResult<()>;\n\n    /// Stop listening for messages\n    async fn stop_listening(&mut self) -> AsyncApiResult<()>;\n\n    /// Get transport statistics\n    fn get_stats(&self) -> TransportStats;\n\n    /// Health check for the transport\n    async fn health_check(&self) -> AsyncApiResult<bool>;\n\n    /// Get protocol name\n    fn protocol(&self) -> &str;\n}\n\n/// Message handler trait for processing incoming messages\n#[async_trait]\npub trait MessageHandler: Send + Sync {\n    async fn handle_message(&self, message: TransportMessage) -> AsyncApiResult<()>;\n}\n\n/// Transport manager for coordinating multiple transports\npub struct TransportManager {\n    transports: Arc<RwLock<HashMap<String, Box<dyn Transport>>>>,\n    handlers: Arc<RwLock<HashMap<String, Arc<dyn MessageHandler>>>>,\n    stats: Arc<RwLock<HashMap<String, TransportStats>>>,\n}\n\nimpl TransportManager {\n    /// Create a new transport manager\n    pub fn new() -> Self {\n        Self {\n            transports: Arc::new(RwLock::new(HashMap::new())),\n            handlers: Arc::new(RwLock::new(HashMap::new())),\n            stats: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Add a transport to the manager\n    pub async fn add_transport(&self, name: String, transport: Box<dyn Transport>) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        let protocol = transport.protocol().to_string();\n        transports.insert(name.clone(), transport);\n\n        // Initialize stats\n        let mut stats = self.stats.write().await;\n        stats.insert(name.clone(), TransportStats::default());\n\n        tracing::info!(\"Added {} transport: {}\", protocol, name);\n        Ok(())\n    }\n\n    /// Remove a transport from the manager\n    pub async fn remove_transport(&self, name: &str) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        if let Some(mut transport) = transports.remove(name) {\n            transport.disconnect().await?;\n        }\n\n        let mut stats = self.stats.write().await;\n        stats.remove(name);\n\n        tracing::info!(\"Removed transport: {}\", name);\n        Ok(())\n    }\n\n    /// Register a message handler for a channel\n    pub async fn register_handler(&self, channel: String, handler: Arc<dyn MessageHandler>) {\n        let mut handlers = self.handlers.write().await;\n        handlers.insert(channel.clone(), handler);\n        tracing::info!(\"Registered handler for channel: {}\", channel);\n    }\n\n    /// Connect all transports\n    pub async fn connect_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.connect().await {\n                Ok(_) => tracing::info!(\"Connected transport: {}\", name),\n                Err(e) => {\n                    tracing::error!(\"Failed to connect transport {}: {}\", name, e);\n                    return Err(e);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Disconnect all transports\n    pub async fn disconnect_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.disconnect().await {\n                Ok(_) => tracing::info!(\"Disconnected transport: {}\", name),\n                Err(e) => tracing::error!(\"Failed to disconnect transport {}: {}\", name, e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Start listening on all transports\n    pub async fn start_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.start_listening().await {\n                Ok(_) => tracing::info!(\"Started listening on transport: {}\", name),\n                Err(e) => {\n                    tracing::error!(\"Failed to start listening on transport {}: {}\", name, e);\n                    return Err(e);\n                }\n            }\n        }\n        Ok(())\n    }\n\n    /// Stop listening on all transports\n    pub async fn stop_all(&self) -> AsyncApiResult<()> {\n        let mut transports = self.transports.write().await;\n        for (name, transport) in transports.iter_mut() {\n            match transport.stop_listening().await {\n                Ok(_) => tracing::info!(\"Stopped listening on transport: {}\", name),\n                Err(e) => tracing::error!(\"Failed to stop listening on transport {}: {}\", name, e),\n            }\n        }\n        Ok(())\n    }\n\n    /// Get aggregated statistics from all transports\n    pub async fn get_all_stats(&self) -> HashMap<String, TransportStats> {\n        let transports = self.transports.read().await;\n        let mut all_stats = HashMap::new();\n\n        for (name, transport) in transports.iter() {\n            all_stats.insert(name.clone(), transport.get_stats());\n        }\n\n        all_stats\n    }\n\n    /// Perform health check on all transports\n    pub async fn health_check_all(&self) -> HashMap<String, bool> {\n        let transports = self.transports.read().await;\n        let mut health_status = HashMap::new();\n\n        for (name, transport) in transports.iter() {\n            let is_healthy = transport.health_check().await.unwrap_or(false);\n            health_status.insert(name.clone(), is_healthy);\n        }\n\n        health_status\n    }\n}\n\nimpl Default for TransportManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["TransportMod","asyncapi","servers","protocols","Set","Object","entries","forEach","_name","server","protocol","add","toLowerCase","moduleDeclarations","has","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,YAAYA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAC/C;AACA,EAAA,MAAMC,OAAO,GAAGD,QAAQ,CAACC,OAAO,EAAE,CAAA;AAClC,EAAA,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAE,CAAA;AAE3B,EAAA,IAAIF,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,EAAE;QACVP,SAAS,CAACQ,GAAG,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,CAAA;AACzC,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAIC,kBAAkB,GAAG,oBAAoB,CAAA;AAE7C,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACxBD,IAAAA,kBAAkB,IAAI,kBAAkB,CAAA;AAC5C,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,IAAI,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,KAAK,CAAC,EAAE;AAC7CD,IAAAA,kBAAkB,IAAI,sBAAsB,CAAA;AAChD,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,kBAAkB,IAAI,iBAAiB,CAAA;AAC3C,GAAA;EAEA,oBACIE,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEL,kBAAkB,CAAA;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}