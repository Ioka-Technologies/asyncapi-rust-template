{"version":3,"file":"amqp.rs.js","sources":["../../../template/src/transport/amqp.rs.js"],"sourcesContent":["export default function AmqpTransport({ asyncapi }) {\n    // Check if AMQP protocol is used\n    const servers = asyncapi.servers();\n    let hasAmqp = false;\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol && ['amqp', 'amqps'].includes(protocol.toLowerCase())) {\n                hasAmqp = true;\n            }\n        });\n    }\n\n    // Only generate file if AMQP is used\n    if (!hasAmqp) {\n        return null;\n    }\n\n    return (\n        <File name=\"amqp.rs\">\n            {`//! AMQP transport implementation\n\nuse async_trait::async_trait;\nuse lapin::{\n    options::*, types::FieldTable, BasicProperties, Channel, Connection, ConnectionProperties,\n    Consumer, ExchangeKind,\n};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::{mpsc, RwLock};\nuse tokio_stream::StreamExt;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{\n    Transport, TransportConfig, TransportStats, TransportMessage, MessageMetadata,\n    ConnectionState, MessageHandler,\n};\n\n/// AMQP transport implementation\npub struct AmqpTransport {\n    config: TransportConfig,\n    connection: Option<Connection>,\n    channel: Option<Channel>,\n    connection_state: Arc<RwLock<ConnectionState>>,\n    stats: Arc<RwLock<TransportStats>>,\n    subscriptions: Arc<RwLock<HashMap<String, String>>>, // queue_name -> routing_key\n    message_handler: Option<Arc<dyn MessageHandler>>,\n    shutdown_tx: Option<mpsc::Sender<()>>,\n}\n\nimpl AmqpTransport {\n    /// Create a new AMQP transport\n    pub fn new(config: TransportConfig) -> AsyncApiResult<Self> {\n        if config.protocol != \"amqp\" && config.protocol != \"amqps\" {\n            return Err(AsyncApiError::new(\n                format!(\"Invalid protocol for AMQP transport: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        Ok(Self {\n            config,\n            connection: None,\n            channel: None,\n            connection_state: Arc::new(RwLock::new(ConnectionState::Disconnected)),\n            stats: Arc::new(RwLock::new(TransportStats::default())),\n            subscriptions: Arc::new(RwLock::new(HashMap::new())),\n            message_handler: None,\n            shutdown_tx: None,\n        })\n    }\n\n    /// Set message handler for incoming messages\n    pub fn set_message_handler(&mut self, handler: Arc<dyn MessageHandler>) {\n        self.message_handler = Some(handler);\n    }\n\n    /// Create AMQP connection URI\n    fn create_connection_uri(&self) -> String {\n        let scheme = if self.config.tls { \"amqps\" } else { \"amqp\" };\n        let auth = if let (Some(username), Some(password)) = (&self.config.username, &self.config.password) {\n            format!(\"{}:{}@\", username, password)\n        } else {\n            String::new()\n        };\n\n        let vhost = self.config.additional_config\n            .get(\"vhost\")\n            .map(|v| format!(\"/{}\", v))\n            .unwrap_or_else(|| \"/\".to_string());\n\n        format!(\"{}://{}{}:{}{}\", scheme, auth, self.config.host, self.config.port, vhost)\n    }\n\n    /// Get exchange name from configuration\n    fn get_exchange_name(&self) -> String {\n        self.config.additional_config\n            .get(\"exchange\")\n            .cloned()\n            .unwrap_or_else(|| \"asyncapi\".to_string())\n    }\n\n    /// Get exchange type from configuration\n    fn get_exchange_type(&self) -> ExchangeKind {\n        match self.config.additional_config\n            .get(\"exchange_type\")\n            .map(|s| s.as_str())\n            .unwrap_or(\"topic\")\n        {\n            \"direct\" => ExchangeKind::Direct,\n            \"fanout\" => ExchangeKind::Fanout,\n            \"headers\" => ExchangeKind::Headers,\n            _ => ExchangeKind::Topic,\n        }\n    }\n\n    /// Start consuming messages from a queue\n    async fn start_consumer(&mut self, queue_name: &str) -> AsyncApiResult<()> {\n        let channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not available\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let consumer = channel\n            .basic_consume(\n                queue_name,\n                &format!(\"asyncapi-consumer-{}\", uuid::Uuid::new_v4()),\n                BasicConsumeOptions::default(),\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to create AMQP consumer: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let connection_state = Arc::clone(&self.connection_state);\n        let stats = Arc::clone(&self.stats);\n        let message_handler = self.message_handler.clone();\n        let (shutdown_tx, mut shutdown_rx) = mpsc::channel::<()>(1);\n        self.shutdown_tx = Some(shutdown_tx);\n\n        tokio::spawn(async move {\n            let mut consumer_stream = consumer;\n\n            loop {\n                tokio::select! {\n                    delivery_result = consumer_stream.next() => {\n                        match delivery_result {\n                            Some(Ok(delivery)) => {\n                                let mut stats = stats.write().await;\n                                stats.messages_received += 1;\n                                stats.bytes_received += delivery.data.len() as u64;\n                                drop(stats);\n\n                                if let Some(handler) = &message_handler {\n                                    let mut headers = HashMap::new();\n\n                                    // Add AMQP-specific metadata\n                                    headers.insert(\"exchange\".to_string(), delivery.exchange.to_string());\n                                    headers.insert(\"routing_key\".to_string(), delivery.routing_key.to_string());\n                                    headers.insert(\"delivery_tag\".to_string(), delivery.delivery_tag.to_string());\n                                    headers.insert(\"redelivered\".to_string(), delivery.redelivered.to_string());\n\n                                    // Add message properties\n                                    if let Some(properties) = &delivery.properties {\n                                        if let Some(content_type) = &properties.content_type() {\n                                            headers.insert(\"content_type\".to_string(), content_type.to_string());\n                                        }\n                                        if let Some(content_encoding) = &properties.content_encoding() {\n                                            headers.insert(\"content_encoding\".to_string(), content_encoding.to_string());\n                                        }\n                                        if let Some(message_id) = &properties.message_id() {\n                                            headers.insert(\"message_id\".to_string(), message_id.to_string());\n                                        }\n                                        if let Some(correlation_id) = &properties.correlation_id() {\n                                            headers.insert(\"correlation_id\".to_string(), correlation_id.to_string());\n                                        }\n                                        if let Some(reply_to) = &properties.reply_to() {\n                                            headers.insert(\"reply_to\".to_string(), reply_to.to_string());\n                                        }\n                                        if let Some(user_id) = &properties.user_id() {\n                                            headers.insert(\"user_id\".to_string(), user_id.to_string());\n                                        }\n                                        if let Some(app_id) = &properties.app_id() {\n                                            headers.insert(\"app_id\".to_string(), app_id.to_string());\n                                        }\n\n                                        // Add custom headers\n                                        if let Some(amqp_headers) = properties.headers() {\n                                            for (key, value) in amqp_headers.iter() {\n                                                if let Ok(value_str) = std::str::from_utf8(&value.to_string().as_bytes()) {\n                                                    headers.insert(key.to_string(), value_str.to_string());\n                                                }\n                                            }\n                                        }\n                                    }\n\n                                    let metadata = MessageMetadata {\n                                        channel: delivery.routing_key.to_string(),\n                                        operation: \"receive\".to_string(),\n                                        content_type: delivery.properties\n                                            .as_ref()\n                                            .and_then(|p| p.content_type())\n                                            .map(|ct| ct.to_string())\n                                            .or_else(|| Some(\"application/octet-stream\".to_string())),\n                                        headers,\n                                        timestamp: chrono::Utc::now(),\n                                    };\n\n                                    let transport_message = TransportMessage {\n                                        metadata,\n                                        payload: delivery.data.to_vec(),\n                                    };\n\n                                    if let Err(e) = handler.handle_message(transport_message).await {\n                                        tracing::error!(\"Failed to handle AMQP message: {}\", e);\n                                        let mut stats = stats.write().await;\n                                        stats.last_error = Some(e.to_string());\n                                    }\n\n                                    // Acknowledge the message\n                                    if let Err(e) = delivery.ack(BasicAckOptions::default()).await {\n                                        tracing::error!(\"Failed to acknowledge AMQP message: {}\", e);\n                                    }\n                                }\n                            }\n                            Some(Err(e)) => {\n                                tracing::error!(\"AMQP consumer error: {}\", e);\n                                let mut stats = stats.write().await;\n                                stats.last_error = Some(e.to_string());\n                            }\n                            None => {\n                                tracing::info!(\"AMQP consumer stream ended\");\n                                break;\n                            }\n                        }\n                    }\n                    _ = shutdown_rx.recv() => {\n                        tracing::info!(\"AMQP consumer shutdown requested\");\n                        break;\n                    }\n                }\n            }\n        });\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Transport for AmqpTransport {\n    async fn connect(&mut self) -> AsyncApiResult<()> {\n        *self.connection_state.write().await = ConnectionState::Connecting;\n\n        let connection_uri = self.create_connection_uri();\n        let connection_properties = ConnectionProperties::default();\n\n        let connection = Connection::connect(&connection_uri, connection_properties)\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to connect to AMQP broker: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let channel = connection.create_channel().await.map_err(|e| {\n            AsyncApiError::new(\n                format!(\"Failed to create AMQP channel: {}\", e),\n                ErrorCategory::Network,\n                Some(Box::new(e)),\n            )\n        })?;\n\n        // Declare exchange if configured\n        let exchange_name = self.get_exchange_name();\n        let exchange_type = self.get_exchange_type();\n\n        channel\n            .exchange_declare(\n                &exchange_name,\n                exchange_type,\n                ExchangeDeclareOptions {\n                    durable: true,\n                    ..Default::default()\n                },\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to declare AMQP exchange: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        self.connection = Some(connection);\n        self.channel = Some(channel);\n\n        // Update connection attempts\n        let mut stats = self.stats.write().await;\n        stats.connection_attempts += 1;\n        drop(stats);\n\n        *self.connection_state.write().await = ConnectionState::Connected;\n        tracing::info!(\"AMQP transport connected successfully\");\n\n        Ok(())\n    }\n\n    async fn disconnect(&mut self) -> AsyncApiResult<()> {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.send(()).await;\n        }\n\n        if let Some(channel) = &self.channel {\n            if let Err(e) = channel.close(200, \"Normal shutdown\").await {\n                tracing::warn!(\"Error closing AMQP channel: {}\", e);\n            }\n        }\n\n        if let Some(connection) = &self.connection {\n            if let Err(e) = connection.close(200, \"Normal shutdown\").await {\n                tracing::warn!(\"Error closing AMQP connection: {}\", e);\n            }\n        }\n\n        self.channel = None;\n        self.connection = None;\n        *self.connection_state.write().await = ConnectionState::Disconnected;\n\n        tracing::info!(\"AMQP transport disconnected\");\n        Ok(())\n    }\n\n    fn is_connected(&self) -> bool {\n        self.connection_state\n            .try_read()\n            .map(|state| matches!(*state, ConnectionState::Connected))\n            .unwrap_or(false)\n            && self.connection.as_ref().map_or(false, |c| c.status().connected())\n    }\n\n    fn connection_state(&self) -> ConnectionState {\n        self.connection_state\n            .try_read()\n            .map(|state| *state)\n            .unwrap_or(ConnectionState::Disconnected)\n    }\n\n    async fn send_message(&mut self, message: TransportMessage) -> AsyncApiResult<()> {\n        let channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let exchange_name = self.get_exchange_name();\n        let routing_key = &message.metadata.channel;\n\n        // Create basic properties\n        let mut properties = BasicProperties::default();\n\n        if let Some(content_type) = &message.metadata.content_type {\n            properties = properties.with_content_type(content_type.clone().into());\n        }\n\n        // Set properties from headers\n        if let Some(message_id) = message.metadata.headers.get(\"message_id\") {\n            properties = properties.with_message_id(message_id.clone().into());\n        }\n        if let Some(correlation_id) = message.metadata.headers.get(\"correlation_id\") {\n            properties = properties.with_correlation_id(correlation_id.clone().into());\n        }\n        if let Some(reply_to) = message.metadata.headers.get(\"reply_to\") {\n            properties = properties.with_reply_to(reply_to.clone().into());\n        }\n\n        // Add custom headers\n        let mut field_table = FieldTable::default();\n        for (key, value) in &message.metadata.headers {\n            if ![\"message_id\", \"correlation_id\", \"reply_to\", \"content_type\"].contains(&key.as_str()) {\n                field_table.insert(key.clone().into(), value.clone().into());\n            }\n        }\n        if !field_table.is_empty() {\n            properties = properties.with_headers(field_table);\n        }\n\n        channel\n            .basic_publish(\n                &exchange_name,\n                routing_key,\n                BasicPublishOptions::default(),\n                &message.payload,\n                properties,\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to publish AMQP message: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        let mut stats = self.stats.write().await;\n        stats.messages_sent += 1;\n        stats.bytes_sent += message.payload.len() as u64;\n\n        tracing::debug!(\"Published AMQP message to routing key: {}\", routing_key);\n        Ok(())\n    }\n\n    async fn subscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let amqp_channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let exchange_name = self.get_exchange_name();\n        let queue_name = format!(\"asyncapi-queue-{}\", uuid::Uuid::new_v4());\n\n        // Declare queue\n        let queue = amqp_channel\n            .queue_declare(\n                &queue_name,\n                QueueDeclareOptions {\n                    auto_delete: true,\n                    ..Default::default()\n                },\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to declare AMQP queue: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        // Bind queue to exchange\n        amqp_channel\n            .queue_bind(\n                &queue_name,\n                &exchange_name,\n                channel,\n                QueueBindOptions::default(),\n                FieldTable::default(),\n            )\n            .await\n            .map_err(|e| {\n                AsyncApiError::new(\n                    format!(\"Failed to bind AMQP queue: {}\", e),\n                    ErrorCategory::Network,\n                    Some(Box::new(e)),\n                )\n            })?;\n\n        // Start consuming\n        self.start_consumer(&queue_name).await?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        subscriptions.insert(queue_name, channel.to_string());\n\n        tracing::info!(\"Subscribed to AMQP routing key: {}\", channel);\n        Ok(())\n    }\n\n    async fn unsubscribe(&mut self, channel: &str) -> AsyncApiResult<()> {\n        let amqp_channel = self.channel.as_ref().ok_or_else(|| {\n            AsyncApiError::new(\n                \"AMQP channel not connected\".to_string(),\n                ErrorCategory::Network,\n                None,\n            )\n        })?;\n\n        let mut subscriptions = self.subscriptions.write().await;\n        let queue_to_remove = subscriptions\n            .iter()\n            .find(|(_, routing_key)| routing_key.as_str() == channel)\n            .map(|(queue_name, _)| queue_name.clone());\n\n        if let Some(queue_name) = queue_to_remove {\n            // Delete the queue\n            amqp_channel\n                .queue_delete(&queue_name, QueueDeleteOptions::default())\n                .await\n                .map_err(|e| {\n                    AsyncApiError::new(\n                        format!(\"Failed to delete AMQP queue: {}\", e),\n                        ErrorCategory::Network,\n                        Some(Box::new(e)),\n                    )\n                })?;\n\n            subscriptions.remove(&queue_name);\n        }\n\n        tracing::info!(\"Unsubscribed from AMQP routing key: {}\", channel);\n        Ok(())\n    }\n\n    async fn start_listening(&mut self) -> AsyncApiResult<()> {\n        // AMQP listening is handled by the consumer, which is started in subscribe()\n        tracing::info!(\"AMQP transport is listening for messages\");\n        Ok(())\n    }\n\n    async fn stop_listening(&mut self) -> AsyncApiResult<()> {\n        // Stop listening by disconnecting\n        self.disconnect().await\n    }\n\n    fn get_stats(&self) -> TransportStats {\n        self.stats.try_read()\n            .map(|stats| stats.clone())\n            .unwrap_or_default()\n    }\n\n    async fn health_check(&self) -> AsyncApiResult<bool> {\n        Ok(self.is_connected())\n    }\n\n    fn protocol(&self) -> &str {\n        &self.config.protocol\n    }\n}\n\nimpl Drop for AmqpTransport {\n    fn drop(&mut self) {\n        if let Some(shutdown_tx) = self.shutdown_tx.take() {\n            let _ = shutdown_tx.try_send(());\n        }\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["AmqpTransport","asyncapi","servers","hasAmqp","Object","entries","forEach","_name","server","protocol","includes","toLowerCase","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,aAAaA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAChD;AACA,EAAA,MAAMC,OAAO,GAAGD,QAAQ,CAACC,OAAO,EAAE,CAAA;EAClC,IAAIC,OAAO,GAAG,KAAK,CAAA;AAEnB,EAAA,IAAID,OAAO,EAAE;AACTE,IAAAA,MAAM,CAACC,OAAO,CAACH,OAAO,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO,CAAC,CAACC,QAAQ,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,EAAE;AAChER,QAAAA,OAAO,GAAG,IAAI,CAAA;AAClB,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAI,CAACA,OAAO,EAAE;AACV,IAAA,OAAO,IAAI,CAAA;AACf,GAAA;EAEA,oBACIS,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}