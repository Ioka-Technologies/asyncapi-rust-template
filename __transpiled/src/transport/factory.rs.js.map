{"version":3,"file":"factory.rs.js","sources":["../../../template/src/transport/factory.rs.js"],"sourcesContent":["export default function TransportFactory({ asyncapi }) {\n    // Detect protocols from servers\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    // Generate imports based on detected protocols\n    let imports = '';\n\n    if (protocols.has('mqtt') || protocols.has('mqtts')) {\n        imports += 'use crate::transport::mqtt::MqttTransport;\\n';\n    }\n    if (protocols.has('kafka')) {\n        imports += 'use crate::transport::kafka::KafkaTransport;\\n';\n    }\n    if (protocols.has('amqp') || protocols.has('amqps')) {\n        imports += 'use crate::transport::amqp::AmqpTransport;\\n';\n    }\n    if (protocols.has('ws') || protocols.has('wss')) {\n        imports += 'use crate::transport::websocket::WebSocketTransport;\\n';\n    }\n    if (protocols.has('http') || protocols.has('https')) {\n        imports += 'use crate::transport::http::HttpTransport;\\n';\n    }\n\n    return (\n        <File name=\"factory.rs\">\n            {`//! Transport factory for creating transport instances based on protocol\n\nuse std::collections::HashMap;\nuse std::sync::Arc;\n\nuse crate::errors::{AsyncApiResult, AsyncApiError, ErrorCategory};\nuse crate::transport::{Transport, TransportConfig};\n${imports}\n\n/// Factory for creating transport instances based on protocol\npub struct TransportFactory;\n\nimpl TransportFactory {\n    /// Create a transport instance based on the protocol\n    pub fn create_transport(config: TransportConfig) -> AsyncApiResult<Box<dyn Transport>> {\n        match config.protocol.to_lowercase().as_str() {${protocols.has('mqtt') || protocols.has('mqtts') ? `\n            \"mqtt\" | \"mqtts\" => {\n                let transport = MqttTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('kafka') ? `\n            \"kafka\" => {\n                let transport = KafkaTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('amqp') || protocols.has('amqps') ? `\n            \"amqp\" | \"amqps\" => {\n                let transport = AmqpTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('ws') || protocols.has('wss') ? `\n            \"ws\" | \"wss\" | \"websocket\" => {\n                let transport = WebSocketTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}${protocols.has('http') || protocols.has('https') ? `\n            \"http\" | \"https\" => {\n                let transport = HttpTransport::new(config)?;\n                Ok(Box::new(transport))\n            }` : ''}\n            _ => Err(AsyncApiError::new(\n                format!(\"Unsupported protocol: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            )),\n        }\n    }\n\n    /// Create multiple transports from a configuration map\n    pub fn create_transports(\n        configs: HashMap<String, TransportConfig>,\n    ) -> AsyncApiResult<HashMap<String, Box<dyn Transport>>> {\n        let mut transports = HashMap::new();\n\n        for (name, config) in configs {\n            let transport = Self::create_transport(config)?;\n            transports.insert(name, transport);\n        }\n\n        Ok(transports)\n    }\n\n    /// Get supported protocols\n    pub fn supported_protocols() -> Vec<&'static str> {\n        vec![\"mqtt\", \"mqtts\", \"kafka\", \"amqp\", \"amqps\", \"ws\", \"wss\", \"websocket\", \"http\", \"https\"]\n    }\n\n    /// Check if a protocol is supported\n    pub fn is_protocol_supported(protocol: &str) -> bool {\n        Self::supported_protocols().contains(&protocol.to_lowercase().as_str())\n    }\n\n    /// Create transport configuration from AsyncAPI server specification\n    pub fn config_from_server(\n        _server_name: &str,\n        protocol: &str,\n        host: &str,\n        port: u16,\n        additional_config: HashMap<String, String>,\n    ) -> TransportConfig {\n        TransportConfig {\n            protocol: protocol.to_string(),\n            host: host.to_string(),\n            port,\n            username: additional_config.get(\"username\").cloned(),\n            password: additional_config.get(\"password\").cloned(),\n            tls: protocol.ends_with('s') || additional_config.get(\"tls\").map_or(false, |v| v == \"true\"),\n            additional_config,\n        }\n    }\n\n    /// Validate transport configuration\n    pub fn validate_config(config: &TransportConfig) -> AsyncApiResult<()> {\n        // Check if protocol is supported\n        if !Self::is_protocol_supported(&config.protocol) {\n            return Err(AsyncApiError::new(\n                format!(\"Unsupported protocol: {}\", config.protocol),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Validate host\n        if config.host.is_empty() {\n            return Err(AsyncApiError::new(\n                \"Host cannot be empty\".to_string(),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Validate port\n        if config.port == 0 {\n            return Err(AsyncApiError::new(\n                \"Port cannot be zero\".to_string(),\n                ErrorCategory::Configuration,\n                None,\n            ));\n        }\n\n        // Protocol-specific validation\n        match config.protocol.to_lowercase().as_str() {\n            \"mqtt\" | \"mqtts\" => {\n                // MQTT-specific validation\n                if config.port < 1024 && !config.additional_config.contains_key(\"allow_privileged_ports\") {\n                    tracing::warn!(\"Using privileged port {} for MQTT\", config.port);\n                }\n            }\n            \"kafka\" => {\n                // Kafka-specific validation\n                if config.port != 9092 && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for Kafka\", config.port);\n                }\n            }\n            \"amqp\" | \"amqps\" => {\n                // AMQP-specific validation\n                let default_port = if config.protocol == \"amqps\" { 5671 } else { 5672 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for AMQP\", config.port);\n                }\n            }\n            \"ws\" | \"wss\" | \"websocket\" => {\n                // WebSocket-specific validation\n                let default_port = if config.protocol == \"wss\" { 443 } else { 80 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for WebSocket\", config.port);\n                }\n            }\n            \"http\" | \"https\" => {\n                // HTTP-specific validation\n                let default_port = if config.protocol == \"https\" { 443 } else { 80 };\n                if config.port != default_port && !config.additional_config.contains_key(\"custom_port\") {\n                    tracing::warn!(\"Using non-standard port {} for HTTP\", config.port);\n                }\n            }\n            _ => {\n                // This should not happen due to earlier validation\n                return Err(AsyncApiError::new(\n                    format!(\"Unknown protocol for validation: {}\", config.protocol),\n                    ErrorCategory::Configuration,\n                    None,\n                ));\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Create default configuration for a protocol\n    pub fn default_config(protocol: &str) -> AsyncApiResult<TransportConfig> {\n        let (default_port, tls) = match protocol.to_lowercase().as_str() {\n            \"mqtt\" => (1883, false),\n            \"mqtts\" => (8883, true),\n            \"kafka\" => (9092, false),\n            \"amqp\" => (5672, false),\n            \"amqps\" => (5671, true),\n            \"ws\" | \"websocket\" => (80, false),\n            \"wss\" => (443, true),\n            \"http\" => (80, false),\n            \"https\" => (443, true),\n            _ => {\n                return Err(AsyncApiError::new(\n                    format!(\"Unsupported protocol: {}\", protocol),\n                    ErrorCategory::Configuration,\n                    None,\n                ));\n            }\n        };\n\n        Ok(TransportConfig {\n            protocol: protocol.to_string(),\n            host: \"localhost\".to_string(),\n            port: default_port,\n            username: None,\n            password: None,\n            tls,\n            additional_config: HashMap::new(),\n        })\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_supported_protocols() {\n        let protocols = TransportFactory::supported_protocols();\n        assert!(protocols.contains(&\"mqtt\"));\n        assert!(protocols.contains(&\"kafka\"));\n        assert!(protocols.contains(&\"amqp\"));\n        assert!(protocols.contains(&\"ws\"));\n        assert!(protocols.contains(&\"http\"));\n    }\n\n    #[test]\n    fn test_is_protocol_supported() {\n        assert!(TransportFactory::is_protocol_supported(\"mqtt\"));\n        assert!(TransportFactory::is_protocol_supported(\"MQTT\"));\n        assert!(TransportFactory::is_protocol_supported(\"kafka\"));\n        assert!(!TransportFactory::is_protocol_supported(\"unknown\"));\n    }\n\n    #[test]\n    fn test_default_config() {\n        let config = TransportFactory::default_config(\"mqtt\").unwrap();\n        assert_eq!(config.protocol, \"mqtt\");\n        assert_eq!(config.host, \"localhost\");\n        assert_eq!(config.port, 1883);\n        assert!(!config.tls);\n\n        let config = TransportFactory::default_config(\"mqtts\").unwrap();\n        assert_eq!(config.protocol, \"mqtts\");\n        assert_eq!(config.port, 8883);\n        assert!(config.tls);\n    }\n\n    #[test]\n    fn test_validate_config() {\n        let mut config = TransportFactory::default_config(\"mqtt\").unwrap();\n        assert!(TransportFactory::validate_config(&config).is_ok());\n\n        // Test invalid protocol\n        config.protocol = \"invalid\".to_string();\n        assert!(TransportFactory::validate_config(&config).is_err());\n\n        // Test empty host\n        config.protocol = \"mqtt\".to_string();\n        config.host = \"\".to_string();\n        assert!(TransportFactory::validate_config(&config).is_err());\n\n        // Test zero port\n        config.host = \"localhost\".to_string();\n        config.port = 0;\n        assert!(TransportFactory::validate_config(&config).is_err());\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["TransportFactory","asyncapi","servers","protocols","Set","Object","entries","forEach","_","server","protocol","add","toLowerCase","imports","has","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,gBAAgBA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AACnD;AACA,EAAA,MAAMC,OAAO,GAAGD,QAAQ,CAACC,OAAO,EAAE,CAAA;AAClC,EAAA,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAE,CAAA;AAE3B,EAAA,IAAIF,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,CAAC,EAAEC,MAAM,CAAC,KAAK;MAC7C,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,EAAE;QACVP,SAAS,CAACQ,GAAG,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,CAAA;AACzC,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;;AAEA;EACA,IAAIC,OAAO,GAAG,EAAE,CAAA;AAEhB,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,OAAO,IAAI,8CAA8C,CAAA;AAC7D,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACxBD,IAAAA,OAAO,IAAI,gDAAgD,CAAA;AAC/D,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,OAAO,IAAI,8CAA8C,CAAA;AAC7D,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,IAAI,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,KAAK,CAAC,EAAE;AAC7CD,IAAAA,OAAO,IAAI,wDAAwD,CAAA;AACvE,GAAA;AACA,EAAA,IAAIV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,EAAE;AACjDD,IAAAA,OAAO,IAAI,8CAA8C,CAAA;AAC7D,GAAA;EAEA,oBACIE,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,YAAY;AAAAC,IAAAA,QAAA,EAClB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA,EAAEL,OAAO,CAAA;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAA,EAAyDV,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,GAAG,CAAA;AAC3G;AACA;AACA;AACA,aAAc,CAAA,GAAG,EAAE,CAAGX,EAAAA,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,GAAG,CAAA;AAC/C;AACA;AACA;AACA,aAAA,CAAc,GAAG,EAAE,CAAA,EAAGX,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,GAAG,CAAA;AACxE;AACA;AACA;AACA,aAAA,CAAc,GAAG,EAAE,CAAA,EAAGX,SAAS,CAACW,GAAG,CAAC,IAAI,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,KAAK,CAAC,GAAG,CAAA;AACpE;AACA;AACA;AACA,aAAA,CAAc,GAAG,EAAE,CAAA,EAAGX,SAAS,CAACW,GAAG,CAAC,MAAM,CAAC,IAAIX,SAAS,CAACW,GAAG,CAAC,OAAO,CAAC,GAAG,CAAA;AACxE;AACA;AACA;AACA,aAAA,CAAc,GAAG,EAAE,CAAA;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}