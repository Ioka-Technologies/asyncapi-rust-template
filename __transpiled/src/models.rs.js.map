{"version":3,"file":"models.rs.js","sources":["../../template/src/models.rs.js"],"sourcesContent":["export default function ModelsRs({ asyncapi }) {\n    // Helper functions for Rust identifier generation\n    function toRustIdentifier(str) {\n        if (!str) return 'unknown';\n        let identifier = str\n            .replace(/[^a-zA-Z0-9_]/g, '_')\n            .replace(/^[0-9]/, '_$&')\n            .replace(/_+/g, '_')\n            .replace(/^_+|_+$/g, '');\n        if (/^[0-9]/.test(identifier)) {\n            identifier = 'item_' + identifier;\n        }\n        if (!identifier) {\n            identifier = 'unknown';\n        }\n        const rustKeywords = [\n            'as', 'break', 'const', 'continue', 'crate', 'else', 'enum', 'extern',\n            'false', 'fn', 'for', 'if', 'impl', 'in', 'let', 'loop', 'match',\n            'mod', 'move', 'mut', 'pub', 'ref', 'return', 'self', 'Self',\n            'static', 'struct', 'super', 'trait', 'true', 'type', 'unsafe',\n            'use', 'where', 'while', 'async', 'await', 'dyn'\n        ];\n        if (rustKeywords.includes(identifier)) {\n            identifier = identifier + '_';\n        }\n        return identifier;\n    }\n\n    function toRustTypeName(str) {\n        if (!str) return 'Unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .split('_')\n            .map(part => part.charAt(0).toUpperCase() + part.slice(1).toLowerCase())\n            .join('');\n    }\n\n    function toRustFieldName(str) {\n        if (!str) return 'unknown';\n        const identifier = toRustIdentifier(str);\n        return identifier\n            .replace(/([A-Z])/g, '_$1')\n            .toLowerCase()\n            .replace(/^_/, '')\n            .replace(/_+/g, '_');\n    }\n    // Extract message schemas\n    const components = asyncapi.components();\n    const messageSchemas = [];\n    const messageTypes = new Set();\n\n    if (components && components.messages) {\n        const messages = components.messages();\n        if (messages) {\n            Object.entries(messages).forEach(([name, message]) => {\n                let payload = null;\n                try {\n                    if (message.payload && typeof message.payload === 'function') {\n                        const payloadSchema = message.payload();\n                        payload = payloadSchema && payloadSchema.json ? payloadSchema.json() : null;\n                    }\n                } catch (e) {\n                    // Ignore payload extraction errors\n                }\n\n                messageSchemas.push({\n                    name,\n                    rustName: toRustTypeName(name),\n                    payload,\n                    description: message.description && typeof message.description === 'function' ? message.description() : null\n                });\n                messageTypes.add(name);\n            });\n        }\n    }\n\n    // Helper function to convert JSON schema to Rust type\n    function jsonSchemaToRustType(schema) {\n        if (!schema || !schema.type) return 'serde_json::Value';\n\n        switch (schema.type) {\n        case 'string':\n            if (schema.format === 'date-time') return 'chrono::DateTime<chrono::Utc>';\n            if (schema.format === 'uuid') return 'uuid::Uuid';\n            return 'String';\n        case 'integer':\n            return schema.format === 'int64' ? 'i64' : 'i32';\n        case 'number':\n            return 'f64';\n        case 'boolean':\n            return 'bool';\n        case 'array': {\n            const itemType = jsonSchemaToRustType(schema.items);\n            return `Vec<${itemType}>`;\n        }\n        case 'object':\n            return 'serde_json::Value'; // For complex objects, use generic JSON\n        default:\n            return 'serde_json::Value';\n        }\n    }\n\n    // Generate message structs\n    function generateMessageStruct(schema) {\n        if (!schema || !schema.properties) {\n            return '    pub data: serde_json::Value,';\n        }\n\n        const fields = Object.entries(schema.properties).map(([fieldName, fieldSchema]) => {\n            const rustType = jsonSchemaToRustType(fieldSchema);\n            const optional = !schema.required || !schema.required.includes(fieldName);\n            const finalType = optional ? `Option<${rustType}>` : rustType;\n            const rustFieldName = toRustFieldName(fieldName);\n            return `    pub ${rustFieldName}: ${finalType},`;\n        }).join('\\n');\n\n        return fields;\n    }\n\n    return (\n        <File name=\"models.rs\">\n            {`//! Message models generated from AsyncAPI specification\n\nuse serde::{Deserialize, Serialize};\nuse uuid::Uuid;\nuse chrono::{DateTime, Utc};\n\n/// Base trait for all AsyncAPI messages\npub trait AsyncApiMessage {\n    fn message_type(&self) -> &'static str;\n    fn channel(&self) -> &'static str;\n}\n\n${messageSchemas.map(schema => `\n/// ${schema.description || `Message type: ${schema.name}`}\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ${schema.rustName} {\n${generateMessageStruct(schema.payload)}\n}\n\nimpl AsyncApiMessage for ${schema.rustName} {\n    fn message_type(&self) -> &'static str {\n        \"${schema.name}\"\n    }\n\n    fn channel(&self) -> &'static str {\n        // TODO: Map to appropriate channel based on your AsyncAPI spec\n        \"default\"\n    }\n}`).join('\\n')}\n\n${messageTypes.size === 0 ? `\n/// Example message structure when no messages are defined in the spec\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ExampleMessage {\n    pub id: String,\n    pub content: String,\n    pub timestamp: DateTime<Utc>,\n}\n\nimpl AsyncApiMessage for ExampleMessage {\n    fn message_type(&self) -> &'static str {\n        \"example\"\n    }\n\n    fn channel(&self) -> &'static str {\n        \"example/channel\"\n    }\n}` : ''}\n`}\n        </File>\n    );\n}\n"],"names":["ModelsRs","asyncapi","toRustIdentifier","str","identifier","replace","test","rustKeywords","includes","toRustTypeName","split","map","part","charAt","toUpperCase","slice","toLowerCase","join","toRustFieldName","components","messageSchemas","messageTypes","Set","messages","Object","entries","forEach","name","message","payload","payloadSchema","json","e","push","rustName","description","add","jsonSchemaToRustType","schema","type","format","itemType","items","generateMessageStruct","properties","fields","fieldName","fieldSchema","rustType","optional","required","finalType","rustFieldName","_jsx","File","children","size"],"mappings":"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"}