{"version":3,"file":"router.rs.js","sources":["../../template/src/router.rs.js"],"sourcesContent":["/* eslint-disable no-useless-escape */\nexport default function RouterRs({ asyncapi }) {\n    // Extract channels and operations for route generation\n    const channels = asyncapi.channels();\n    const channelData = [];\n\n    if (channels) {\n        Object.entries(channels).forEach(([channelName, channel]) => {\n            const operations = channel.operations && channel.operations();\n            const channelOps = [];\n\n            if (operations) {\n                Object.entries(operations).forEach(([opName, operation]) => {\n                    const action = operation.action && operation.action();\n                    channelOps.push({\n                        name: opName,\n                        action,\n                        channel: channelName\n                    });\n                });\n            }\n\n            channelData.push({\n                name: channelName,\n                operations: channelOps\n            });\n        });\n    }\n\n    return (\n        <File name=\"router.rs\">\n            {`//! Advanced routing system for AsyncAPI applications\n//!\n//! This module provides:\n//! - Pattern-based routing with wildcards and parameters\n//! - Content-based message routing\n//! - Route guards and middleware chains\n//! - Dynamic route registration and modification\n//! - Performance-optimized route matching\n\nuse crate::context::{RequestContext, RequestPriority};\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse crate::handlers::HandlerRegistry;\nuse crate::middleware::{Middleware, MiddlewarePipeline};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse regex::Regex;\nuse serde::{Deserialize, Serialize};\nuse tracing::{info, warn, error, debug, instrument};\nuse std::time::{Duration, Instant};\nuse uuid::Uuid;\n\n/// Advanced router for message routing with pattern matching and content-based routing\n#[derive(Debug)]\npub struct Router {\n    /// Static routes for exact matches\n    static_routes: Arc<RwLock<HashMap<String, Route>>>,\n    /// Pattern routes for wildcard and parameter matching\n    pattern_routes: Arc<RwLock<Vec<PatternRoute>>>,\n    /// Content-based routes that examine message payload\n    content_routes: Arc<RwLock<Vec<ContentRoute>>>,\n    /// Default route for unmatched messages\n    default_route: Arc<RwLock<Option<Route>>>,\n    /// Route performance metrics\n    metrics: Arc<RwLock<RouterMetrics>>,\n    /// Route cache for performance optimization\n    route_cache: Arc<RwLock<HashMap<String, CachedRoute>>>,\n    /// Maximum cache size\n    max_cache_size: usize,\n}\n\nimpl Router {\n    /// Create a new router instance\n    pub fn new() -> Self {\n        Self {\n            static_routes: Arc::new(RwLock::new(HashMap::new())),\n            pattern_routes: Arc::new(RwLock::new(Vec::new())),\n            content_routes: Arc::new(RwLock::new(Vec::new())),\n            default_route: Arc::new(RwLock::new(None)),\n            metrics: Arc::new(RwLock::new(RouterMetrics::new())),\n            route_cache: Arc::new(RwLock::new(HashMap::new())),\n            max_cache_size: 1000,\n        }\n    }\n\n    /// Create router with custom cache size\n    pub fn with_cache_size(cache_size: usize) -> Self {\n        let mut router = Self::new();\n        router.max_cache_size = cache_size;\n        router\n    }\n\n    /// Add a static route for exact channel/operation matching\n    #[instrument(skip(self, route), fields(channel = %route.channel, operation = %route.operation))]\n    pub async fn add_static_route(&self, route: Route) -> AsyncApiResult<()> {\n        let route_key = format!(\"{}:{}\", route.channel, route.operation);\n\n        debug!(\n            channel = %route.channel,\n            operation = %route.operation,\n            priority = ?route.priority,\n            \"Adding static route\"\n        );\n\n        let mut routes = self.static_routes.write().await;\n        routes.insert(route_key, route);\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Add a pattern route for wildcard and parameter matching\n    #[instrument(skip(self, pattern_route), fields(pattern = %pattern_route.pattern))]\n    pub async fn add_pattern_route(&self, pattern_route: PatternRoute) -> AsyncApiResult<()> {\n        debug!(\n            pattern = %pattern_route.pattern,\n            priority = ?pattern_route.route.priority,\n            \"Adding pattern route\"\n        );\n\n        let mut routes = self.pattern_routes.write().await;\n        routes.push(pattern_route);\n\n        // Sort by priority (higher priority first)\n        routes.sort_by(|a, b| b.route.priority.cmp(&a.route.priority));\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Add a content-based route that examines message payload\n    #[instrument(skip(self, content_route), fields(name = %content_route.name))]\n    pub async fn add_content_route(&self, content_route: ContentRoute) -> AsyncApiResult<()> {\n        debug!(\n            name = %content_route.name,\n            priority = ?content_route.route.priority,\n            \"Adding content-based route\"\n        );\n\n        let mut routes = self.content_routes.write().await;\n        routes.push(content_route);\n\n        // Sort by priority (higher priority first)\n        routes.sort_by(|a, b| b.route.priority.cmp(&a.route.priority));\n\n        // Clear cache when routes change\n        self.clear_cache().await;\n\n        Ok(())\n    }\n\n    /// Set the default route for unmatched messages\n    pub async fn set_default_route(&self, route: Route) -> AsyncApiResult<()> {\n        debug!(\n            channel = %route.channel,\n            operation = %route.operation,\n            \"Setting default route\"\n        );\n\n        let mut default_route = self.default_route.write().await;\n        *default_route = Some(route);\n\n        Ok(())\n    }\n\n    /// Route a message to the appropriate handler\n    #[instrument(skip(self, payload, context), fields(\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    pub async fn route_message(\n        &self,\n        context: &RequestContext,\n        payload: &[u8],\n        handlers: &HandlerRegistry,\n    ) -> AsyncApiResult<RouteResult> {\n        let start_time = Instant::now();\n        let route_key = format!(\"{}:{}\", context.channel, context.operation);\n\n        // Check cache first\n        if let Some(cached_route) = self.get_cached_route(&route_key).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                route_key = %route_key,\n                \"Using cached route\"\n            );\n\n            let result = self.execute_route(&cached_route.route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::CacheHit, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try static routes first (fastest)\n        if let Some(route) = self.find_static_route(&context.channel, &context.operation).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Found static route match\"\n            );\n\n            self.cache_route(route_key.clone(), route.clone()).await;\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::StaticMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try pattern routes\n        if let Some((route, params)) = self.find_pattern_route(&context.channel, &context.operation).await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                params = ?params,\n                \"Found pattern route match\"\n            );\n\n            // Add route parameters to context\n            for (key, value) in params {\n                context.set_data(&format!(\"route_param_{}\", key), value).await?;\n            }\n\n            self.cache_route(route_key.clone(), route.clone()).await;\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::PatternMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Try content-based routes\n        if let Some(route) = self.find_content_route(payload, context).await? {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Found content-based route match\"\n            );\n\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::ContentMatch, start_time.elapsed()).await;\n            return result;\n        }\n\n        // Use default route if available\n        if let Some(route) = self.get_default_route().await {\n            debug!(\n                correlation_id = %context.correlation_id,\n                \"Using default route\"\n            );\n\n            let result = self.execute_route(&route, context, payload, handlers).await;\n            self.record_route_metric(RouteMetric::DefaultRoute, start_time.elapsed()).await;\n            return result;\n        }\n\n        // No route found\n        self.record_route_metric(RouteMetric::NoMatch, start_time.elapsed()).await;\n\n        error!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            \"No route found for message\"\n        );\n\n        Err(AsyncApiError::Router {\n            message: format!(\"No route found for channel '{}' operation '{}'\", context.channel, context.operation),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Routing,\n                false,\n            ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n             .with_context(\"channel\", &context.channel)\n             .with_context(\"operation\", &context.operation),\n            source: None,\n        })\n    }\n\n    /// Execute a route with its middleware chain and guards\n    async fn execute_route(\n        &self,\n        route: &Route,\n        context: &RequestContext,\n        payload: &[u8],\n        handlers: &HandlerRegistry,\n    ) -> AsyncApiResult<RouteResult> {\n        // Check route guards\n        for guard in &route.guards {\n            if !(guard.check)(context, payload).await? {\n                return Err(AsyncApiError::Router {\n                    message: format!(\"Route guard '{}' failed\", guard.name),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Authorization,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"guard_name\", &guard.name)\n                     .with_context(\"channel\", &context.channel)\n                     .with_context(\"operation\", &context.operation),\n                    source: None,\n                });\n            }\n        }\n\n        // Process through route middleware\n        let processed_payload = if let Some(ref middleware) = route.middleware {\n            // Convert RequestContext to MiddlewareContext\n            let middleware_context = crate::middleware::MiddlewareContext {\n                correlation_id: context.correlation_id,\n                channel: context.channel.clone(),\n                operation: context.operation.clone(),\n                timestamp: chrono::DateTime::from(context.timestamp),\n                metadata: context.metadata.clone(),\n            };\n            middleware.process_inbound(&middleware_context, payload).await?\n        } else {\n            payload.to_vec()\n        };\n\n        // Route to handler\n        let result = match &route.destination {\n            RouteDestination::Handler { channel, operation } => {\n                handlers.route_message(channel, operation, &processed_payload).await?;\n                RouteResult::Handled\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                let mut results = Vec::new();\n                for dest in destinations {\n                    match handlers.route_message(&dest.channel, &dest.operation, &processed_payload).await {\n                        Ok(()) => results.push(dest.clone()),\n                        Err(e) => {\n                            warn!(\n                                correlation_id = %context.correlation_id,\n                                channel = %dest.channel,\n                                operation = %dest.operation,\n                                error = %e,\n                                \"Failed to route to one of multiple destinations\"\n                            );\n                        }\n                    }\n                }\n                RouteResult::MultipleHandled(results)\n            }\n            RouteDestination::Custom { handler } => {\n                handler(context, &processed_payload).await?;\n                RouteResult::CustomHandled\n            }\n        };\n\n        Ok(result)\n    }\n\n    /// Find static route\n    async fn find_static_route(&self, channel: &str, operation: &str) -> Option<Route> {\n        let routes = self.static_routes.read().await;\n        let route_key = format!(\"{}:{}\", channel, operation);\n        routes.get(&route_key).cloned()\n    }\n\n    /// Find pattern route with parameter extraction\n    async fn find_pattern_route(&self, channel: &str, operation: &str) -> Option<(Route, HashMap<String, String>)> {\n        let routes = self.pattern_routes.read().await;\n        let route_path = format!(\"{}:{}\", channel, operation);\n\n        for pattern_route in routes.iter() {\n            if let Some(captures) = pattern_route.regex.captures(&route_path) {\n                let mut params = HashMap::new();\n\n                // Extract named parameters\n                for name in pattern_route.regex.capture_names().flatten() {\n                    if let Some(value) = captures.name(name) {\n                        params.insert(name.to_string(), value.as_str().to_string());\n                    }\n                }\n\n                return Some((pattern_route.route.clone(), params));\n            }\n        }\n\n        None\n    }\n\n    /// Find content-based route\n    async fn find_content_route(&self, payload: &[u8], context: &RequestContext) -> AsyncApiResult<Option<Route>> {\n        let routes = self.content_routes.read().await;\n\n        for content_route in routes.iter() {\n            if content_route.matcher.matches(payload, context).await? {\n                return Ok(Some(content_route.route.clone()));\n            }\n        }\n\n        Ok(None)\n    }\n\n    /// Get default route\n    async fn get_default_route(&self) -> Option<Route> {\n        self.default_route.read().await.clone()\n    }\n\n    /// Cache a route for performance\n    async fn cache_route(&self, key: String, route: Route) {\n        let mut cache = self.route_cache.write().await;\n\n        // Implement LRU eviction if cache is full\n        if cache.len() >= self.max_cache_size {\n            // Remove oldest entry (simple implementation)\n            if let Some(oldest_key) = cache.keys().next().cloned() {\n                cache.remove(&oldest_key);\n            }\n        }\n\n        cache.insert(key, CachedRoute {\n            route,\n            cached_at: Instant::now(),\n        });\n    }\n\n    /// Get cached route\n    async fn get_cached_route(&self, key: &str) -> Option<CachedRoute> {\n        let cache = self.route_cache.read().await;\n        cache.get(key).cloned()\n    }\n\n    /// Clear route cache\n    async fn clear_cache(&self) {\n        let mut cache = self.route_cache.write().await;\n        cache.clear();\n        debug!(\"Route cache cleared\");\n    }\n\n    /// Record route performance metric\n    async fn record_route_metric(&self, metric_type: RouteMetric, duration: Duration) {\n        let mut metrics = self.metrics.write().await;\n        metrics.record_metric(metric_type, duration);\n    }\n\n    /// Get router statistics\n    pub async fn get_statistics(&self) -> RouterStatistics {\n        let metrics = self.metrics.read().await;\n        let static_routes = self.static_routes.read().await;\n        let pattern_routes = self.pattern_routes.read().await;\n        let content_routes = self.content_routes.read().await;\n        let cache = self.route_cache.read().await;\n\n        RouterStatistics {\n            static_route_count: static_routes.len(),\n            pattern_route_count: pattern_routes.len(),\n            content_route_count: content_routes.len(),\n            cache_size: cache.len(),\n            cache_hit_rate: metrics.cache_hit_rate(),\n            average_route_time: metrics.average_route_time(),\n            total_routes: metrics.total_routes,\n        }\n    }\n\n    /// Initialize with default routes from AsyncAPI specification\n    pub async fn initialize_default_routes(&self) -> AsyncApiResult<()> {\n        info!(\"Initializing default routes from AsyncAPI specification\");\n\n        ${channelData.map(channel => `\n        // Routes for ${channel.name}\n        ${channel.operations.map(op => `\n        self.add_static_route(Route {\n            channel: \"${channel.name}\".to_string(),\n            operation: \"${op.name}\".to_string(),\n            priority: RequestPriority::Normal,\n            destination: RouteDestination::Handler {\n                channel: \"${channel.name}\".to_string(),\n                operation: \"${op.name}\".to_string(),\n            },\n            guards: Vec::new(),\n            middleware: None,\n            metadata: HashMap::new(),\n        }).await?;`).join('\\n        ')}\n        `).join('\\n')}\n\n        // Add pattern routes for common patterns\n        self.add_pattern_route(PatternRoute {\n            pattern: r\"(?P<channel>[^:]+):(?P<operation>.+)\".to_string(),\n            regex: Regex::new(r\"(?P<channel>[^:]+):(?P<operation>.+)\").unwrap(),\n            route: Route {\n                channel: \"dynamic\".to_string(),\n                operation: \"dynamic\".to_string(),\n                priority: RequestPriority::Low,\n                destination: RouteDestination::Handler {\n                    channel: \"dynamic\".to_string(),\n                    operation: \"dynamic\".to_string(),\n                },\n                guards: Vec::new(),\n                middleware: None,\n                metadata: HashMap::new(),\n            },\n        }).await?;\n\n        info!(\"Default routes initialized successfully\");\n        Ok(())\n    }\n}\n\nimpl Default for Router {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Individual route definition\npub struct Route {\n    /// Channel pattern\n    pub channel: String,\n    /// Operation pattern\n    pub operation: String,\n    /// Route priority for conflict resolution\n    pub priority: RequestPriority,\n    /// Route destination\n    pub destination: RouteDestination,\n    /// Route guards for validation\n    pub guards: Vec<RouteGuard>,\n    /// Route-specific middleware\n    pub middleware: Option<MiddlewarePipeline>,\n    /// Route metadata\n    pub metadata: HashMap<String, String>,\n}\n\nimpl std::fmt::Debug for Route {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"Route\")\n            .field(\"channel\", &self.channel)\n            .field(\"operation\", &self.operation)\n            .field(\"priority\", &self.priority)\n            .field(\"destination\", &self.destination)\n            .field(\"guards\", &self.guards)\n            .field(\"middleware\", &self.middleware.is_some())\n            .field(\"metadata\", &self.metadata)\n            .finish()\n    }\n}\n\nimpl Clone for Route {\n    fn clone(&self) -> Self {\n        Self {\n            channel: self.channel.clone(),\n            operation: self.operation.clone(),\n            priority: self.priority,\n            destination: self.destination.clone(),\n            guards: self.guards.clone(),\n            middleware: None, // Can't clone MiddlewarePipeline, so set to None\n            metadata: self.metadata.clone(),\n        }\n    }\n}\n\n/// Route destination types\npub enum RouteDestination {\n    /// Route to a specific handler\n    Handler { channel: String, operation: String },\n    /// Route to multiple handlers (fan-out)\n    MultipleHandlers { destinations: Vec<HandlerDestination> },\n    /// Route to a custom function\n    Custom {\n        #[allow(clippy::type_complexity)]\n        handler: Arc<dyn Fn(&RequestContext, &[u8]) -> std::pin::Pin<Box<dyn std::future::Future<Output = AsyncApiResult<()>> + Send>> + Send + Sync>\n    },\n}\n\nimpl std::fmt::Debug for RouteDestination {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        match self {\n            RouteDestination::Handler { channel, operation } => {\n                f.debug_struct(\"Handler\")\n                    .field(\"channel\", channel)\n                    .field(\"operation\", operation)\n                    .finish()\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                f.debug_struct(\"MultipleHandlers\")\n                    .field(\"destinations\", destinations)\n                    .finish()\n            }\n            RouteDestination::Custom { .. } => {\n                f.debug_struct(\"Custom\")\n                    .field(\"handler\", &\"<function>\")\n                    .finish()\n            }\n        }\n    }\n}\n\nimpl Clone for RouteDestination {\n    fn clone(&self) -> Self {\n        match self {\n            RouteDestination::Handler { channel, operation } => {\n                RouteDestination::Handler {\n                    channel: channel.clone(),\n                    operation: operation.clone(),\n                }\n            }\n            RouteDestination::MultipleHandlers { destinations } => {\n                RouteDestination::MultipleHandlers {\n                    destinations: destinations.clone(),\n                }\n            }\n            RouteDestination::Custom { handler } => {\n                RouteDestination::Custom {\n                    handler: handler.clone(),\n                }\n            }\n        }\n    }\n}\n\n/// Handler destination for multi-routing\n#[derive(Debug, Clone)]\npub struct HandlerDestination {\n    pub channel: String,\n    pub operation: String,\n}\n\n/// Pattern-based route with regex matching\n#[derive(Debug)]\npub struct PatternRoute {\n    /// Original pattern string\n    pub pattern: String,\n    /// Compiled regex for matching\n    pub regex: Regex,\n    /// Route definition\n    pub route: Route,\n}\n\n/// Content-based route that examines message payload\n#[derive(Debug)]\npub struct ContentRoute {\n    /// Route name for identification\n    pub name: String,\n    /// Content matcher\n    pub matcher: Box<dyn ContentMatcher + Send + Sync>,\n    /// Route definition\n    pub route: Route,\n}\n\n/// Trait for content-based routing\n#[async_trait::async_trait]\npub trait ContentMatcher: std::fmt::Debug {\n    /// Check if the content matches this route\n    async fn matches(&self, payload: &[u8], context: &RequestContext) -> AsyncApiResult<bool>;\n}\n\n/// JSON field matcher for content-based routing\n#[derive(Debug)]\npub struct JsonFieldMatcher {\n    pub field_path: String,\n    pub expected_value: serde_json::Value,\n}\n\n#[async_trait::async_trait]\nimpl ContentMatcher for JsonFieldMatcher {\n    async fn matches(&self, payload: &[u8], _context: &RequestContext) -> AsyncApiResult<bool> {\n        match serde_json::from_slice::<serde_json::Value>(payload) {\n            Ok(json) => {\n                let field_value = json.pointer(&self.field_path);\n                Ok(field_value == Some(&self.expected_value))\n            }\n            Err(_) => Ok(false), // Not JSON, doesn't match\n        }\n    }\n}\n\n/// Route guard for pre-routing validation\npub struct RouteGuard {\n    pub name: String,\n    #[allow(clippy::type_complexity)]\n    pub check: Arc<dyn Fn(&RequestContext, &[u8]) -> std::pin::Pin<Box<dyn std::future::Future<Output = AsyncApiResult<bool>> + Send>> + Send + Sync>,\n}\n\nimpl std::fmt::Debug for RouteGuard {\n    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n        f.debug_struct(\"RouteGuard\")\n            .field(\"name\", &self.name)\n            .field(\"check\", &\"<function>\")\n            .finish()\n    }\n}\n\nimpl Clone for RouteGuard {\n    fn clone(&self) -> Self {\n        Self {\n            name: self.name.clone(),\n            check: self.check.clone(),\n        }\n    }\n}\n\n/// Cached route entry\n#[derive(Debug, Clone)]\npub struct CachedRoute {\n    pub route: Route,\n    pub cached_at: Instant,\n}\n\n/// Route execution result\n#[derive(Debug)]\npub enum RouteResult {\n    /// Message was handled by a single handler\n    Handled,\n    /// Message was handled by multiple handlers\n    MultipleHandled(Vec<HandlerDestination>),\n    /// Message was handled by a custom handler\n    CustomHandled,\n}\n\n/// Router performance metrics\n#[derive(Debug)]\npub struct RouterMetrics {\n    pub total_routes: u64,\n    pub cache_hits: u64,\n    pub cache_misses: u64,\n    pub static_matches: u64,\n    pub pattern_matches: u64,\n    pub content_matches: u64,\n    pub default_routes: u64,\n    pub no_matches: u64,\n    pub route_times: Vec<Duration>,\n}\n\nimpl RouterMetrics {\n    pub fn new() -> Self {\n        Self {\n            total_routes: 0,\n            cache_hits: 0,\n            cache_misses: 0,\n            static_matches: 0,\n            pattern_matches: 0,\n            content_matches: 0,\n            default_routes: 0,\n            no_matches: 0,\n            route_times: Vec::new(),\n        }\n    }\n\n    pub fn record_metric(&mut self, metric_type: RouteMetric, duration: Duration) {\n        self.total_routes += 1;\n        self.route_times.push(duration);\n\n        // Keep only last 1000 measurements\n        if self.route_times.len() > 1000 {\n            self.route_times.remove(0);\n        }\n\n        match metric_type {\n            RouteMetric::CacheHit => self.cache_hits += 1,\n            RouteMetric::CacheMiss => self.cache_misses += 1,\n            RouteMetric::StaticMatch => self.static_matches += 1,\n            RouteMetric::PatternMatch => self.pattern_matches += 1,\n            RouteMetric::ContentMatch => self.content_matches += 1,\n            RouteMetric::DefaultRoute => self.default_routes += 1,\n            RouteMetric::NoMatch => self.no_matches += 1,\n        }\n    }\n\n    pub fn cache_hit_rate(&self) -> f64 {\n        let total_cache_attempts = self.cache_hits + self.cache_misses;\n        if total_cache_attempts > 0 {\n            self.cache_hits as f64 / total_cache_attempts as f64\n        } else {\n            0.0\n        }\n    }\n\n    pub fn average_route_time(&self) -> Duration {\n        if self.route_times.is_empty() {\n            Duration::ZERO\n        } else {\n            let total: Duration = self.route_times.iter().sum();\n            total / self.route_times.len() as u32\n        }\n    }\n}\n\n/// Route metric types\n#[derive(Debug, Clone, Copy)]\npub enum RouteMetric {\n    CacheHit,\n    CacheMiss,\n    StaticMatch,\n    PatternMatch,\n    ContentMatch,\n    DefaultRoute,\n    NoMatch,\n}\n\n/// Router statistics for monitoring\n#[derive(Debug, Clone, Serialize)]\npub struct RouterStatistics {\n    pub static_route_count: usize,\n    pub pattern_route_count: usize,\n    pub content_route_count: usize,\n    pub cache_size: usize,\n    pub cache_hit_rate: f64,\n    pub average_route_time: Duration,\n    pub total_routes: u64,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_static_route_matching() {\n        let router = Router::new();\n\n        let route = Route {\n            channel: \"test/channel\".to_string(),\n            operation: \"test_operation\".to_string(),\n            priority: RequestPriority::Normal,\n            destination: RouteDestination::Handler {\n                channel: \"test/channel\".to_string(),\n                operation: \"test_operation\".to_string(),\n            },\n            guards: Vec::new(),\n            middleware: None,\n            metadata: HashMap::new(),\n        };\n\n        router.add_static_route(route).await.unwrap();\n\n        let found_route = router.find_static_route(\"test/channel\", \"test_operation\").await;\n        assert!(found_route.is_some());\n    }\n\n    #[tokio::test]\n    async fn test_pattern_route_matching() {\n        let router = Router::new();\n\n        let pattern_route = PatternRoute {\n            pattern: r\"user/(?P<user_id>\\d+):update\".to_string(),\n            regex: Regex::new(r\"user/(?P<user_id>\\d+):update\").unwrap(),\n            route: Route {\n                channel: \"user\".to_string(),\n                operation: \"update\".to_string(),\n                priority: RequestPriority::Normal,\n                destination: RouteDestination::Handler {\n                    channel: \"user\".to_string(),\n                    operation: \"update\".to_string(),\n                },\n                guards: Vec::new(),\n                middleware: None,\n                metadata: HashMap::new(),\n            },\n        };\n\n        router.add_pattern_route(pattern_route).await.unwrap();\n\n        let (route, params) = router.find_pattern_route(\"user/123\", \"update\").await.unwrap();\n        assert_eq!(route.channel, \"user\");\n        assert_eq!(params.get(\"user_id\"), Some(&\"123\".to_string()));\n    }\n\n    #[test]\n    fn test_json_field_matcher() {\n        let matcher = JsonFieldMatcher {\n            field_path: \"/type\".to_string(),\n            expected_value: serde_json::Value::String(\"user_created\".to_string()),\n        };\n\n        let payload = r#\"{\"type\": \"user_created\", \"user_id\": 123}\"#.as_bytes();\n        // Note: This would need to be an async test in practice\n        // assert!(matcher.matches(payload, &context).await.unwrap());\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["RouterRs","asyncapi","channels","channelData","Object","entries","forEach","channelName","channel","operations","channelOps","opName","operation","action","push","name","_jsx","File","children","map","op","join"],"mappings":";;;;;AAAA;AACe,SAASA,QAAQA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAC3C;AACA,EAAA,MAAMC,QAAQ,GAAGD,QAAQ,CAACC,QAAQ,EAAE,CAAA;EACpC,MAAMC,WAAW,GAAG,EAAE,CAAA;AAEtB,EAAA,IAAID,QAAQ,EAAE;AACVE,IAAAA,MAAM,CAACC,OAAO,CAACH,QAAQ,CAAC,CAACI,OAAO,CAAC,CAAC,CAACC,WAAW,EAAEC,OAAO,CAAC,KAAK;MACzD,MAAMC,UAAU,GAAGD,OAAO,CAACC,UAAU,IAAID,OAAO,CAACC,UAAU,EAAE,CAAA;MAC7D,MAAMC,UAAU,GAAG,EAAE,CAAA;AAErB,MAAA,IAAID,UAAU,EAAE;AACZL,QAAAA,MAAM,CAACC,OAAO,CAACI,UAAU,CAAC,CAACH,OAAO,CAAC,CAAC,CAACK,MAAM,EAAEC,SAAS,CAAC,KAAK;UACxD,MAAMC,MAAM,GAAGD,SAAS,CAACC,MAAM,IAAID,SAAS,CAACC,MAAM,EAAE,CAAA;UACrDH,UAAU,CAACI,IAAI,CAAC;AACZC,YAAAA,IAAI,EAAEJ,MAAM;YACZE,MAAM;AACNL,YAAAA,OAAO,EAAED,WAAAA;AACb,WAAC,CAAC,CAAA;AACN,SAAC,CAAC,CAAA;AACN,OAAA;MAEAJ,WAAW,CAACW,IAAI,CAAC;AACbC,QAAAA,IAAI,EAAER,WAAW;AACjBE,QAAAA,UAAU,EAAEC,UAAAA;AAChB,OAAC,CAAC,CAAA;AACN,KAAC,CAAC,CAAA;AACN,GAAA;EAEA,oBACIM,cAAA,CAACC,IAAI,EAAA;AAACF,IAAAA,IAAI,EAAC,WAAW;AAAAG,IAAAA,QAAA,EACjB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAA,EAAUf,WAAW,CAACgB,GAAG,CAACX,OAAO,IAAI,CAAA;AACrC,sBAAwBA,EAAAA,OAAO,CAACO,IAAI,CAAA;AACpC,QAAA,EAAUP,OAAO,CAACC,UAAU,CAACU,GAAG,CAACC,EAAE,IAAI,CAAA;AACvC;AACA,sBAAwBZ,EAAAA,OAAO,CAACO,IAAI,CAAA;AACpC,wBAA0BK,EAAAA,EAAE,CAACL,IAAI,CAAA;AACjC;AACA;AACA,0BAA4BP,EAAAA,OAAO,CAACO,IAAI,CAAA;AACxC,4BAA8BK,EAAAA,EAAE,CAACL,IAAI,CAAA;AACrC;AACA;AACA;AACA;AACA,kBAAA,CAAmB,CAAC,CAACM,IAAI,CAAC,YAAY,CAAC,CAAA;AACvC,QAAA,CAAS,CAAC,CAACA,IAAI,CAAC,IAAI,CAAC,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}