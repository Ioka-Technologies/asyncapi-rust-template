{"version":3,"file":"context.rs.js","sources":["../../template/src/context.rs.js"],"sourcesContent":["export default function ContextRs() {\n    return (\n        <File name=\"context.rs\">\n            {`//! Advanced context management system for AsyncAPI applications\n//!\n//! This module provides:\n//! - Request-scoped context with automatic propagation\n//! - Thread-safe execution context for shared state\n//! - Context-aware error handling and enrichment\n//! - Performance metrics and tracing integration\n//! - Middleware data sharing and storage\n\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant, SystemTime, UNIX_EPOCH};\nuse tokio::sync::RwLock;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse tracing::{info, warn, error, debug, instrument, Span};\n\n/// Request-scoped context that carries data through the entire processing pipeline\n#[derive(Debug, Clone)]\npub struct RequestContext {\n    /// Unique correlation ID for request tracking\n    pub correlation_id: Uuid,\n    /// Request start time for performance tracking\n    pub start_time: Instant,\n    /// Request timestamp\n    pub timestamp: SystemTime,\n    /// Source channel/topic\n    pub channel: String,\n    /// Operation being performed\n    pub operation: String,\n    /// Request metadata and headers\n    pub metadata: HashMap<String, String>,\n    /// Custom data storage for middleware and handlers\n    pub data: Arc<RwLock<HashMap<String, ContextValue>>>,\n    /// Performance metrics\n    pub metrics: Arc<RwLock<RequestMetrics>>,\n    /// Tracing span for distributed tracing\n    pub span: Span,\n    /// Request priority (for routing and processing)\n    pub priority: RequestPriority,\n    /// Request tags for categorization\n    pub tags: Vec<String>,\n    /// Authentication claims (if authenticated)\n    #[cfg(feature = \"auth\")]\n    pub auth_claims: Option<crate::auth::Claims>,\n}\n\nimpl RequestContext {\n    /// Create a new request context\n    pub fn new(channel: &str, operation: &str) -> Self {\n        let correlation_id = Uuid::new_v4();\n        let span = tracing::info_span!(\n            \"request\",\n            correlation_id = %correlation_id,\n            channel = %channel,\n            operation = %operation\n        );\n\n        Self {\n            correlation_id,\n            start_time: Instant::now(),\n            timestamp: SystemTime::now(),\n            channel: channel.to_string(),\n            operation: operation.to_string(),\n            metadata: HashMap::new(),\n            data: Arc::new(RwLock::new(HashMap::new())),\n            metrics: Arc::new(RwLock::new(RequestMetrics::new())),\n            span,\n            priority: RequestPriority::Normal,\n            tags: Vec::new(),\n        }\n    }\n\n    /// Create context with custom correlation ID\n    pub fn with_correlation_id(channel: &str, operation: &str, correlation_id: Uuid) -> Self {\n        let mut ctx = Self::new(channel, operation);\n        ctx.correlation_id = correlation_id;\n        ctx\n    }\n\n    /// Add metadata to the context\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n\n    /// Set request priority\n    pub fn with_priority(mut self, priority: RequestPriority) -> Self {\n        self.priority = priority;\n        self\n    }\n\n    /// Add tags to the context\n    pub fn with_tags(mut self, tags: Vec<String>) -> Self {\n        self.tags = tags;\n        self\n    }\n\n    /// Store data in the context\n    pub async fn set_data<T: Into<ContextValue>>(&self, key: &str, value: T) -> AsyncApiResult<()> {\n        let mut data = self.data.write().await;\n        data.insert(key.to_string(), value.into());\n        debug!(\n            correlation_id = %self.correlation_id,\n            key = key,\n            \"Stored data in request context\"\n        );\n        Ok(())\n    }\n\n    /// Retrieve data from the context\n    pub async fn get_data(&self, key: &str) -> Option<ContextValue> {\n        let data = self.data.read().await;\n        data.get(key).cloned()\n    }\n\n    /// Get typed data from the context\n    pub async fn get_typed_data<T>(&self, key: &str) -> AsyncApiResult<Option<T>>\n    where\n        T: for<'de> Deserialize<'de>,\n    {\n        if let Some(value) = self.get_data(key).await {\n            match value {\n                ContextValue::Json(json_str) => {\n                    match serde_json::from_str::<T>(&json_str) {\n                        Ok(typed_value) => Ok(Some(typed_value)),\n                        Err(e) => Err(AsyncApiError::Context {\n                            message: format!(\"Failed to deserialize context data: {}\", e),\n                            context_key: key.to_string(),\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::Medium,\n                                ErrorCategory::Serialization,\n                                false,\n                            ).with_context(\"correlation_id\", &self.correlation_id.to_string()),\n                            source: Some(Box::new(e)),\n                        }),\n                    }\n                }\n                _ => Err(AsyncApiError::Context {\n                    message: \"Context value is not JSON serializable\".to_string(),\n                    context_key: key.to_string(),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Low,\n                        ErrorCategory::Validation,\n                        false,\n                    ).with_context(\"correlation_id\", &self.correlation_id.to_string()),\n                    source: None,\n                }),\n            }\n        } else {\n            Ok(None)\n        }\n    }\n\n    /// Record a metric event\n    pub async fn record_metric(&self, event: MetricEvent) {\n        let mut metrics = self.metrics.write().await;\n        metrics.record_event(event);\n    }\n\n    /// Get current metrics\n    pub async fn get_metrics(&self) -> RequestMetrics {\n        self.metrics.read().await.clone()\n    }\n\n    /// Get elapsed time since request start\n    pub fn elapsed(&self) -> Duration {\n        self.start_time.elapsed()\n    }\n\n    /// Create a child context for sub-operations\n    pub fn child_context(&self, operation: &str) -> Self {\n        let child_span = tracing::info_span!(\n            parent: &self.span,\n            \"child_operation\",\n            operation = %operation,\n            parent_correlation_id = %self.correlation_id\n        );\n\n        Self {\n            correlation_id: Uuid::new_v4(),\n            start_time: Instant::now(),\n            timestamp: SystemTime::now(),\n            channel: self.channel.clone(),\n            operation: operation.to_string(),\n            metadata: self.metadata.clone(),\n            data: self.data.clone(), // Share data with parent\n            metrics: Arc::new(RwLock::new(RequestMetrics::new())),\n            span: child_span,\n            priority: self.priority,\n            tags: self.tags.clone(),\n            #[cfg(feature = \"auth\")]\n            auth_claims: self.auth_claims.clone(),\n        }\n    }\n\n    /// Set authentication claims\n    #[cfg(feature = \"auth\")]\n    pub fn set_auth_claims(&mut self, claims: crate::auth::Claims) {\n        self.auth_claims = Some(claims);\n    }\n\n    /// Get authentication claims\n    #[cfg(feature = \"auth\")]\n    pub fn get_auth_claims(&self) -> Option<&crate::auth::Claims> {\n        self.auth_claims.as_ref()\n    }\n\n    /// Check if the request is authenticated\n    #[cfg(feature = \"auth\")]\n    pub fn is_authenticated(&self) -> bool {\n        self.auth_claims.is_some()\n    }\n\n    /// Get the authenticated user ID\n    #[cfg(feature = \"auth\")]\n    pub fn get_user_id(&self) -> Option<&str> {\n        self.auth_claims.as_ref().map(|claims| claims.sub.as_str())\n    }\n\n    /// Check if the authenticated user has a specific role\n    #[cfg(feature = \"auth\")]\n    pub fn has_role(&self, role: &str) -> bool {\n        self.auth_claims.as_ref()\n            .map(|claims| claims.has_role(role))\n            .unwrap_or(false)\n    }\n\n    /// Check if the authenticated user has a specific permission\n    #[cfg(feature = \"auth\")]\n    pub fn has_permission(&self, permission: &str) -> bool {\n        self.auth_claims.as_ref()\n            .map(|claims| claims.has_permission(permission))\n            .unwrap_or(false)\n    }\n\n    /// Get client ID for rate limiting and tracking\n    pub fn get_client_id(&self) -> Option<String> {\n        // Try to get from auth claims first\n        #[cfg(feature = \"auth\")]\n        if let Some(claims) = &self.auth_claims {\n            return Some(claims.sub.clone());\n        }\n\n        // Fall back to metadata\n        if let Some(client_id) = self.metadata.get(\"client_id\") {\n            return Some(client_id.clone());\n        }\n\n        // Fall back to IP address or other identifier\n        if let Some(ip) = self.metadata.get(\"remote_addr\") {\n            return Some(ip.clone());\n        }\n\n        None\n    }\n\n    /// Get header value\n    pub fn get_header(&self, name: &str) -> Option<&String> {\n        self.metadata.get(&format!(\"header_{}\", name.to_lowercase()))\n    }\n\n    /// Set header value\n    pub fn set_header(&mut self, name: &str, value: &str) {\n        self.metadata.insert(format!(\"header_{}\", name.to_lowercase()), value.to_string());\n    }\n\n    /// Get metadata value\n    pub fn get_metadata(&self, key: &str) -> Option<&String> {\n        self.metadata.get(key)\n    }\n\n    /// Set metadata value\n    pub fn set_metadata(&mut self, key: &str, value: &str) {\n        self.metadata.insert(key.to_string(), value.to_string());\n    }\n\n    /// Get property value (convenience method for common properties)\n    pub fn get_property(&self, key: &str) -> Option<&String> {\n        self.metadata.get(&format!(\"prop_{}\", key))\n    }\n\n    /// Set property value (convenience method for common properties)\n    pub fn set_property(&mut self, key: String, value: String) {\n        self.metadata.insert(format!(\"prop_{}\", key), value);\n    }\n\n    /// Enrich error with context information\n    pub fn enrich_error(&self, mut error: AsyncApiError) -> AsyncApiError {\n        error.add_context(\"correlation_id\", &self.correlation_id.to_string());\n        error.add_context(\"channel\", &self.channel);\n        error.add_context(\"operation\", &self.operation);\n        error.add_context(\"elapsed_ms\", &self.elapsed().as_millis().to_string());\n\n        // Add metadata to error context\n        for (key, value) in &self.metadata {\n            error.add_context(&format!(\"metadata_{}\", key), value);\n        }\n\n        error\n    }\n}\n\n/// Values that can be stored in the context\n#[derive(Debug, Clone)]\npub enum ContextValue {\n    String(String),\n    Integer(i64),\n    Float(f64),\n    Boolean(bool),\n    Json(String),\n    Binary(Vec<u8>),\n}\n\nimpl From<String> for ContextValue {\n    fn from(value: String) -> Self {\n        ContextValue::String(value)\n    }\n}\n\nimpl From<&str> for ContextValue {\n    fn from(value: &str) -> Self {\n        ContextValue::String(value.to_string())\n    }\n}\n\nimpl From<i64> for ContextValue {\n    fn from(value: i64) -> Self {\n        ContextValue::Integer(value)\n    }\n}\n\nimpl From<f64> for ContextValue {\n    fn from(value: f64) -> Self {\n        ContextValue::Float(value)\n    }\n}\n\nimpl From<bool> for ContextValue {\n    fn from(value: bool) -> Self {\n        ContextValue::Boolean(value)\n    }\n}\n\nimpl From<Vec<u8>> for ContextValue {\n    fn from(value: Vec<u8>) -> Self {\n        ContextValue::Binary(value)\n    }\n}\n\nimpl<T: Serialize> From<&T> for ContextValue {\n    fn from(value: &T) -> Self {\n        match serde_json::to_string(value) {\n            Ok(json) => ContextValue::Json(json),\n            Err(_) => ContextValue::String(\"serialization_failed\".to_string()),\n        }\n    }\n}\n\n/// Request priority levels for routing and processing\n#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\npub enum RequestPriority {\n    Low = 1,\n    Normal = 2,\n    High = 3,\n    Critical = 4,\n}\n\nimpl Default for RequestPriority {\n    fn default() -> Self {\n        RequestPriority::Normal\n    }\n}\n\n/// Performance metrics for a request\n#[derive(Debug, Clone)]\npub struct RequestMetrics {\n    pub events: Vec<MetricEvent>,\n    pub start_time: Instant,\n}\n\nimpl RequestMetrics {\n    pub fn new() -> Self {\n        Self {\n            events: Vec::new(),\n            start_time: Instant::now(),\n        }\n    }\n\n    pub fn record_event(&mut self, event: MetricEvent) {\n        self.events.push(event);\n    }\n\n    pub fn total_duration(&self) -> Duration {\n        self.start_time.elapsed()\n    }\n\n    pub fn get_events_by_type(&self, event_type: &str) -> Vec<&MetricEvent> {\n        self.events.iter().filter(|e| e.event_type == event_type).collect()\n    }\n}\n\n/// Individual metric event\n#[derive(Debug, Clone)]\npub struct MetricEvent {\n    pub event_type: String,\n    pub timestamp: Instant,\n    pub duration: Option<Duration>,\n    pub metadata: HashMap<String, String>,\n}\n\nimpl MetricEvent {\n    pub fn new(event_type: &str) -> Self {\n        Self {\n            event_type: event_type.to_string(),\n            timestamp: Instant::now(),\n            duration: None,\n            metadata: HashMap::new(),\n        }\n    }\n\n    pub fn with_duration(mut self, duration: Duration) -> Self {\n        self.duration = Some(duration);\n        self\n    }\n\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n}\n\n/// Global execution context for shared state\n#[derive(Debug)]\npub struct ExecutionContext {\n    /// Application-wide configuration\n    pub config: Arc<RwLock<HashMap<String, String>>>,\n    /// Shared metrics and statistics\n    pub global_metrics: Arc<RwLock<GlobalMetrics>>,\n    /// Active request contexts\n    pub active_requests: Arc<RwLock<HashMap<Uuid, RequestContext>>>,\n    /// Context creation time\n    pub created_at: SystemTime,\n}\n\nimpl ExecutionContext {\n    pub fn new() -> Self {\n        Self {\n            config: Arc::new(RwLock::new(HashMap::new())),\n            global_metrics: Arc::new(RwLock::new(GlobalMetrics::new())),\n            active_requests: Arc::new(RwLock::new(HashMap::new())),\n            created_at: SystemTime::now(),\n        }\n    }\n\n    /// Register an active request\n    pub async fn register_request(&self, context: RequestContext) {\n        let mut requests = self.active_requests.write().await;\n        requests.insert(context.correlation_id, context);\n\n        let mut metrics = self.global_metrics.write().await;\n        metrics.active_requests += 1;\n        metrics.total_requests += 1;\n    }\n\n    /// Unregister a completed request\n    pub async fn unregister_request(&self, correlation_id: Uuid) -> Option<RequestContext> {\n        let mut requests = self.active_requests.write().await;\n        let context = requests.remove(&correlation_id);\n\n        if context.is_some() {\n            let mut metrics = self.global_metrics.write().await;\n            metrics.active_requests = metrics.active_requests.saturating_sub(1);\n        }\n\n        context\n    }\n\n    /// Get active request count\n    pub async fn active_request_count(&self) -> usize {\n        self.active_requests.read().await.len()\n    }\n\n    /// Get global metrics\n    pub async fn get_global_metrics(&self) -> GlobalMetrics {\n        self.global_metrics.read().await.clone()\n    }\n\n    /// Set configuration value\n    pub async fn set_config(&self, key: &str, value: &str) {\n        let mut config = self.config.write().await;\n        config.insert(key.to_string(), value.to_string());\n    }\n\n    /// Get configuration value\n    pub async fn get_config(&self, key: &str) -> Option<String> {\n        let config = self.config.read().await;\n        config.get(key).cloned()\n    }\n}\n\nimpl Default for ExecutionContext {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Global application metrics\n#[derive(Debug, Clone)]\npub struct GlobalMetrics {\n    pub total_requests: u64,\n    pub active_requests: u64,\n    pub successful_requests: u64,\n    pub failed_requests: u64,\n    pub average_response_time: Duration,\n    pub uptime: Duration,\n    pub start_time: SystemTime,\n}\n\nimpl GlobalMetrics {\n    pub fn new() -> Self {\n        Self {\n            total_requests: 0,\n            active_requests: 0,\n            successful_requests: 0,\n            failed_requests: 0,\n            average_response_time: Duration::ZERO,\n            uptime: Duration::ZERO,\n            start_time: SystemTime::now(),\n        }\n    }\n\n    pub fn record_success(&mut self, duration: Duration) {\n        self.successful_requests += 1;\n        self.update_average_response_time(duration);\n    }\n\n    pub fn record_failure(&mut self, duration: Duration) {\n        self.failed_requests += 1;\n        self.update_average_response_time(duration);\n    }\n\n    fn update_average_response_time(&mut self, duration: Duration) {\n        let total_completed = self.successful_requests + self.failed_requests;\n        if total_completed > 0 {\n            let total_time = self.average_response_time.as_nanos() * (total_completed - 1) as u128 + duration.as_nanos();\n            self.average_response_time = Duration::from_nanos((total_time / total_completed as u128) as u64);\n        }\n    }\n\n    pub fn success_rate(&self) -> f64 {\n        let total_completed = self.successful_requests + self.failed_requests;\n        if total_completed > 0 {\n            self.successful_requests as f64 / total_completed as f64\n        } else {\n            0.0\n        }\n    }\n}\n\n/// Context manager for handling context lifecycle\npub struct ContextManager {\n    execution_context: Arc<ExecutionContext>,\n}\n\nimpl ContextManager {\n    pub fn new() -> Self {\n        Self {\n            execution_context: Arc::new(ExecutionContext::new()),\n        }\n    }\n\n    pub fn with_execution_context(execution_context: Arc<ExecutionContext>) -> Self {\n        Self { execution_context }\n    }\n\n    /// Create a new request context and register it\n    #[instrument(skip(self), fields(channel, operation))]\n    pub async fn create_request_context(&self, channel: &str, operation: &str) -> RequestContext {\n        let context = RequestContext::new(channel, operation);\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            channel = %channel,\n            operation = %operation,\n            \"Created new request context\"\n        );\n\n        self.execution_context.register_request(context.clone()).await;\n        context\n    }\n\n    /// Complete a request context and update metrics\n    #[instrument(skip(self, context), fields(correlation_id = %context.correlation_id))]\n    pub async fn complete_request_context(&self, context: RequestContext, success: bool) -> AsyncApiResult<()> {\n        let duration = context.elapsed();\n\n        // Update global metrics\n        {\n            let mut metrics = self.execution_context.global_metrics.write().await;\n            if success {\n                metrics.record_success(duration);\n            } else {\n                metrics.record_failure(duration);\n            }\n        }\n\n        // Unregister the request\n        self.execution_context.unregister_request(context.correlation_id).await;\n\n        info!(\n            correlation_id = %context.correlation_id,\n            duration_ms = duration.as_millis(),\n            success = success,\n            \"Completed request context\"\n        );\n\n        Ok(())\n    }\n\n    /// Get execution context\n    pub fn execution_context(&self) -> Arc<ExecutionContext> {\n        self.execution_context.clone()\n    }\n\n    /// Get context statistics\n    pub async fn get_statistics(&self) -> ContextStatistics {\n        let global_metrics = self.execution_context.get_global_metrics().await;\n        let active_count = self.execution_context.active_request_count().await;\n\n        ContextStatistics {\n            active_requests: active_count,\n            total_requests: global_metrics.total_requests,\n            success_rate: global_metrics.success_rate(),\n            average_response_time: global_metrics.average_response_time,\n            uptime: self.execution_context.created_at.elapsed().unwrap_or_default(),\n        }\n    }\n}\n\nimpl Default for ContextManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Statistics about context usage\n#[derive(Debug, Clone, Serialize)]\npub struct ContextStatistics {\n    pub active_requests: usize,\n    pub total_requests: u64,\n    pub success_rate: f64,\n    pub average_response_time: Duration,\n    pub uptime: Duration,\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_request_context_creation() {\n        let ctx = RequestContext::new(\"test/channel\", \"test_operation\");\n        assert_eq!(ctx.channel, \"test/channel\");\n        assert_eq!(ctx.operation, \"test_operation\");\n        assert_eq!(ctx.priority, RequestPriority::Normal);\n    }\n\n    #[tokio::test]\n    async fn test_context_data_storage() {\n        let ctx = RequestContext::new(\"test/channel\", \"test_operation\");\n\n        ctx.set_data(\"test_key\", \"test_value\").await.unwrap();\n        let value = ctx.get_data(\"test_key\").await;\n\n        assert!(value.is_some());\n        match value.unwrap() {\n            ContextValue::String(s) => assert_eq!(s, \"test_value\"),\n            _ => panic!(\"Expected string value\"),\n        }\n    }\n\n    #[tokio::test]\n    async fn test_context_manager() {\n        let manager = ContextManager::new();\n        let ctx = manager.create_request_context(\"test/channel\", \"test_op\").await;\n\n        assert_eq!(manager.execution_context.active_request_count().await, 1);\n\n        manager.complete_request_context(ctx, true).await.unwrap();\n        assert_eq!(manager.execution_context.active_request_count().await, 0);\n    }\n\n    #[test]\n    fn test_request_priority_ordering() {\n        assert!(RequestPriority::Critical > RequestPriority::High);\n        assert!(RequestPriority::High > RequestPriority::Normal);\n        assert!(RequestPriority::Normal > RequestPriority::Low);\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["ContextRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,SAASA,GAAG;EAChC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,YAAY;AAAAC,IAAAA,QAAA,EAClB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}