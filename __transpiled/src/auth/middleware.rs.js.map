{"version":3,"file":"middleware.rs.js","sources":["../../../template/src/auth/middleware.rs.js"],"sourcesContent":["export default function AuthMiddlewareRs() {\n    return (\n        <File name=\"middleware.rs\">\n            {`//! Authentication middleware for message processing\n\nuse crate::auth::{AuthConfig, JwtValidator, Claims};\nuse crate::context::{RequestContext, ExecutionContext};\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse crate::middleware::Middleware;\nuse async_trait::async_trait;\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse tracing::{debug, warn, error};\n\n/// Authentication middleware\npub struct AuthMiddleware {\n    config: AuthConfig,\n    jwt_validator: JwtValidator,\n    rate_limiter: Option<RateLimiter>,\n    session_manager: Option<SessionManager>,\n}\n\nimpl AuthMiddleware {\n    /// Create new authentication middleware\n    pub fn new(config: AuthConfig) -> AsyncApiResult<Self> {\n        let jwt_validator = Self::create_jwt_validator(&config)?;\n\n        let rate_limiter = if let Some(ref rate_config) = config.rate_limiting {\n            Some(RateLimiter::new(\n                rate_config.max_attempts,\n                Duration::from_secs(rate_config.window_seconds),\n                Duration::from_secs(rate_config.lockout_seconds),\n            ))\n        } else {\n            None\n        };\n\n        let session_manager = if let Some(ref session_config) = config.session {\n            Some(SessionManager::new(\n                Duration::from_secs(session_config.timeout_seconds),\n                session_config.extend_on_activity,\n                session_config.max_concurrent_sessions,\n            ))\n        } else {\n            None\n        };\n\n        Ok(Self {\n            config,\n            jwt_validator,\n            rate_limiter,\n            session_manager,\n        })\n    }\n\n    /// Create JWT validator from configuration\n    fn create_jwt_validator(config: &AuthConfig) -> AsyncApiResult<JwtValidator> {\n        let mut validator = match config.jwt.algorithm {\n            crate::auth::config::JwtAlgorithm::HS256 => {\n                let secret = config.jwt.secret.as_ref().ok_or_else(|| AsyncApiError::Configuration {\n                    message: \"JWT secret is required for HS256\".to_string(),\n                    field: Some(\"jwt.secret\".to_string()),\n                    source: None,\n                })?;\n                JwtValidator::new_hmac(secret.as_bytes())\n            }\n            crate::auth::config::JwtAlgorithm::RS256 => {\n                let public_key = config.jwt.public_key_pem.as_ref().ok_or_else(|| AsyncApiError::Configuration {\n                    message: \"RSA public key is required for RS256\".to_string(),\n                    field: Some(\"jwt.public_key_pem\".to_string()),\n                    source: None,\n                })?;\n\n                if let Some(private_key) = &config.jwt.private_key_pem {\n                    JwtValidator::new_rsa_keypair(private_key.as_bytes(), public_key.as_bytes())?\n                } else {\n                    JwtValidator::new_rsa_public(public_key.as_bytes())?\n                }\n            }\n        };\n\n        // Configure validator with issuer and audience if specified\n        if let Some(ref issuer) = config.jwt.issuer {\n            validator = validator.with_issuer(issuer.clone());\n        }\n\n        if let Some(ref audience) = config.jwt.audience {\n            validator = validator.with_audience(audience.clone());\n        }\n\n        validator = validator.with_leeway(config.jwt.leeway);\n\n        Ok(validator)\n    }\n\n    /// Extract authentication token from context\n    fn extract_token(&self, context: &RequestContext) -> AsyncApiResult<Option<String>> {\n        // Try to get token from headers\n        if let Some(auth_header) = context.get_header(\"authorization\") {\n            let token = JwtValidator::extract_bearer_token(auth_header)?;\n            return Ok(Some(token.to_string()));\n        }\n\n        // Try to get token from metadata\n        if let Some(token) = context.get_metadata(\"auth_token\") {\n            return Ok(Some(token.clone()));\n        }\n\n        // Try to get token from custom properties\n        if let Some(token) = context.get_property(\"jwt_token\") {\n            return Ok(Some(token.clone()));\n        }\n\n        Ok(None)\n    }\n\n    /// Validate user permissions\n    fn validate_permissions(&self, claims: &Claims) -> AsyncApiResult<()> {\n        // Check required roles\n        if !self.config.required_roles.is_empty() {\n            let has_required_role = self.config.required_roles.iter()\n                .any(|role| claims.has_role(role));\n\n            if !has_required_role {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"User lacks required roles: {:?}\", self.config.required_roles),\n                    required_permissions: self.config.required_roles.clone(),\n                    user_permissions: claims.roles.clone(),\n                });\n            }\n        }\n\n        // Check required permissions\n        if !self.config.required_permissions.is_empty() {\n            let has_required_permission = self.config.required_permissions.iter()\n                .any(|perm| claims.has_permission(perm));\n\n            if !has_required_permission {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"User lacks required permissions: {:?}\", self.config.required_permissions),\n                    required_permissions: self.config.required_permissions.clone(),\n                    user_permissions: claims.permissions.clone(),\n                });\n            }\n        }\n\n        Ok(())\n    }\n}\n\n#[async_trait]\nimpl Middleware for AuthMiddleware {\n    fn name(&self) -> &'static str {\n        \"AuthMiddleware\"\n    }\n\n    async fn process(\n        &self,\n        context: &mut RequestContext,\n        _execution_context: &ExecutionContext,\n    ) -> AsyncApiResult<()> {\n        debug!(\"Processing authentication middleware\");\n\n        // Check rate limiting first\n        if let Some(ref rate_limiter) = self.rate_limiter {\n            let client_id = context.get_client_id().unwrap_or(\"unknown\".to_string());\n            if !rate_limiter.check_rate_limit(&client_id).await {\n                warn!(\"Rate limit exceeded for client: {}\", client_id);\n                return Err(AsyncApiError::RateLimit {\n                    message: \"Authentication rate limit exceeded\".to_string(),\n                    retry_after: Some(self.config.rate_limit_lockout().unwrap_or(Duration::from_secs(900))),\n                });\n            }\n        }\n\n        // Extract authentication token\n        let token = match self.extract_token(context)? {\n            Some(token) => token,\n            None => {\n                if self.config.allow_anonymous {\n                    debug!(\"No authentication token found, allowing anonymous access\");\n                    context.set_property(\"authenticated\".to_string(), \"false\".to_string());\n                    return Ok(());\n                } else {\n                    return Err(AsyncApiError::Authentication {\n                        message: \"No authentication token provided\".to_string(),\n                        source: None,\n                    });\n                }\n            }\n        };\n\n        // Validate JWT token\n        let claims = match self.jwt_validator.validate_token(&token) {\n            Ok(claims) => claims,\n            Err(e) => {\n                warn!(\"JWT validation failed: {}\", e);\n\n                // Record failed attempt for rate limiting\n                if let Some(ref rate_limiter) = self.rate_limiter {\n                    let client_id = context.get_client_id().unwrap_or(\"unknown\".to_string());\n                    rate_limiter.record_failed_attempt(&client_id).await;\n                }\n\n                return Err(e);\n            }\n        };\n\n        // Validate permissions\n        self.validate_permissions(&claims)?;\n\n        // Check session if session management is enabled\n        if let Some(ref session_manager) = self.session_manager {\n            session_manager.validate_session(&claims.sub, &token).await?;\n        }\n\n        // Store authentication information in context\n        context.set_property(\"authenticated\".to_string(), \"true\".to_string());\n        context.set_property(\"user_id\".to_string(), claims.sub.clone());\n        context.set_property(\"user_roles\".to_string(), claims.roles.join(\",\"));\n        context.set_property(\"user_permissions\".to_string(), claims.permissions.join(\",\"));\n\n        // Store claims for use by handlers\n        context.set_auth_claims(claims);\n\n        debug!(\"Authentication successful for user: {}\", context.get_property(\"user_id\").unwrap_or(&\"unknown\".to_string()));\n        Ok(())\n    }\n}\n\n/// Rate limiter for authentication attempts\nstruct RateLimiter {\n    max_attempts: u32,\n    window: Duration,\n    lockout: Duration,\n    attempts: Arc<RwLock<HashMap<String, AttemptRecord>>>,\n}\n\n#[derive(Debug, Clone)]\nstruct AttemptRecord {\n    count: u32,\n    window_start: Instant,\n    locked_until: Option<Instant>,\n}\n\nimpl RateLimiter {\n    fn new(max_attempts: u32, window: Duration, lockout: Duration) -> Self {\n        Self {\n            max_attempts,\n            window,\n            lockout,\n            attempts: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    async fn check_rate_limit(&self, client_id: &str) -> bool {\n        let mut attempts = self.attempts.write().await;\n        let now = Instant::now();\n\n        let record = attempts.entry(client_id.to_string()).or_insert(AttemptRecord {\n            count: 0,\n            window_start: now,\n            locked_until: None,\n        });\n\n        // Check if client is locked out\n        if let Some(locked_until) = record.locked_until {\n            if now < locked_until {\n                return false;\n            } else {\n                // Lockout expired, reset\n                record.locked_until = None;\n                record.count = 0;\n                record.window_start = now;\n            }\n        }\n\n        // Check if we need to reset the window\n        if now.duration_since(record.window_start) > self.window {\n            record.count = 0;\n            record.window_start = now;\n        }\n\n        record.count < self.max_attempts\n    }\n\n    async fn record_failed_attempt(&self, client_id: &str) {\n        let mut attempts = self.attempts.write().await;\n        let now = Instant::now();\n\n        let record = attempts.entry(client_id.to_string()).or_insert(AttemptRecord {\n            count: 0,\n            window_start: now,\n            locked_until: None,\n        });\n\n        record.count += 1;\n\n        if record.count >= self.max_attempts {\n            record.locked_until = Some(now + self.lockout);\n            warn!(\"Client {} locked out due to too many failed authentication attempts\", client_id);\n        }\n    }\n}\n\n/// Session manager for tracking user sessions\nstruct SessionManager {\n    timeout: Duration,\n    extend_on_activity: bool,\n    max_concurrent_sessions: Option<u32>,\n    sessions: Arc<RwLock<HashMap<String, Vec<SessionInfo>>>>,\n}\n\n#[derive(Debug, Clone)]\nstruct SessionInfo {\n    token_hash: String,\n    created_at: Instant,\n    last_activity: Instant,\n}\n\nimpl SessionManager {\n    fn new(timeout: Duration, extend_on_activity: bool, max_concurrent_sessions: Option<u32>) -> Self {\n        Self {\n            timeout,\n            extend_on_activity,\n            max_concurrent_sessions,\n            sessions: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    async fn validate_session(&self, user_id: &str, token: &str) -> AsyncApiResult<()> {\n        let mut sessions = self.sessions.write().await;\n        let now = Instant::now();\n        let token_hash = self.hash_token(token);\n\n        let user_sessions = sessions.entry(user_id.to_string()).or_insert_with(Vec::new);\n\n        // Remove expired sessions\n        user_sessions.retain(|session| {\n            now.duration_since(session.last_activity) <= self.timeout\n        });\n\n        // Find current session\n        if let Some(session) = user_sessions.iter_mut().find(|s| s.token_hash == token_hash) {\n            // Check if session is expired\n            if now.duration_since(session.last_activity) > self.timeout {\n                return Err(AsyncApiError::Authentication {\n                    message: \"Session has expired\".to_string(),\n                    source: None,\n                });\n            }\n\n            // Extend session if configured\n            if self.extend_on_activity {\n                session.last_activity = now;\n            }\n\n            Ok(())\n        } else {\n            // New session\n            if let Some(max_sessions) = self.max_concurrent_sessions {\n                if user_sessions.len() >= max_sessions as usize {\n                    // Remove oldest session\n                    user_sessions.sort_by_key(|s| s.created_at);\n                    user_sessions.remove(0);\n                }\n            }\n\n            user_sessions.push(SessionInfo {\n                token_hash,\n                created_at: now,\n                last_activity: now,\n            });\n\n            Ok(())\n        }\n    }\n\n    fn hash_token(&self, token: &str) -> String {\n        use std::collections::hash_map::DefaultHasher;\n        use std::hash::{Hash, Hasher};\n\n        let mut hasher = DefaultHasher::new();\n        token.hash(&mut hasher);\n        format!(\"{:x}\", hasher.finish())\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n    use crate::auth::AuthConfig;\n\n    #[tokio::test]\n    async fn test_rate_limiter() {\n        let rate_limiter = RateLimiter::new(3, Duration::from_secs(60), Duration::from_secs(300));\n        let client_id = \"test_client\";\n\n        // Should allow initial attempts\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n        assert!(rate_limiter.check_rate_limit(client_id).await);\n\n        // Record failed attempts\n        rate_limiter.record_failed_attempt(client_id).await;\n        rate_limiter.record_failed_attempt(client_id).await;\n        rate_limiter.record_failed_attempt(client_id).await;\n\n        // Should be locked out now\n        assert!(!rate_limiter.check_rate_limit(client_id).await);\n    }\n\n    #[tokio::test]\n    async fn test_session_manager() {\n        let session_manager = SessionManager::new(\n            Duration::from_secs(3600),\n            true,\n            Some(2),\n        );\n\n        let user_id = \"test_user\";\n        let token1 = \"token1\";\n        let token2 = \"token2\";\n\n        // Validate new sessions\n        assert!(session_manager.validate_session(user_id, token1).await.is_ok());\n        assert!(session_manager.validate_session(user_id, token2).await.is_ok());\n\n        // Validate existing sessions\n        assert!(session_manager.validate_session(user_id, token1).await.is_ok());\n        assert!(session_manager.validate_session(user_id, token2).await.is_ok());\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["AuthMiddlewareRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,gBAAgBA,GAAG;EACvC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,eAAe;AAAAC,IAAAA,QAAA,EACrB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}