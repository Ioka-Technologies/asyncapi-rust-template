{"version":3,"file":"rbac.rs.js","sources":["../../../template/src/auth/rbac.rs.js"],"sourcesContent":["export default function AuthRbacRs() {\n    return (\n        <File name=\"rbac.rs\">\n            {`//! Role-Based Access Control (RBAC) system\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::{HashMap, HashSet};\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{debug, warn};\n\n/// A role in the RBAC system\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct Role {\n    /// Role name\n    pub name: String,\n    /// Role description\n    pub description: String,\n    /// Permissions granted by this role\n    pub permissions: HashSet<Permission>,\n    /// Parent roles (for role inheritance)\n    pub parent_roles: HashSet<String>,\n    /// Whether this role is active\n    pub active: bool,\n}\n\nimpl Role {\n    /// Create a new role\n    pub fn new(name: &str, description: &str) -> Self {\n        Self {\n            name: name.to_string(),\n            description: description.to_string(),\n            permissions: HashSet::new(),\n            parent_roles: HashSet::new(),\n            active: true,\n        }\n    }\n\n    /// Add a permission to this role\n    pub fn with_permission(mut self, permission: Permission) -> Self {\n        self.permissions.insert(permission);\n        self\n    }\n\n    /// Add multiple permissions to this role\n    pub fn with_permissions(mut self, permissions: Vec<Permission>) -> Self {\n        self.permissions.extend(permissions);\n        self\n    }\n\n    /// Add a parent role for inheritance\n    pub fn with_parent_role(mut self, parent_role: &str) -> Self {\n        self.parent_roles.insert(parent_role.to_string());\n        self\n    }\n\n    /// Check if this role has a specific permission\n    pub fn has_permission(&self, permission: &Permission) -> bool {\n        self.permissions.contains(permission)\n    }\n\n    /// Get all permissions including inherited ones\n    pub fn get_all_permissions(&self, role_manager: &RoleManager) -> HashSet<Permission> {\n        let mut all_permissions = self.permissions.clone();\n\n        // Add permissions from parent roles\n        for parent_name in &self.parent_roles {\n            if let Some(parent_role) = role_manager.get_role(parent_name) {\n                all_permissions.extend(parent_role.get_all_permissions(role_manager));\n            }\n        }\n\n        all_permissions\n    }\n}\n\n/// A permission in the RBAC system\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct Permission {\n    /// Permission name (e.g., \"read:users\", \"write:messages\")\n    pub name: String,\n    /// Resource this permission applies to\n    pub resource: String,\n    /// Action this permission allows\n    pub action: String,\n    /// Optional conditions for this permission\n    pub conditions: Option<PermissionConditions>,\n}\n\nimpl Permission {\n    /// Create a new permission\n    pub fn new(resource: &str, action: &str) -> Self {\n        Self {\n            name: format!(\"{}:{}\", action, resource),\n            resource: resource.to_string(),\n            action: action.to_string(),\n            conditions: None,\n        }\n    }\n\n    /// Create a permission with conditions\n    pub fn with_conditions(mut self, conditions: PermissionConditions) -> Self {\n        self.conditions = Some(conditions);\n        self\n    }\n\n    /// Check if this permission matches a required permission\n    pub fn matches(&self, required: &Permission) -> bool {\n        // Basic name matching\n        if self.name == required.name {\n            return true;\n        }\n\n        // Wildcard matching\n        if self.action == \"*\" && self.resource == required.resource {\n            return true;\n        }\n\n        if self.resource == \"*\" && self.action == required.action {\n            return true;\n        }\n\n        if self.action == \"*\" && self.resource == \"*\" {\n            return true;\n        }\n\n        false\n    }\n}\n\n/// Conditions that can be applied to permissions\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct PermissionConditions {\n    /// Time-based conditions\n    pub time_restrictions: Option<TimeRestrictions>,\n    /// IP-based conditions\n    pub ip_restrictions: Option<Vec<String>>,\n    /// Custom conditions\n    pub custom_conditions: HashMap<String, String>,\n}\n\n/// Time-based restrictions for permissions\n#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, Hash)]\npub struct TimeRestrictions {\n    /// Start time (hour of day, 0-23)\n    pub start_hour: Option<u8>,\n    /// End time (hour of day, 0-23)\n    pub end_hour: Option<u8>,\n    /// Days of week (0=Sunday, 6=Saturday)\n    pub allowed_days: Option<Vec<u8>>,\n}\n\n/// Role manager for RBAC operations\npub struct RoleManager {\n    roles: Arc<RwLock<HashMap<String, Role>>>,\n    user_roles: Arc<RwLock<HashMap<String, HashSet<String>>>>,\n}\n\nimpl RoleManager {\n    /// Create a new role manager\n    pub fn new() -> Self {\n        Self {\n            roles: Arc::new(RwLock::new(HashMap::new())),\n            user_roles: Arc::new(RwLock::new(HashMap::new())),\n        }\n    }\n\n    /// Create a role manager with default roles\n    pub async fn with_default_roles() -> Self {\n        let manager = Self::new();\n        manager.setup_default_roles().await;\n        manager\n    }\n\n    /// Set up default roles for common use cases\n    async fn setup_default_roles(&self) {\n        // Admin role with all permissions\n        let admin_role = Role::new(\"admin\", \"Administrator with full access\")\n            .with_permission(Permission::new(\"*\", \"*\"));\n\n        // User role with basic permissions\n        let user_role = Role::new(\"user\", \"Regular user with basic access\")\n            .with_permission(Permission::new(\"messages\", \"read\"))\n            .with_permission(Permission::new(\"profile\", \"read\"))\n            .with_permission(Permission::new(\"profile\", \"write\"));\n\n        // Guest role with read-only access\n        let guest_role = Role::new(\"guest\", \"Guest user with read-only access\")\n            .with_permission(Permission::new(\"messages\", \"read\"));\n\n        // Moderator role inheriting from user\n        let moderator_role = Role::new(\"moderator\", \"Moderator with additional permissions\")\n            .with_parent_role(\"user\")\n            .with_permission(Permission::new(\"messages\", \"write\"))\n            .with_permission(Permission::new(\"messages\", \"delete\"));\n\n        self.add_role(admin_role).await.ok();\n        self.add_role(user_role).await.ok();\n        self.add_role(guest_role).await.ok();\n        self.add_role(moderator_role).await.ok();\n    }\n\n    /// Add a role to the system\n    pub async fn add_role(&self, role: Role) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if roles.contains_key(&role.name) {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' already exists\", role.name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Adding role: {}\", role.name);\n        roles.insert(role.name.clone(), role);\n        Ok(())\n    }\n\n    /// Get a role by name\n    pub fn get_role(&self, name: &str) -> Option<Role> {\n        // This is a simplified synchronous version for internal use\n        // In a real implementation, you might want to use async here too\n        if let Ok(roles) = self.roles.try_read() {\n            roles.get(name).cloned()\n        } else {\n            None\n        }\n    }\n\n    /// Get a role by name (async version)\n    pub async fn get_role_async(&self, name: &str) -> Option<Role> {\n        let roles = self.roles.read().await;\n        roles.get(name).cloned()\n    }\n\n    /// Update a role\n    pub async fn update_role(&self, role: Role) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if !roles.contains_key(&role.name) {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' does not exist\", role.name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Updating role: {}\", role.name);\n        roles.insert(role.name.clone(), role);\n        Ok(())\n    }\n\n    /// Remove a role\n    pub async fn remove_role(&self, name: &str) -> AsyncApiResult<()> {\n        let mut roles = self.roles.write().await;\n\n        if roles.remove(name).is_none() {\n            return Err(AsyncApiError::Authorization {\n                message: format!(\"Role '{}' does not exist\", name),\n                required_permissions: vec![],\n                user_permissions: vec![],\n            });\n        }\n\n        debug!(\"Removed role: {}\", name);\n\n        // Remove role from all users\n        let mut user_roles = self.user_roles.write().await;\n        for user_role_set in user_roles.values_mut() {\n            user_role_set.remove(name);\n        }\n\n        Ok(())\n    }\n\n    /// Assign a role to a user\n    pub async fn assign_role_to_user(&self, user_id: &str, role_name: &str) -> AsyncApiResult<()> {\n        // Check if role exists\n        {\n            let roles = self.roles.read().await;\n            if !roles.contains_key(role_name) {\n                return Err(AsyncApiError::Authorization {\n                    message: format!(\"Role '{}' does not exist\", role_name),\n                    required_permissions: vec![],\n                    user_permissions: vec![],\n                });\n            }\n        }\n\n        let mut user_roles = self.user_roles.write().await;\n        let user_role_set = user_roles.entry(user_id.to_string()).or_insert_with(HashSet::new);\n        user_role_set.insert(role_name.to_string());\n\n        debug!(\"Assigned role '{}' to user '{}'\", role_name, user_id);\n        Ok(())\n    }\n\n    /// Remove a role from a user\n    pub async fn remove_role_from_user(&self, user_id: &str, role_name: &str) -> AsyncApiResult<()> {\n        let mut user_roles = self.user_roles.write().await;\n\n        if let Some(user_role_set) = user_roles.get_mut(user_id) {\n            user_role_set.remove(role_name);\n            debug!(\"Removed role '{}' from user '{}'\", role_name, user_id);\n        }\n\n        Ok(())\n    }\n\n    /// Get all roles for a user\n    pub async fn get_user_roles(&self, user_id: &str) -> Vec<Role> {\n        let user_roles = self.user_roles.read().await;\n        let roles = self.roles.read().await;\n\n        if let Some(role_names) = user_roles.get(user_id) {\n            role_names.iter()\n                .filter_map(|name| roles.get(name).cloned())\n                .collect()\n        } else {\n            Vec::new()\n        }\n    }\n\n    /// Get all permissions for a user (including inherited)\n    pub async fn get_user_permissions(&self, user_id: &str) -> HashSet<Permission> {\n        let user_roles = self.get_user_roles(user_id).await;\n        let mut all_permissions = HashSet::new();\n\n        for role in user_roles {\n            all_permissions.extend(role.get_all_permissions(self));\n        }\n\n        all_permissions\n    }\n\n    /// Check if a user has a specific permission\n    pub async fn user_has_permission(&self, user_id: &str, required_permission: &Permission) -> bool {\n        let user_permissions = self.get_user_permissions(user_id).await;\n\n        for permission in &user_permissions {\n            if permission.matches(required_permission) {\n                return true;\n            }\n        }\n\n        false\n    }\n\n    /// Check if a user has any of the required permissions\n    pub async fn user_has_any_permission(&self, user_id: &str, required_permissions: &[Permission]) -> bool {\n        for permission in required_permissions {\n            if self.user_has_permission(user_id, permission).await {\n                return true;\n            }\n        }\n        false\n    }\n\n    /// Check if a user has all of the required permissions\n    pub async fn user_has_all_permissions(&self, user_id: &str, required_permissions: &[Permission]) -> bool {\n        for permission in required_permissions {\n            if !self.user_has_permission(user_id, permission).await {\n                return false;\n            }\n        }\n        true\n    }\n\n    /// List all roles\n    pub async fn list_roles(&self) -> Vec<Role> {\n        let roles = self.roles.read().await;\n        roles.values().cloned().collect()\n    }\n\n    /// Get role statistics\n    pub async fn get_statistics(&self) -> RoleStatistics {\n        let roles = self.roles.read().await;\n        let user_roles = self.user_roles.read().await;\n\n        RoleStatistics {\n            total_roles: roles.len(),\n            total_users_with_roles: user_roles.len(),\n            active_roles: roles.values().filter(|r| r.active).count(),\n            roles_by_name: roles.keys().cloned().collect(),\n        }\n    }\n}\n\nimpl Default for RoleManager {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Statistics about the RBAC system\n#[derive(Debug, Clone, Serialize)]\npub struct RoleStatistics {\n    pub total_roles: usize,\n    pub total_users_with_roles: usize,\n    pub active_roles: usize,\n    pub roles_by_name: Vec<String>,\n}\n\n/// Helper macros for creating permissions\n#[macro_export]\nmacro_rules! permission {\n    ($resource:expr, $action:expr) => {\n        Permission::new($resource, $action)\n    };\n}\n\n#[macro_export]\nmacro_rules! role {\n    ($name:expr, $description:expr) => {\n        Role::new($name, $description)\n    };\n    ($name:expr, $description:expr, [$($permission:expr),*]) => {\n        Role::new($name, $description)\n            $(.with_permission($permission))*\n    };\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_role_creation() {\n        let role = Role::new(\"test_role\", \"Test role\")\n            .with_permission(Permission::new(\"messages\", \"read\"))\n            .with_permission(Permission::new(\"users\", \"write\"));\n\n        assert_eq!(role.name, \"test_role\");\n        assert_eq!(role.permissions.len(), 2);\n        assert!(role.has_permission(&Permission::new(\"messages\", \"read\")));\n    }\n\n    #[tokio::test]\n    async fn test_permission_matching() {\n        let wildcard_permission = Permission::new(\"*\", \"read\");\n        let specific_permission = Permission::new(\"messages\", \"read\");\n\n        assert!(wildcard_permission.matches(&specific_permission));\n        assert!(specific_permission.matches(&specific_permission));\n    }\n\n    #[tokio::test]\n    async fn test_role_manager() {\n        let manager = RoleManager::new();\n\n        let role = Role::new(\"test_role\", \"Test role\")\n            .with_permission(Permission::new(\"messages\", \"read\"));\n\n        manager.add_role(role).await.unwrap();\n        manager.assign_role_to_user(\"user1\", \"test_role\").await.unwrap();\n\n        let user_roles = manager.get_user_roles(\"user1\").await;\n        assert_eq!(user_roles.len(), 1);\n        assert_eq!(user_roles[0].name, \"test_role\");\n\n        let has_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"messages\", \"read\")\n        ).await;\n        assert!(has_permission);\n    }\n\n    #[tokio::test]\n    async fn test_role_inheritance() {\n        let manager = RoleManager::new();\n\n        let parent_role = Role::new(\"parent\", \"Parent role\")\n            .with_permission(Permission::new(\"base\", \"read\"));\n\n        let child_role = Role::new(\"child\", \"Child role\")\n            .with_parent_role(\"parent\")\n            .with_permission(Permission::new(\"extra\", \"write\"));\n\n        manager.add_role(parent_role).await.unwrap();\n        manager.add_role(child_role).await.unwrap();\n        manager.assign_role_to_user(\"user1\", \"child\").await.unwrap();\n\n        // User should have permissions from both parent and child roles\n        let has_parent_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"base\", \"read\")\n        ).await;\n        let has_child_permission = manager.user_has_permission(\n            \"user1\",\n            &Permission::new(\"extra\", \"write\")\n        ).await;\n\n        assert!(has_parent_permission);\n        assert!(has_child_permission);\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["AuthRbacRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,UAAUA,GAAG;EACjC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,SAAS;AAAAC,IAAAA,QAAA,EACf,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}