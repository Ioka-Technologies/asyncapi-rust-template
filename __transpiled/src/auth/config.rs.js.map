{"version":3,"file":"config.rs.js","sources":["../../../template/src/auth/config.rs.js"],"sourcesContent":["export default function AuthConfigRs() {\n    return (\n        <File name=\"config.rs\">\n            {`//! Authentication configuration\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::time::Duration;\n\n/// Authentication configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct AuthConfig {\n    /// JWT configuration\n    pub jwt: JwtConfig,\n    /// Rate limiting configuration\n    pub rate_limiting: Option<RateLimitConfig>,\n    /// Session configuration\n    pub session: Option<SessionConfig>,\n    /// Required roles for access\n    pub required_roles: Vec<String>,\n    /// Required permissions for access\n    pub required_permissions: Vec<String>,\n    /// Whether to allow anonymous access\n    pub allow_anonymous: bool,\n}\n\n/// JWT configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct JwtConfig {\n    /// JWT secret for HMAC algorithms\n    pub secret: Option<String>,\n    /// RSA private key PEM for signing (RS256)\n    pub private_key_pem: Option<String>,\n    /// RSA public key PEM for verification (RS256)\n    pub public_key_pem: Option<String>,\n    /// Expected issuer\n    pub issuer: Option<String>,\n    /// Expected audience\n    pub audience: Option<String>,\n    /// Token expiration time in seconds\n    pub expires_in: u64,\n    /// Leeway for time-based validations in seconds\n    pub leeway: u64,\n    /// Algorithm to use (HS256, RS256)\n    pub algorithm: JwtAlgorithm,\n}\n\n/// JWT algorithms\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub enum JwtAlgorithm {\n    /// HMAC with SHA-256\n    HS256,\n    /// RSA with SHA-256\n    RS256,\n}\n\n/// Rate limiting configuration for authentication\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct RateLimitConfig {\n    /// Maximum number of authentication attempts per window\n    pub max_attempts: u32,\n    /// Time window for rate limiting\n    pub window_seconds: u64,\n    /// Lockout duration after exceeding rate limit\n    pub lockout_seconds: u64,\n}\n\n/// Session configuration\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct SessionConfig {\n    /// Session timeout in seconds\n    pub timeout_seconds: u64,\n    /// Whether to extend session on activity\n    pub extend_on_activity: bool,\n    /// Maximum concurrent sessions per user\n    pub max_concurrent_sessions: Option<u32>,\n}\n\nimpl Default for AuthConfig {\n    fn default() -> Self {\n        Self {\n            jwt: JwtConfig::default(),\n            rate_limiting: Some(RateLimitConfig::default()),\n            session: Some(SessionConfig::default()),\n            required_roles: Vec::new(),\n            required_permissions: Vec::new(),\n            allow_anonymous: false,\n        }\n    }\n}\n\nimpl Default for JwtConfig {\n    fn default() -> Self {\n        Self {\n            secret: None,\n            private_key_pem: None,\n            public_key_pem: None,\n            issuer: None,\n            audience: None,\n            expires_in: 3600, // 1 hour\n            leeway: 60,       // 1 minute\n            algorithm: JwtAlgorithm::HS256,\n        }\n    }\n}\n\nimpl Default for RateLimitConfig {\n    fn default() -> Self {\n        Self {\n            max_attempts: 5,\n            window_seconds: 300,   // 5 minutes\n            lockout_seconds: 900,  // 15 minutes\n        }\n    }\n}\n\nimpl Default for SessionConfig {\n    fn default() -> Self {\n        Self {\n            timeout_seconds: 3600, // 1 hour\n            extend_on_activity: true,\n            max_concurrent_sessions: Some(5),\n        }\n    }\n}\n\nimpl AuthConfig {\n    /// Create a new authentication configuration\n    pub fn new() -> Self {\n        Self::default()\n    }\n\n    /// Set JWT secret for HMAC algorithms\n    pub fn with_jwt_secret(mut self, secret: String) -> Self {\n        self.jwt.secret = Some(secret);\n        self.jwt.algorithm = JwtAlgorithm::HS256;\n        self\n    }\n\n    /// Set RSA key pair for RS256 algorithm\n    pub fn with_rsa_keys(mut self, private_key_pem: String, public_key_pem: String) -> Self {\n        self.jwt.private_key_pem = Some(private_key_pem);\n        self.jwt.public_key_pem = Some(public_key_pem);\n        self.jwt.algorithm = JwtAlgorithm::RS256;\n        self\n    }\n\n    /// Set RSA public key for verification only\n    pub fn with_rsa_public_key(mut self, public_key_pem: String) -> Self {\n        self.jwt.public_key_pem = Some(public_key_pem);\n        self.jwt.algorithm = JwtAlgorithm::RS256;\n        self\n    }\n\n    /// Set JWT issuer\n    pub fn with_issuer(mut self, issuer: String) -> Self {\n        self.jwt.issuer = Some(issuer);\n        self\n    }\n\n    /// Set JWT audience\n    pub fn with_audience(mut self, audience: String) -> Self {\n        self.jwt.audience = Some(audience);\n        self\n    }\n\n    /// Set token expiration time\n    pub fn with_expires_in(mut self, seconds: u64) -> Self {\n        self.jwt.expires_in = seconds;\n        self\n    }\n\n    /// Add required role\n    pub fn with_required_role(mut self, role: String) -> Self {\n        self.required_roles.push(role);\n        self\n    }\n\n    /// Add required permission\n    pub fn with_required_permission(mut self, permission: String) -> Self {\n        self.required_permissions.push(permission);\n        self\n    }\n\n    /// Allow anonymous access\n    pub fn allow_anonymous(mut self) -> Self {\n        self.allow_anonymous = true;\n        self\n    }\n\n    /// Disable rate limiting\n    pub fn without_rate_limiting(mut self) -> Self {\n        self.rate_limiting = None;\n        self\n    }\n\n    /// Configure rate limiting\n    pub fn with_rate_limiting(mut self, config: RateLimitConfig) -> Self {\n        self.rate_limiting = Some(config);\n        self\n    }\n\n    /// Configure session management\n    pub fn with_session_config(mut self, config: SessionConfig) -> Self {\n        self.session = Some(config);\n        self\n    }\n\n    /// Validate the authentication configuration\n    pub fn validate(&self) -> AsyncApiResult<()> {\n        // Validate JWT configuration\n        match self.jwt.algorithm {\n            JwtAlgorithm::HS256 => {\n                if self.jwt.secret.is_none() {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"JWT secret is required for HS256 algorithm\".to_string(),\n                        field: Some(\"jwt.secret\".to_string()),\n                        source: None,\n                    });\n                }\n\n                if let Some(ref secret) = self.jwt.secret {\n                    if secret.len() < 32 {\n                        return Err(AsyncApiError::Configuration {\n                            message: \"JWT secret should be at least 32 characters long\".to_string(),\n                            field: Some(\"jwt.secret\".to_string()),\n                            source: None,\n                        });\n                    }\n                }\n            }\n            JwtAlgorithm::RS256 => {\n                if self.jwt.public_key_pem.is_none() {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"RSA public key is required for RS256 algorithm\".to_string(),\n                        field: Some(\"jwt.public_key_pem\".to_string()),\n                        source: None,\n                    });\n                }\n            }\n        }\n\n        // Validate expiration time\n        if self.jwt.expires_in == 0 {\n            return Err(AsyncApiError::Configuration {\n                message: \"JWT expiration time must be greater than 0\".to_string(),\n                field: Some(\"jwt.expires_in\".to_string()),\n                source: None,\n            });\n        }\n\n        // Validate rate limiting configuration\n        if let Some(ref rate_limit) = self.rate_limiting {\n            if rate_limit.max_attempts == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Rate limit max_attempts must be greater than 0\".to_string(),\n                    field: Some(\"rate_limiting.max_attempts\".to_string()),\n                    source: None,\n                });\n            }\n\n            if rate_limit.window_seconds == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Rate limit window_seconds must be greater than 0\".to_string(),\n                    field: Some(\"rate_limiting.window_seconds\".to_string()),\n                    source: None,\n                });\n            }\n        }\n\n        // Validate session configuration\n        if let Some(ref session) = self.session {\n            if session.timeout_seconds == 0 {\n                return Err(AsyncApiError::Configuration {\n                    message: \"Session timeout must be greater than 0\".to_string(),\n                    field: Some(\"session.timeout_seconds\".to_string()),\n                    source: None,\n                });\n            }\n\n            if let Some(max_sessions) = session.max_concurrent_sessions {\n                if max_sessions == 0 {\n                    return Err(AsyncApiError::Configuration {\n                        message: \"Max concurrent sessions must be greater than 0\".to_string(),\n                        field: Some(\"session.max_concurrent_sessions\".to_string()),\n                        source: None,\n                    });\n                }\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Create configuration from environment variables\n    pub fn from_env() -> AsyncApiResult<Self> {\n        let mut config = Self::default();\n\n        // JWT configuration\n        if let Ok(secret) = std::env::var(\"JWT_SECRET\") {\n            config.jwt.secret = Some(secret);\n            config.jwt.algorithm = JwtAlgorithm::HS256;\n        }\n\n        if let Ok(private_key) = std::env::var(\"JWT_PRIVATE_KEY_PEM\") {\n            config.jwt.private_key_pem = Some(private_key);\n            config.jwt.algorithm = JwtAlgorithm::RS256;\n        }\n\n        if let Ok(public_key) = std::env::var(\"JWT_PUBLIC_KEY_PEM\") {\n            config.jwt.public_key_pem = Some(public_key);\n            if config.jwt.private_key_pem.is_none() {\n                config.jwt.algorithm = JwtAlgorithm::RS256;\n            }\n        }\n\n        if let Ok(issuer) = std::env::var(\"JWT_ISSUER\") {\n            config.jwt.issuer = Some(issuer);\n        }\n\n        if let Ok(audience) = std::env::var(\"JWT_AUDIENCE\") {\n            config.jwt.audience = Some(audience);\n        }\n\n        if let Ok(expires_in) = std::env::var(\"JWT_EXPIRES_IN\") {\n            config.jwt.expires_in = expires_in.parse().map_err(|e| AsyncApiError::Configuration {\n                message: format!(\"Invalid JWT_EXPIRES_IN value: {}\", e),\n                field: Some(\"JWT_EXPIRES_IN\".to_string()),\n                source: Some(Box::new(e)),\n            })?;\n        }\n\n        // Rate limiting configuration\n        if let Ok(max_attempts) = std::env::var(\"AUTH_RATE_LIMIT_MAX_ATTEMPTS\") {\n            if let Some(ref mut rate_limit) = config.rate_limiting {\n                rate_limit.max_attempts = max_attempts.parse().map_err(|e| AsyncApiError::Configuration {\n                    message: format!(\"Invalid AUTH_RATE_LIMIT_MAX_ATTEMPTS value: {}\", e),\n                    field: Some(\"AUTH_RATE_LIMIT_MAX_ATTEMPTS\".to_string()),\n                    source: Some(Box::new(e)),\n                })?;\n            }\n        }\n\n        // Anonymous access\n        if let Ok(allow_anon) = std::env::var(\"AUTH_ALLOW_ANONYMOUS\") {\n            config.allow_anonymous = allow_anon.to_lowercase() == \"true\";\n        }\n\n        config.validate()?;\n        Ok(config)\n    }\n\n    /// Get the rate limit window as Duration\n    pub fn rate_limit_window(&self) -> Option<Duration> {\n        self.rate_limiting.as_ref().map(|rl| Duration::from_secs(rl.window_seconds))\n    }\n\n    /// Get the rate limit lockout duration as Duration\n    pub fn rate_limit_lockout(&self) -> Option<Duration> {\n        self.rate_limiting.as_ref().map(|rl| Duration::from_secs(rl.lockout_seconds))\n    }\n\n    /// Get the session timeout as Duration\n    pub fn session_timeout(&self) -> Option<Duration> {\n        self.session.as_ref().map(|s| Duration::from_secs(s.timeout_seconds))\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_default_config() {\n        let config = AuthConfig::default();\n        assert!(config.validate().is_err()); // Should fail without secret\n    }\n\n    #[test]\n    fn test_hmac_config() {\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string());\n\n        assert!(config.validate().is_ok());\n        assert_eq!(config.jwt.algorithm, JwtAlgorithm::HS256);\n    }\n\n    #[test]\n    fn test_config_validation() {\n        // Test short secret\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"short\".to_string());\n        assert!(config.validate().is_err());\n\n        // Test zero expiration\n        let mut config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string());\n        config.jwt.expires_in = 0;\n        assert!(config.validate().is_err());\n    }\n\n    #[test]\n    fn test_builder_pattern() {\n        let config = AuthConfig::new()\n            .with_jwt_secret(\"this-is-a-very-long-secret-key-for-testing\".to_string())\n            .with_issuer(\"test-issuer\".to_string())\n            .with_audience(\"test-audience\".to_string())\n            .with_required_role(\"admin\".to_string())\n            .allow_anonymous();\n\n        assert!(config.validate().is_ok());\n        assert_eq!(config.jwt.issuer, Some(\"test-issuer\".to_string()));\n        assert_eq!(config.jwt.audience, Some(\"test-audience\".to_string()));\n        assert!(config.required_roles.contains(&\"admin\".to_string()));\n        assert!(config.allow_anonymous);\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["AuthConfigRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,YAAYA,GAAG;EACnC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,WAAW;AAAAC,IAAAA,QAAA,EACjB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}