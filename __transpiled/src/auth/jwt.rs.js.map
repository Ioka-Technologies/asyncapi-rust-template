{"version":3,"file":"jwt.rs.js","sources":["../../../template/src/auth/jwt.rs.js"],"sourcesContent":["export default function AuthJwtRs() {\n    return (\n        <File name=\"jwt.rs\">\n            {`//! JWT token validation and claims handling\n\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse jsonwebtoken::{decode, encode, Algorithm, DecodingKey, EncodingKey, Header, Validation};\nuse serde::{Deserialize, Serialize};\nuse std::collections::HashSet;\nuse std::time::{SystemTime, UNIX_EPOCH};\nuse tracing::{debug, warn};\n\n/// JWT claims structure\n#[derive(Debug, Serialize, Deserialize, Clone)]\npub struct Claims {\n    /// Subject (user ID)\n    pub sub: String,\n    /// Issued at timestamp\n    pub iat: u64,\n    /// Expiration timestamp\n    pub exp: u64,\n    /// Issuer\n    pub iss: String,\n    /// Audience\n    pub aud: String,\n    /// User roles\n    pub roles: Vec<String>,\n    /// User permissions\n    pub permissions: Vec<String>,\n    /// Custom claims\n    #[serde(flatten)]\n    pub custom: serde_json::Map<String, serde_json::Value>,\n}\n\nimpl Claims {\n    /// Create new claims with expiration\n    pub fn new(\n        user_id: String,\n        issuer: String,\n        audience: String,\n        expires_in_seconds: u64,\n    ) -> AsyncApiResult<Self> {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map_err(|e| AsyncApiError::Authentication {\n                message: format!(\"Failed to get current time: {}\", e),\n                source: Some(Box::new(e)),\n            })?\n            .as_secs();\n\n        Ok(Self {\n            sub: user_id,\n            iat: now,\n            exp: now + expires_in_seconds,\n            iss: issuer,\n            aud: audience,\n            roles: Vec::new(),\n            permissions: Vec::new(),\n            custom: serde_json::Map::new(),\n        })\n    }\n\n    /// Add a role to the claims\n    pub fn with_role(mut self, role: String) -> Self {\n        self.roles.push(role);\n        self\n    }\n\n    /// Add multiple roles to the claims\n    pub fn with_roles(mut self, roles: Vec<String>) -> Self {\n        self.roles.extend(roles);\n        self\n    }\n\n    /// Add a permission to the claims\n    pub fn with_permission(mut self, permission: String) -> Self {\n        self.permissions.push(permission);\n        self\n    }\n\n    /// Add multiple permissions to the claims\n    pub fn with_permissions(mut self, permissions: Vec<String>) -> Self {\n        self.permissions.extend(permissions);\n        self\n    }\n\n    /// Add a custom claim\n    pub fn with_custom_claim<T: Serialize>(mut self, key: String, value: T) -> AsyncApiResult<Self> {\n        let json_value = serde_json::to_value(value).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Failed to serialize custom claim: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n        self.custom.insert(key, json_value);\n        Ok(self)\n    }\n\n    /// Check if the token has expired\n    pub fn is_expired(&self) -> bool {\n        let now = SystemTime::now()\n            .duration_since(UNIX_EPOCH)\n            .map(|d| d.as_secs())\n            .unwrap_or(0);\n\n        self.exp <= now\n    }\n\n    /// Check if the claims contain a specific role\n    pub fn has_role(&self, role: &str) -> bool {\n        self.roles.contains(&role.to_string())\n    }\n\n    /// Check if the claims contain any of the specified roles\n    pub fn has_any_role(&self, roles: &[&str]) -> bool {\n        roles.iter().any(|role| self.has_role(role))\n    }\n\n    /// Check if the claims contain all of the specified roles\n    pub fn has_all_roles(&self, roles: &[&str]) -> bool {\n        roles.iter().all(|role| self.has_role(role))\n    }\n\n    /// Check if the claims contain a specific permission\n    pub fn has_permission(&self, permission: &str) -> bool {\n        self.permissions.contains(&permission.to_string())\n    }\n\n    /// Check if the claims contain any of the specified permissions\n    pub fn has_any_permission(&self, permissions: &[&str]) -> bool {\n        permissions.iter().any(|perm| self.has_permission(perm))\n    }\n\n    /// Get a custom claim value\n    pub fn get_custom_claim<T: for<'de> Deserialize<'de>>(&self, key: &str) -> AsyncApiResult<Option<T>> {\n        match self.custom.get(key) {\n            Some(value) => {\n                let result = serde_json::from_value(value.clone()).map_err(|e| AsyncApiError::Authentication {\n                    message: format!(\"Failed to deserialize custom claim '{}': {}\", key, e),\n                    source: Some(Box::new(e)),\n                })?;\n                Ok(Some(result))\n            }\n            None => Ok(None),\n        }\n    }\n}\n\n/// JWT token validator\npub struct JwtValidator {\n    decoding_key: DecodingKey,\n    validation: Validation,\n    encoding_key: Option<EncodingKey>,\n}\n\nimpl JwtValidator {\n    /// Create a new JWT validator with HMAC secret\n    pub fn new_hmac(secret: &[u8]) -> Self {\n        let mut validation = Validation::new(Algorithm::HS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false; // We'll validate audience manually if needed\n\n        Self {\n            decoding_key: DecodingKey::from_secret(secret),\n            validation,\n            encoding_key: Some(EncodingKey::from_secret(secret)),\n        }\n    }\n\n    /// Create a new JWT validator with RSA public key\n    pub fn new_rsa_public(public_key_pem: &[u8]) -> AsyncApiResult<Self> {\n        let decoding_key = DecodingKey::from_rsa_pem(public_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA public key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let mut validation = Validation::new(Algorithm::RS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false;\n\n        Ok(Self {\n            decoding_key,\n            validation,\n            encoding_key: None,\n        })\n    }\n\n    /// Create a new JWT validator with RSA key pair\n    pub fn new_rsa_keypair(private_key_pem: &[u8], public_key_pem: &[u8]) -> AsyncApiResult<Self> {\n        let decoding_key = DecodingKey::from_rsa_pem(public_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA public key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let encoding_key = EncodingKey::from_rsa_pem(private_key_pem).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Invalid RSA private key: {}\", e),\n            source: Some(Box::new(e)),\n        })?;\n\n        let mut validation = Validation::new(Algorithm::RS256);\n        validation.validate_exp = true;\n        validation.validate_aud = false;\n\n        Ok(Self {\n            decoding_key,\n            validation,\n            encoding_key: Some(encoding_key),\n        })\n    }\n\n    /// Set required audience for validation\n    pub fn with_audience(mut self, audience: String) -> Self {\n        self.validation.validate_aud = true;\n        self.validation.aud = Some(HashSet::from([audience]));\n        self\n    }\n\n    /// Set required issuer for validation\n    pub fn with_issuer(mut self, issuer: String) -> Self {\n        self.validation.validate_iss = true;\n        self.validation.iss = Some(HashSet::from([issuer]));\n        self\n    }\n\n    /// Set leeway for time-based validations (in seconds)\n    pub fn with_leeway(mut self, leeway_seconds: u64) -> Self {\n        self.validation.leeway = leeway_seconds;\n        self\n    }\n\n    /// Validate and decode a JWT token\n    pub fn validate_token(&self, token: &str) -> AsyncApiResult<Claims> {\n        debug!(\"Validating JWT token\");\n\n        let token_data = decode::<Claims>(token, &self.decoding_key, &self.validation)\n            .map_err(|e| {\n                warn!(\"JWT validation failed: {}\", e);\n                AsyncApiError::Authentication {\n                    message: format!(\"Invalid JWT token: {}\", e),\n                    source: Some(Box::new(e)),\n                }\n            })?;\n\n        let claims = token_data.claims;\n\n        // Additional custom validations\n        if claims.is_expired() {\n            return Err(AsyncApiError::Authentication {\n                message: \"Token has expired\".to_string(),\n                source: None,\n            });\n        }\n\n        debug!(\"JWT token validated successfully for user: {}\", claims.sub);\n        Ok(claims)\n    }\n\n    /// Generate a new JWT token (requires encoding key)\n    pub fn generate_token(&self, claims: &Claims) -> AsyncApiResult<String> {\n        let encoding_key = self.encoding_key.as_ref().ok_or_else(|| AsyncApiError::Authentication {\n            message: \"No encoding key available for token generation\".to_string(),\n            source: None,\n        })?;\n\n        let header = Header::new(match encoding_key {\n            EncodingKey::Rsa { .. } => Algorithm::RS256,\n            _ => Algorithm::HS256,\n        });\n\n        encode(&header, claims, encoding_key).map_err(|e| AsyncApiError::Authentication {\n            message: format!(\"Failed to generate JWT token: {}\", e),\n            source: Some(Box::new(e)),\n        })\n    }\n\n    /// Extract token from Authorization header\n    pub fn extract_bearer_token(auth_header: &str) -> AsyncApiResult<&str> {\n        if !auth_header.starts_with(\"Bearer \") {\n            return Err(AsyncApiError::Authentication {\n                message: \"Authorization header must start with 'Bearer '\".to_string(),\n                source: None,\n            });\n        }\n\n        let token = &auth_header[7..]; // Remove \"Bearer \" prefix\n        if token.is_empty() {\n            return Err(AsyncApiError::Authentication {\n                message: \"Empty bearer token\".to_string(),\n                source: None,\n            });\n        }\n\n        Ok(token)\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn test_claims_creation() {\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap();\n\n        assert_eq!(claims.sub, \"user123\");\n        assert_eq!(claims.iss, \"test-issuer\");\n        assert_eq!(claims.aud, \"test-audience\");\n        assert!(!claims.is_expired());\n    }\n\n    #[test]\n    fn test_role_permissions() {\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap()\n        .with_role(\"admin\".to_string())\n        .with_permission(\"read:users\".to_string());\n\n        assert!(claims.has_role(\"admin\"));\n        assert!(!claims.has_role(\"user\"));\n        assert!(claims.has_permission(\"read:users\"));\n        assert!(!claims.has_permission(\"write:users\"));\n    }\n\n    #[test]\n    fn test_jwt_hmac_roundtrip() {\n        let secret = b\"test-secret-key\";\n        let validator = JwtValidator::new_hmac(secret);\n\n        let claims = Claims::new(\n            \"user123\".to_string(),\n            \"test-issuer\".to_string(),\n            \"test-audience\".to_string(),\n            3600,\n        ).unwrap();\n\n        let token = validator.generate_token(&claims).unwrap();\n        let decoded_claims = validator.validate_token(&token).unwrap();\n\n        assert_eq!(claims.sub, decoded_claims.sub);\n        assert_eq!(claims.iss, decoded_claims.iss);\n        assert_eq!(claims.aud, decoded_claims.aud);\n    }\n\n    #[test]\n    fn test_bearer_token_extraction() {\n        let auth_header = \"Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\";\n        let token = JwtValidator::extract_bearer_token(auth_header).unwrap();\n        assert_eq!(token, \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\");\n\n        let invalid_header = \"Basic dXNlcjpwYXNz\";\n        assert!(JwtValidator::extract_bearer_token(invalid_header).is_err());\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["AuthJwtRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,SAASA,GAAG;EAChC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}