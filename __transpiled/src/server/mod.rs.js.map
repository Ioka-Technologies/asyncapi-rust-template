{"version":3,"file":"mod.rs.js","sources":["../../../template/src/server/mod.rs.js"],"sourcesContent":["export default function ServerModRs() {\n    return (\n        <File name=\"mod.rs\">\n            {`//! Server module for AsyncAPI service\n//!\n//! This module provides the main server implementation and builder pattern\n//! for constructing servers with various configurations and middleware.\n\npub mod builder;\n\npub use builder::{ServerBuilder, ServerConfig};\n\nuse crate::config::Config;\nuse crate::errors::{AsyncApiError, AsyncApiResult};\nuse crate::handlers::HandlerRegistry;\nuse crate::middleware::MiddlewarePipeline;\nuse crate::context::ContextManager;\nuse crate::router::Router;\nuse crate::recovery::RecoveryManager;\n\nuse std::sync::Arc;\nuse tokio::sync::RwLock;\nuse tracing::{info, warn, error, debug};\n\n/// Main server struct that orchestrates all components\npub struct Server {\n    config: Config,\n    handlers: Arc<RwLock<HandlerRegistry>>,\n    context_manager: Arc<ContextManager>,\n    router: Arc<Router>,\n    middleware: MiddlewarePipeline,\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl Server {\n    /// Create a new server with default configuration\n    pub async fn new(config: Config) -> AsyncApiResult<Self> {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n        let context_manager = Arc::new(ContextManager::new());\n        let router = Arc::new(Router::new());\n        let handlers = Arc::new(RwLock::new(\n            HandlerRegistry::with_recovery_manager(recovery_manager.clone())\n        ));\n        let middleware = MiddlewarePipeline::new(recovery_manager.clone());\n\n        // Initialize router with default routes\n        router.initialize_default_routes().await?;\n\n        Ok(Self {\n            config,\n            handlers,\n            context_manager,\n            router,\n            middleware,\n            recovery_manager,\n        })\n    }\n\n    /// Create a new server with custom configuration\n    pub async fn new_with_config(\n        config: Config,\n        handlers: Arc<RwLock<HandlerRegistry>>,\n        context_manager: Arc<ContextManager>,\n        router: Arc<Router>,\n        middleware: MiddlewarePipeline,\n    ) -> AsyncApiResult<Self> {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n\n        Ok(Self {\n            config,\n            handlers,\n            context_manager,\n            router,\n            middleware,\n            recovery_manager,\n        })\n    }\n\n    /// Start the server\n    pub async fn start(&self) -> AsyncApiResult<()> {\n        info!(\"Starting AsyncAPI server on {}:{}\",\n              self.config.host,\n              self.config.port);\n\n        // Initialize all components\n        self.initialize_components().await?;\n\n        // Start the main server loop\n        self.run_server_loop().await?;\n\n        Ok(())\n    }\n\n    /// Stop the server gracefully\n    pub async fn stop(&self) -> AsyncApiResult<()> {\n        info!(\"Stopping AsyncAPI server gracefully\");\n\n        // Perform cleanup operations\n        self.cleanup().await?;\n\n        info!(\"Server stopped successfully\");\n        Ok(())\n    }\n\n    /// Initialize all server components\n    async fn initialize_components(&self) -> AsyncApiResult<()> {\n        debug!(\"Initializing server components\");\n\n        // Components are already initialized during construction\n        debug!(\"Context manager ready\");\n        debug!(\"Middleware pipeline ready\");\n        debug!(\"Recovery manager ready\");\n\n        debug!(\"All server components initialized successfully\");\n        Ok(())\n    }\n\n    /// Main server loop\n    async fn run_server_loop(&self) -> AsyncApiResult<()> {\n        debug!(\"Starting main server loop\");\n\n        // This is where the actual server logic would run\n        // For now, we'll just keep the server alive\n        loop {\n            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;\n\n            // Check if we should continue running\n            if self.should_shutdown().await {\n                break;\n            }\n        }\n\n        Ok(())\n    }\n\n    /// Check if the server should shutdown\n    async fn should_shutdown(&self) -> bool {\n        // For now, never shutdown automatically\n        // In a real implementation, this would check for shutdown signals\n        false\n    }\n\n    /// Cleanup server resources\n    async fn cleanup(&self) -> AsyncApiResult<()> {\n        debug!(\"Cleaning up server resources\");\n\n        // Cleanup handlers\n        debug!(\"Handlers cleanup completed\");\n\n        // Cleanup middleware\n        debug!(\"Middleware cleanup completed\");\n\n        // Cleanup context manager\n        debug!(\"Context manager cleanup completed\");\n\n        // Cleanup recovery manager\n        debug!(\"Recovery manager cleanup completed\");\n\n        debug!(\"Server cleanup completed\");\n        Ok(())\n    }\n\n    /// Get server configuration\n    pub fn config(&self) -> &Config {\n        &self.config\n    }\n\n    /// Get handler registry\n    pub fn handlers(&self) -> Arc<RwLock<HandlerRegistry>> {\n        self.handlers.clone()\n    }\n\n    /// Get context manager\n    pub fn context_manager(&self) -> Arc<ContextManager> {\n        self.context_manager.clone()\n    }\n\n    /// Get router\n    pub fn router(&self) -> Arc<Router> {\n        self.router.clone()\n    }\n\n    /// Get middleware pipeline\n    pub fn middleware(&self) -> &MiddlewarePipeline {\n        &self.middleware\n    }\n\n    /// Get recovery manager\n    pub fn recovery_manager(&self) -> Arc<RecoveryManager> {\n        self.recovery_manager.clone()\n    }\n\n    /// Health check endpoint\n    pub async fn health_check(&self) -> AsyncApiResult<HealthStatus> {\n        debug!(\"Performing health check\");\n\n        let mut status = HealthStatus::new();\n\n        // Check handlers\n        status.handlers = ComponentHealth::Healthy;\n\n        // Check middleware\n        status.middleware = ComponentHealth::Healthy;\n\n        // Check context manager\n        status.context_manager = ComponentHealth::Healthy;\n\n        // Check recovery manager\n        status.recovery_manager = ComponentHealth::Healthy;\n\n        // Overall status\n        status.overall = if status.all_healthy() {\n            ComponentHealth::Healthy\n        } else {\n            ComponentHealth::Unhealthy\n        };\n\n        debug!(\"Health check completed: {:?}\", status.overall);\n        Ok(status)\n    }\n\n    /// Start HTTP handler\n    pub async fn start_http_handler(&self) -> AsyncApiResult<()> {\n        info!(\"Starting HTTP handler on {}:{}\", self.config.host, self.config.port);\n\n        // Initialize HTTP transport\n        // For now, just log that we're starting\n        debug!(\"HTTP handler started successfully\");\n        Ok(())\n    }\n\n    /// Shutdown the server\n    pub async fn shutdown(&self) -> AsyncApiResult<()> {\n        info!(\"Shutting down server\");\n        self.stop().await\n    }\n}\n\n/// Health status for the server and its components\n#[derive(Debug, Clone)]\npub struct HealthStatus {\n    pub overall: ComponentHealth,\n    pub handlers: ComponentHealth,\n    pub middleware: ComponentHealth,\n    pub context_manager: ComponentHealth,\n    pub recovery_manager: ComponentHealth,\n}\n\nimpl HealthStatus {\n    pub fn new() -> Self {\n        Self {\n            overall: ComponentHealth::Unknown,\n            handlers: ComponentHealth::Unknown,\n            middleware: ComponentHealth::Unknown,\n            context_manager: ComponentHealth::Unknown,\n            recovery_manager: ComponentHealth::Unknown,\n        }\n    }\n\n    pub fn all_healthy(&self) -> bool {\n        matches!(self.handlers, ComponentHealth::Healthy) &&\n        matches!(self.middleware, ComponentHealth::Healthy) &&\n        matches!(self.context_manager, ComponentHealth::Healthy) &&\n        matches!(self.recovery_manager, ComponentHealth::Healthy)\n    }\n}\n\n/// Health status for individual components\n#[derive(Debug, Clone, PartialEq, Eq)]\npub enum ComponentHealth {\n    Healthy,\n    Unhealthy,\n    Unknown,\n}\n\nimpl Default for HealthStatus {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[tokio::test]\n    async fn test_server_creation() {\n        let config = Config::default();\n        let server = Server::new(config).await;\n        assert!(server.is_ok());\n    }\n\n    #[tokio::test]\n    async fn test_health_check() {\n        let config = Config::default();\n        let server = Server::new(config).await.unwrap();\n        let health = server.health_check().await;\n        assert!(health.is_ok());\n    }\n}\n`}\n        </File>\n    );\n}\n"],"names":["ServerModRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,WAAWA,GAAG;EAClC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,QAAQ;AAAAC,IAAAA,QAAA,EACd,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}