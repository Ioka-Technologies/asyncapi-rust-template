{"version":3,"file":"middleware.rs.js","sources":["../../template/src/middleware.rs.js"],"sourcesContent":["export default function MiddlewareRs() {\n    return (\n        <File name=\"middleware.rs\">\n            {`//! Enhanced middleware for request/response processing with comprehensive error handling\n//!\n//! This module provides:\n//! - Error-aware middleware pipeline\n//! - Metrics collection and monitoring\n//! - Request/response validation\n//! - Performance tracking\n//! - Security and rate limiting\n\nuse crate::errors::{AsyncApiError, AsyncApiResult, ErrorMetadata, ErrorSeverity, ErrorCategory};\nuse crate::context::RequestContext;\nuse crate::recovery::RecoveryManager;\nuse async_trait::async_trait;\nuse tracing::{info, warn, error, debug, instrument};\nuse std::collections::HashMap;\nuse std::sync::Arc;\nuse std::time::{Duration, Instant};\nuse tokio::sync::RwLock;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\n\n/// Enhanced middleware trait for processing messages with error handling\n#[async_trait::async_trait]\npub trait Middleware: Send + Sync {\n    /// Process inbound messages with error handling\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>>;\n\n    /// Process outbound messages with error handling\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>>;\n\n    /// Get middleware name for logging and metrics\n    fn name(&self) -> &'static str;\n\n    /// Check if middleware is enabled\n    fn is_enabled(&self) -> bool {\n        true\n    }\n}\n\n/// Context for middleware processing with correlation tracking\n#[derive(Debug, Clone)]\npub struct MiddlewareContext {\n    pub correlation_id: Uuid,\n    pub channel: String,\n    pub operation: String,\n    pub timestamp: chrono::DateTime<chrono::Utc>,\n    pub metadata: std::collections::HashMap<String, String>,\n}\n\nimpl MiddlewareContext {\n    pub fn new(channel: &str, operation: &str) -> Self {\n        Self {\n            correlation_id: Uuid::new_v4(),\n            channel: channel.to_string(),\n            operation: operation.to_string(),\n            timestamp: chrono::Utc::now(),\n            metadata: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn with_metadata(mut self, key: &str, value: &str) -> Self {\n        self.metadata.insert(key.to_string(), value.to_string());\n        self\n    }\n}\n\n/// Logging middleware that logs all message traffic with enhanced context\npub struct LoggingMiddleware {\n    log_payloads: bool,\n    max_payload_log_size: usize,\n}\n\nimpl LoggingMiddleware {\n    pub fn new(log_payloads: bool, max_payload_log_size: usize) -> Self {\n        Self {\n            log_payloads,\n            max_payload_log_size,\n        }\n    }\n}\n\nimpl Default for LoggingMiddleware {\n    fn default() -> Self {\n        Self::new(false, 100) // Don't log payloads by default for security\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for LoggingMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"logging\",\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let start_time = Instant::now();\n\n        info!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            payload_size = payload.len(),\n            \"Processing inbound message\"\n        );\n\n        if self.log_payloads && !payload.is_empty() {\n            let payload_preview = if payload.len() > self.max_payload_log_size {\n                format!(\"{}... (truncated)\", String::from_utf8_lossy(&payload[..self.max_payload_log_size]))\n            } else {\n                String::from_utf8_lossy(payload).to_string()\n            };\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                payload_preview = %payload_preview,\n                \"Inbound message payload\"\n            );\n        }\n\n        let processing_time = start_time.elapsed();\n        debug!(\n            correlation_id = %context.correlation_id,\n            processing_time_ms = processing_time.as_millis(),\n            \"Logging middleware processing completed\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    #[instrument(skip(self, payload), fields(\n        middleware = \"logging\",\n        correlation_id = %context.correlation_id,\n        channel = %context.channel,\n        operation = %context.operation,\n        payload_size = payload.len()\n    ))]\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        info!(\n            correlation_id = %context.correlation_id,\n            channel = %context.channel,\n            operation = %context.operation,\n            payload_size = payload.len(),\n            \"Processing outbound message\"\n        );\n\n        if self.log_payloads && !payload.is_empty() {\n            let payload_preview = if payload.len() > self.max_payload_log_size {\n                format!(\"{}... (truncated)\", String::from_utf8_lossy(&payload[..self.max_payload_log_size]))\n            } else {\n                String::from_utf8_lossy(payload).to_string()\n            };\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                payload_preview = %payload_preview,\n                \"Outbound message payload\"\n            );\n        }\n\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"logging\"\n    }\n}\n\n/// Metrics middleware for collecting performance data and error rates\npub struct MetricsMiddleware {\n    start_time: Instant,\n    message_count: Arc<RwLock<u64>>,\n    error_count: Arc<RwLock<u64>>,\n    processing_times: Arc<RwLock<Vec<std::time::Duration>>>,\n}\n\nimpl MetricsMiddleware {\n    pub fn new() -> Self {\n        Self {\n            start_time: Instant::now(),\n            message_count: Arc::new(RwLock::new(0)),\n            error_count: Arc::new(RwLock::new(0)),\n            processing_times: Arc::new(RwLock::new(Vec::new())),\n        }\n    }\n\n    pub async fn get_metrics(&self) -> MiddlewareMetrics {\n        let message_count = *self.message_count.read().await;\n        let error_count = *self.error_count.read().await;\n        let processing_times = self.processing_times.read().await;\n\n        let avg_processing_time = if processing_times.is_empty() {\n            std::time::Duration::ZERO\n        } else {\n            let total: std::time::Duration = processing_times.iter().sum();\n            total / processing_times.len() as u32\n        };\n\n        MiddlewareMetrics {\n            uptime: self.start_time.elapsed(),\n            message_count,\n            error_count,\n            error_rate: if message_count > 0 { error_count as f64 / message_count as f64 } else { 0.0 },\n            avg_processing_time,\n        }\n    }\n}\n\nimpl Default for MetricsMiddleware {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for MetricsMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"metrics\",\n        correlation_id = %context.correlation_id,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let start_time = Instant::now();\n\n        // Increment message count\n        {\n            let mut count = self.message_count.write().await;\n            *count += 1;\n        }\n\n        let processing_time = start_time.elapsed();\n\n        // Record processing time\n        {\n            let mut times = self.processing_times.write().await;\n            times.push(processing_time);\n\n            // Keep only last 1000 measurements to prevent memory growth\n            if times.len() > 1000 {\n                times.remove(0);\n            }\n        }\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            processing_time_ms = processing_time.as_millis(),\n            \"Metrics collected for inbound message\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    async fn process_outbound(&self, _context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // For outbound, we just pass through without additional metrics\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"metrics\"\n    }\n}\n\n/// Validation middleware for message schema validation with detailed error reporting\npub struct ValidationMiddleware {\n    strict_mode: bool,\n}\n\nimpl ValidationMiddleware {\n    pub fn new(strict_mode: bool) -> Self {\n        Self { strict_mode }\n    }\n}\n\nimpl Default for ValidationMiddleware {\n    fn default() -> Self {\n        Self::new(true) // Strict validation by default\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for ValidationMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"validation\",\n        correlation_id = %context.correlation_id,\n        strict_mode = self.strict_mode,\n        payload_size = payload.len()\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        debug!(\n            correlation_id = %context.correlation_id,\n            strict_mode = self.strict_mode,\n            \"Starting message validation\"\n        );\n\n        // Basic payload validation\n        if payload.is_empty() {\n            return Err(AsyncApiError::Validation {\n                message: \"Empty payload received\".to_string(),\n                field: Some(\"payload\".to_string()),\n                metadata: ErrorMetadata::new(\n                    ErrorSeverity::Medium,\n                    ErrorCategory::Validation,\n                    false,\n                ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                 .with_context(\"channel\", &context.channel)\n                 .with_context(\"operation\", &context.operation)\n                 .with_context(\"middleware\", \"validation\"),\n                source: None,\n            });\n        }\n\n        // JSON validation\n        match serde_json::from_slice::<serde_json::Value>(payload) {\n            Ok(json_value) => {\n                debug!(\n                    correlation_id = %context.correlation_id,\n                    message_type = json_value.get(\"type\").and_then(|v| v.as_str()).unwrap_or(\"unknown\"),\n                    \"Message validation successful\"\n                );\n\n                // Additional validation in strict mode\n                if self.strict_mode {\n                    // Check for required fields\n                    if json_value.get(\"type\").is_none() {\n                        warn!(\n                            correlation_id = %context.correlation_id,\n                            \"Missing 'type' field in strict validation mode\"\n                        );\n\n                        return Err(AsyncApiError::Validation {\n                            message: \"Missing required field 'type' in message\".to_string(),\n                            field: Some(\"type\".to_string()),\n                            metadata: ErrorMetadata::new(\n                                ErrorSeverity::Medium,\n                                ErrorCategory::Validation,\n                                false,\n                            ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                             .with_context(\"validation_mode\", \"strict\"),\n                            source: None,\n                        });\n                    }\n                }\n\n                Ok(payload.to_vec())\n            }\n            Err(e) => {\n                error!(\n                    correlation_id = %context.correlation_id,\n                    error = %e,\n                    payload_preview = %String::from_utf8_lossy(&payload[..payload.len().min(100)]),\n                    \"JSON validation failed\"\n                );\n\n                Err(AsyncApiError::Validation {\n                    message: format!(\"Invalid JSON payload: {}\", e),\n                    field: Some(\"payload\".to_string()),\n                    metadata: ErrorMetadata::new(\n                        ErrorSeverity::Medium,\n                        ErrorCategory::Validation,\n                        false,\n                    ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                     .with_context(\"channel\", &context.channel)\n                     .with_context(\"operation\", &context.operation)\n                     .with_context(\"validation_error\", &e.to_string()),\n                    source: Some(Box::new(e)),\n                })\n            }\n        }\n    }\n\n    async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // Validate outbound messages as well\n        if !payload.is_empty() {\n            match serde_json::from_slice::<serde_json::Value>(payload) {\n                Ok(_) => {\n                    debug!(\n                        correlation_id = %context.correlation_id,\n                        \"Outbound message validation successful\"\n                    );\n                }\n                Err(e) => {\n                    warn!(\n                        correlation_id = %context.correlation_id,\n                        error = %e,\n                        \"Outbound message validation failed\"\n                    );\n                    // For outbound, we might be less strict and just log the warning\n                }\n            }\n        }\n\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"validation\"\n    }\n}\n\n/// Rate limiting middleware to prevent abuse and overload\npub struct RateLimitMiddleware {\n    max_requests_per_minute: u32,\n    request_counts: Arc<RwLock<std::collections::HashMap<String, (u32, Instant)>>>,\n}\n\nimpl RateLimitMiddleware {\n    pub fn new(max_requests_per_minute: u32) -> Self {\n        Self {\n            max_requests_per_minute,\n            request_counts: Arc::new(RwLock::new(std::collections::HashMap::new())),\n        }\n    }\n}\n\nimpl Default for RateLimitMiddleware {\n    fn default() -> Self {\n        Self::new(1000) // 1000 requests per minute by default\n    }\n}\n\n#[async_trait::async_trait]\nimpl Middleware for RateLimitMiddleware {\n    #[instrument(skip(self, payload), fields(\n        middleware = \"rate_limit\",\n        correlation_id = %context.correlation_id,\n        max_rpm = self.max_requests_per_minute\n    ))]\n    async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let key = format!(\"{}:{}\", context.channel, context.operation);\n        let now = Instant::now();\n\n        {\n            let mut counts = self.request_counts.write().await;\n\n            // Clean up old entries (older than 1 minute)\n            counts.retain(|_, (_, timestamp)| now.duration_since(*timestamp).as_secs() < 60);\n\n            // Check current rate\n            let (count, first_request_time) = counts.entry(key.clone()).or_insert((0, now));\n\n            if now.duration_since(*first_request_time).as_secs() < 60 {\n                if *count >= self.max_requests_per_minute {\n                    warn!(\n                        correlation_id = %context.correlation_id,\n                        channel = %context.channel,\n                        operation = %context.operation,\n                        current_count = *count,\n                        max_allowed = self.max_requests_per_minute,\n                        \"Rate limit exceeded\"\n                    );\n\n                    return Err(AsyncApiError::Resource {\n                        message: format!(\n                            \"Rate limit exceeded: {} requests per minute for {}\",\n                            self.max_requests_per_minute, key\n                        ),\n                        resource_type: \"rate_limit\".to_string(),\n                        metadata: ErrorMetadata::new(\n                            ErrorSeverity::Medium,\n                            ErrorCategory::Resource,\n                            true, // Rate limit errors are retryable after some time\n                        ).with_context(\"correlation_id\", &context.correlation_id.to_string())\n                         .with_context(\"rate_limit_key\", &key)\n                         .with_context(\"current_count\", &count.to_string())\n                         .with_context(\"max_allowed\", &self.max_requests_per_minute.to_string()),\n                        source: None,\n                    });\n                }\n                *count += 1;\n            } else {\n                // Reset counter for new minute window\n                *count = 1;\n                *first_request_time = now;\n            }\n        }\n\n        debug!(\n            correlation_id = %context.correlation_id,\n            rate_limit_key = %key,\n            \"Rate limit check passed\"\n        );\n\n        Ok(payload.to_vec())\n    }\n\n    async fn process_outbound(&self, _context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        // No rate limiting for outbound messages\n        Ok(payload.to_vec())\n    }\n\n    fn name(&self) -> &'static str {\n        \"rate_limit\"\n    }\n}\n\n/// Middleware pipeline that processes messages through multiple middleware layers\npub struct MiddlewarePipeline {\n    middlewares: Vec<Box<dyn Middleware>>,\n    recovery_manager: Arc<RecoveryManager>,\n}\n\nimpl MiddlewarePipeline {\n    pub fn new(recovery_manager: Arc<RecoveryManager>) -> Self {\n        Self {\n            middlewares: Vec::new(),\n            recovery_manager,\n        }\n    }\n\n    /// Initialize the middleware pipeline\n    pub async fn initialize(&self) -> AsyncApiResult<()> {\n        debug!(\"Initializing middleware pipeline with {} middlewares\", self.middlewares.len());\n        Ok(())\n    }\n\n    /// Cleanup the middleware pipeline\n    pub async fn cleanup(&self) -> AsyncApiResult<()> {\n        debug!(\"Cleaning up middleware pipeline\");\n        Ok(())\n    }\n\n    /// Health check for the middleware pipeline\n    pub async fn health_check(&self) -> AsyncApiResult<crate::server::ComponentHealth> {\n        Ok(crate::server::ComponentHealth::Healthy)\n    }\n\n    /// Add middleware to the pipeline\n    pub fn add_middleware<M: Middleware + 'static>(mut self, middleware: M) -> Self {\n        self.middlewares.push(Box::new(middleware));\n        self\n    }\n\n    /// Process inbound message through all middleware\n    #[instrument(skip(self, payload), fields(\n        pipeline = \"inbound\",\n        middleware_count = self.middlewares.len(),\n        payload_size = payload.len()\n    ))]\n    pub async fn process_inbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let mut current_payload = payload.to_vec();\n\n        for middleware in &self.middlewares {\n            if !middleware.is_enabled() {\n                debug!(\n                    correlation_id = %context.correlation_id,\n                    middleware = middleware.name(),\n                    \"Skipping disabled middleware\"\n                );\n                continue;\n            }\n\n            debug!(\n                correlation_id = %context.correlation_id,\n                middleware = middleware.name(),\n                \"Processing through middleware\"\n            );\n\n            match middleware.process_inbound(context, &current_payload).await {\n                Ok(processed_payload) => {\n                    current_payload = processed_payload;\n                }\n                Err(e) => {\n                    error!(\n                        correlation_id = %context.correlation_id,\n                        middleware = middleware.name(),\n                        error = %e,\n                        \"Middleware processing failed\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n\n        info!(\n            correlation_id = %context.correlation_id,\n            middleware_count = self.middlewares.len(),\n            final_payload_size = current_payload.len(),\n            \"Inbound middleware pipeline completed successfully\"\n        );\n\n        Ok(current_payload)\n    }\n\n    /// Process outbound message through all middleware (in reverse order)\n    #[instrument(skip(self, payload), fields(\n        pipeline = \"outbound\",\n        middleware_count = self.middlewares.len(),\n        payload_size = payload.len()\n    ))]\n    pub async fn process_outbound(&self, context: &MiddlewareContext, payload: &[u8]) -> AsyncApiResult<Vec<u8>> {\n        let mut current_payload = payload.to_vec();\n\n        // Process in reverse order for outbound\n        for middleware in self.middlewares.iter().rev() {\n            if !middleware.is_enabled() {\n                continue;\n            }\n\n            match middleware.process_outbound(context, &current_payload).await {\n                Ok(processed_payload) => {\n                    current_payload = processed_payload;\n                }\n                Err(e) => {\n                    error!(\n                        correlation_id = %context.correlation_id,\n                        middleware = middleware.name(),\n                        error = %e,\n                        \"Outbound middleware processing failed\"\n                    );\n                    return Err(e);\n                }\n            }\n        }\n\n        Ok(current_payload)\n    }\n}\n\nimpl Default for MiddlewarePipeline {\n    fn default() -> Self {\n        let recovery_manager = Arc::new(RecoveryManager::default());\n        Self::new(recovery_manager)\n            .add_middleware(LoggingMiddleware::default())\n            .add_middleware(MetricsMiddleware::default())\n            .add_middleware(ValidationMiddleware::default())\n            .add_middleware(RateLimitMiddleware::default())\n    }\n}\n\n/// Metrics collected by middleware\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct MiddlewareMetrics {\n    pub uptime: std::time::Duration,\n    pub message_count: u64,\n    pub error_count: u64,\n    pub error_rate: f64,\n    pub avg_processing_time: std::time::Duration,\n}\n`}\n        </File>\n    );\n}\n"],"names":["MiddlewareRs","_jsx","File","name","children"],"mappings":";;;;;AAAe,SAASA,YAAYA,GAAG;EACnC,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,eAAe;AAAAC,IAAAA,QAAA,EACrB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}