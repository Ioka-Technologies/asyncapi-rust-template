{"version":3,"file":"errors.rs.js","sources":["../../template/src/errors.rs.js"],"sourcesContent":["export default function ErrorsRs({ asyncapi }) {\n    // Detect protocols from servers for protocol-specific errors\n    const servers = asyncapi.servers();\n    const protocols = new Set();\n\n    if (servers) {\n        Object.entries(servers).forEach(([_name, server]) => {\n            const protocol = server.protocol && server.protocol();\n            if (protocol) {\n                protocols.add(protocol.toLowerCase());\n            }\n        });\n    }\n\n    return (\n        <File name=\"errors.rs\">\n            {`//! Comprehensive error handling system for AsyncAPI operations\n//!\n//! This module provides a hierarchical error system with:\n//! - Custom error types for different failure scenarios\n//! - Error context and correlation for debugging\n//! - Protocol-specific error handling\n//! - Error recovery and retry mechanisms\n//! - Structured error data for monitoring\n\nuse thiserror::Error;\nuse std::fmt;\nuse uuid::Uuid;\nuse serde::{Deserialize, Serialize};\nuse chrono::{DateTime, Utc};\n\n/// Correlation ID for tracing errors across operations\n#[derive(Debug, Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]\npub struct CorrelationId(pub Uuid);\n\nimpl CorrelationId {\n    pub fn new() -> Self {\n        Self(Uuid::new_v4())\n    }\n}\n\nimpl fmt::Display for CorrelationId {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        write!(f, \"{}\", self.0)\n    }\n}\n\nimpl Default for CorrelationId {\n    fn default() -> Self {\n        Self::new()\n    }\n}\n\n/// Error severity levels for categorization and alerting\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ErrorSeverity {\n    /// Low severity - informational, no action required\n    Low,\n    /// Medium severity - warning, monitoring required\n    Medium,\n    /// High severity - error, immediate attention needed\n    High,\n    /// Critical severity - system failure, urgent action required\n    Critical,\n}\n\nimpl fmt::Display for ErrorSeverity {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorSeverity::Low => write!(f, \"LOW\"),\n            ErrorSeverity::Medium => write!(f, \"MEDIUM\"),\n            ErrorSeverity::High => write!(f, \"HIGH\"),\n            ErrorSeverity::Critical => write!(f, \"CRITICAL\"),\n        }\n    }\n}\n\n/// Error category for classification and handling\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Serialize, Deserialize)]\npub enum ErrorCategory {\n    /// Configuration-related errors\n    Configuration,\n    /// Network and protocol errors\n    Network,\n    /// Message validation errors\n    Validation,\n    /// Business logic errors\n    BusinessLogic,\n    /// System resource errors\n    Resource,\n    /// Security-related errors\n    Security,\n    /// Serialization/deserialization errors\n    Serialization,\n    /// Routing errors\n    Routing,\n    /// Authorization errors\n    Authorization,\n    /// Unknown or unclassified errors\n    Unknown,\n}\n\nimpl fmt::Display for ErrorCategory {\n    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        match self {\n            ErrorCategory::Configuration => write!(f, \"CONFIGURATION\"),\n            ErrorCategory::Network => write!(f, \"NETWORK\"),\n            ErrorCategory::Validation => write!(f, \"VALIDATION\"),\n            ErrorCategory::BusinessLogic => write!(f, \"BUSINESS_LOGIC\"),\n            ErrorCategory::Resource => write!(f, \"RESOURCE\"),\n            ErrorCategory::Security => write!(f, \"SECURITY\"),\n            ErrorCategory::Serialization => write!(f, \"SERIALIZATION\"),\n            ErrorCategory::Routing => write!(f, \"ROUTING\"),\n            ErrorCategory::Authorization => write!(f, \"AUTHORIZATION\"),\n            ErrorCategory::Unknown => write!(f, \"UNKNOWN\"),\n        }\n    }\n}\n\n/// Error metadata for enhanced context and monitoring\n#[derive(Debug, Clone, Serialize, Deserialize)]\npub struct ErrorMetadata {\n    pub correlation_id: CorrelationId,\n    pub severity: ErrorSeverity,\n    pub category: ErrorCategory,\n    pub timestamp: DateTime<Utc>,\n    pub retryable: bool,\n    pub source_location: Option<String>,\n    pub additional_context: std::collections::HashMap<String, String>,\n}\n\nimpl ErrorMetadata {\n    pub fn new(severity: ErrorSeverity, category: ErrorCategory, retryable: bool) -> Self {\n        Self {\n            correlation_id: CorrelationId::new(),\n            severity,\n            category,\n            timestamp: Utc::now(),\n            retryable,\n            source_location: None,\n            additional_context: std::collections::HashMap::new(),\n        }\n    }\n\n    pub fn with_context(mut self, key: &str, value: &str) -> Self {\n        self.additional_context.insert(key.to_string(), value.to_string());\n        self\n    }\n\n    pub fn with_location(mut self, location: &str) -> Self {\n        self.source_location = Some(location.to_string());\n        self\n    }\n}\n\n/// Root error type for all AsyncAPI operations\n#[derive(Error, Debug)]\npub enum AsyncApiError {\n    #[error(\"Configuration error: {message}\")]\n    Configuration {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Protocol error: {message}\")]\n    Protocol {\n        message: String,\n        protocol: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Validation error: {message}\")]\n    Validation {\n        message: String,\n        field: Option<String>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Handler error: {message}\")]\n    Handler {\n        message: String,\n        handler_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Middleware error: {message}\")]\n    Middleware {\n        message: String,\n        middleware_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Recovery error: {message}\")]\n    Recovery {\n        message: String,\n        attempts: u32,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Resource error: {message}\")]\n    Resource {\n        message: String,\n        resource_type: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Security error: {message}\")]\n    Security {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Authentication error: {message}\")]\n    Authentication {\n        message: String,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Authorization error: {message}\")]\n    Authorization {\n        message: String,\n        required_permissions: Vec<String>,\n        user_permissions: Vec<String>,\n    },\n\n    #[error(\"Rate limit exceeded: {message}\")]\n    RateLimit {\n        message: String,\n        retry_after: Option<std::time::Duration>,\n    },\n\n    #[error(\"Context error: {message}\")]\n    Context {\n        message: String,\n        context_key: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Router error: {message}\")]\n    Router {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n}\n\nimpl AsyncApiError {\n    /// Create a new error with the specified message, category, and optional source\n    pub fn new(\n        message: String,\n        category: ErrorCategory,\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    ) -> Self {\n        let (severity, retryable) = match category {\n            ErrorCategory::Configuration => (ErrorSeverity::High, false),\n            ErrorCategory::Network => (ErrorSeverity::High, true),\n            ErrorCategory::Validation => (ErrorSeverity::Medium, false),\n            ErrorCategory::BusinessLogic => (ErrorSeverity::High, true),\n            ErrorCategory::Resource => (ErrorSeverity::High, true),\n            ErrorCategory::Security => (ErrorSeverity::Critical, false),\n            ErrorCategory::Serialization => (ErrorSeverity::Medium, false),\n            ErrorCategory::Routing => (ErrorSeverity::Medium, true),\n            ErrorCategory::Authorization => (ErrorSeverity::High, false),\n            ErrorCategory::Unknown => (ErrorSeverity::Medium, false),\n        };\n\n        let metadata = ErrorMetadata::new(severity, category, retryable)\n            .with_location(&format!(\"{}:{}\", file!(), line!()));\n\n        match category {\n            ErrorCategory::Configuration => AsyncApiError::Configuration {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Network => AsyncApiError::Protocol {\n                message,\n                protocol: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Validation => AsyncApiError::Validation {\n                message,\n                field: None,\n                metadata,\n                source,\n            },\n            ErrorCategory::BusinessLogic => AsyncApiError::Handler {\n                message,\n                handler_name: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Resource => AsyncApiError::Resource {\n                message,\n                resource_type: \"unknown\".to_string(),\n                metadata,\n                source,\n            },\n            ErrorCategory::Security => AsyncApiError::Security {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Serialization => AsyncApiError::Validation {\n                message,\n                field: None,\n                metadata,\n                source,\n            },\n            ErrorCategory::Routing => AsyncApiError::Router {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Authorization => AsyncApiError::Security {\n                message,\n                metadata,\n                source,\n            },\n            ErrorCategory::Unknown => AsyncApiError::Configuration {\n                message,\n                metadata,\n                source,\n            },\n        }\n    }\n\n    /// Get error metadata for monitoring and logging\n    pub fn metadata(&self) -> &ErrorMetadata {\n        match self {\n            AsyncApiError::Configuration { metadata, .. } => metadata,\n            AsyncApiError::Protocol { metadata, .. } => metadata,\n            AsyncApiError::Validation { metadata, .. } => metadata,\n            AsyncApiError::Handler { metadata, .. } => metadata,\n            AsyncApiError::Middleware { metadata, .. } => metadata,\n            AsyncApiError::Recovery { metadata, .. } => metadata,\n            AsyncApiError::Resource { metadata, .. } => metadata,\n            AsyncApiError::Security { metadata, .. } => metadata,\n            AsyncApiError::Context { metadata, .. } => metadata,\n            AsyncApiError::Router { metadata, .. } => metadata,\n            // Authentication, Authorization, and RateLimit don't have metadata\n            _ => panic!(\"Error variant without metadata\"),\n        }\n    }\n\n    /// Check if error is retryable\n    pub fn is_retryable(&self) -> bool {\n        self.metadata().retryable\n    }\n\n    /// Get error severity\n    pub fn severity(&self) -> ErrorSeverity {\n        self.metadata().severity\n    }\n\n    /// Get error category\n    pub fn category(&self) -> ErrorCategory {\n        self.metadata().category\n    }\n\n    /// Get correlation ID for tracing\n    pub fn correlation_id(&self) -> &CorrelationId {\n        &self.metadata().correlation_id\n    }\n\n    /// Add context to error metadata\n    pub fn add_context(&mut self, key: &str, value: &str) {\n        match self {\n            AsyncApiError::Configuration { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Protocol { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Validation { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Handler { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Middleware { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Recovery { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Resource { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Security { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            AsyncApiError::Context { metadata, .. } => {\n                metadata.additional_context.insert(key.to_string(), value.to_string());\n            }\n            // Authentication, Authorization, and RateLimit don't have metadata\n            _ => {}\n        }\n    }\n}\n\n${Array.from(protocols).map(protocol => {\n            const protocolTitle = protocol.charAt(0).toUpperCase() + protocol.slice(1);\n\n            return `\n/// ${protocolTitle} protocol-specific errors\n#[derive(Error, Debug)]\npub enum ${protocolTitle}Error {\n    #[error(\"${protocolTitle} connection error: {message}\")]\n    Connection {\n        message: String,\n        endpoint: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"${protocolTitle} authentication error: {message}\")]\n    Authentication {\n        message: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"${protocolTitle} message error: {message}\")]\n    Message {\n        message: String,\n        message_id: Option<String>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    ${protocol === 'mqtt' ? `\n    #[error(\"MQTT subscription error: {message}\")]\n    Subscription {\n        message: String,\n        topic: String,\n        qos: u8,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"MQTT publish error: {message}\")]\n    Publish {\n        message: String,\n        topic: String,\n        qos: u8,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${protocol === 'kafka' ? `\n    #[error(\"Kafka producer error: {message}\")]\n    Producer {\n        message: String,\n        topic: String,\n        partition: Option<i32>,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Kafka consumer error: {message}\")]\n    Consumer {\n        message: String,\n        topic: String,\n        group_id: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"Kafka offset error: {message}\")]\n    Offset {\n        message: String,\n        topic: String,\n        partition: i32,\n        offset: i64,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${protocol === 'amqp' ? `\n    #[error(\"AMQP channel error: {message}\")]\n    Channel {\n        message: String,\n        channel_id: u16,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"AMQP exchange error: {message}\")]\n    Exchange {\n        message: String,\n        exchange_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"AMQP queue error: {message}\")]\n    Queue {\n        message: String,\n        queue_name: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${(protocol === 'ws' || protocol === 'wss') ? `\n    #[error(\"WebSocket frame error: {message}\")]\n    Frame {\n        message: String,\n        frame_type: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"WebSocket protocol error: {message}\")]\n    Protocol {\n        message: String,\n        expected: String,\n        received: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n\n    ${(protocol === 'http' || protocol === 'https') ? `\n    #[error(\"HTTP status error: {status_code} - {message}\")]\n    Status {\n        message: String,\n        status_code: u16,\n        method: String,\n        url: String,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },\n\n    #[error(\"HTTP timeout error: {message}\")]\n    Timeout {\n        message: String,\n        timeout_duration: std::time::Duration,\n        metadata: ErrorMetadata,\n        #[source]\n        source: Option<Box<dyn std::error::Error + Send + Sync>>,\n    },` : ''}\n}\n\nimpl ${protocolTitle}Error {\n    /// Get error metadata\n    pub fn metadata(&self) -> &ErrorMetadata {\n        match self {\n            ${protocolTitle}Error::Connection { metadata, .. } => metadata,\n            ${protocolTitle}Error::Authentication { metadata, .. } => metadata,\n            ${protocolTitle}Error::Message { metadata, .. } => metadata,\n            ${protocol === 'mqtt' ? `\n            ${protocolTitle}Error::Subscription { metadata, .. } => metadata,\n            ${protocolTitle}Error::Publish { metadata, .. } => metadata,` : ''}\n            ${protocol === 'kafka' ? `\n            ${protocolTitle}Error::Producer { metadata, .. } => metadata,\n            ${protocolTitle}Error::Consumer { metadata, .. } => metadata,\n            ${protocolTitle}Error::Offset { metadata, .. } => metadata,` : ''}\n            ${protocol === 'amqp' ? `\n            ${protocolTitle}Error::Channel { metadata, .. } => metadata,\n            ${protocolTitle}Error::Exchange { metadata, .. } => metadata,\n            ${protocolTitle}Error::Queue { metadata, .. } => metadata,` : ''}\n            ${(protocol === 'ws' || protocol === 'wss') ? `\n            ${protocolTitle}Error::Frame { metadata, .. } => metadata,\n            ${protocolTitle}Error::Protocol { metadata, .. } => metadata,` : ''}\n            ${(protocol === 'http' || protocol === 'https') ? `\n            ${protocolTitle}Error::Status { metadata, .. } => metadata,\n            ${protocolTitle}Error::Timeout { metadata, .. } => metadata,` : ''}\n        }\n    }\n\n    /// Check if error is retryable\n    pub fn is_retryable(&self) -> bool {\n        self.metadata().retryable\n    }\n}\n\nimpl From<${protocolTitle}Error> for AsyncApiError {\n    fn from(error: ${protocolTitle}Error) -> Self {\n        AsyncApiError::Protocol {\n            message: error.to_string(),\n            protocol: \"${protocol}\".to_string(),\n            metadata: error.metadata().clone(),\n            source: Some(Box::new(error)),\n        }\n    }\n}`;\n        }).join('\\n')}\n\n/// Result type alias for AsyncAPI operations\npub type AsyncApiResult<T> = Result<T, AsyncApiError>;\n\n/// Helper macros for creating errors with context\n#[macro_export]\nmacro_rules! config_error {\n    ($msg:expr) => {\n        AsyncApiError::Configuration {\n            message: $msg.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $source:expr) => {\n        AsyncApiError::Configuration {\n            message: $msg.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: Some(Box::new($source)),\n        }\n    };\n}\n\n#[macro_export]\nmacro_rules! validation_error {\n    ($msg:expr) => {\n        AsyncApiError::Validation {\n            message: $msg.to_string(),\n            field: None,\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $field:expr) => {\n        AsyncApiError::Validation {\n            message: $msg.to_string(),\n            field: Some($field.to_string()),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n}\n\n#[macro_export]\nmacro_rules! handler_error {\n    ($msg:expr, $handler:expr) => {\n        AsyncApiError::Handler {\n            message: $msg.to_string(),\n            handler_name: $handler.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::BusinessLogic,\n                true,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: None,\n        }\n    };\n    ($msg:expr, $handler:expr, $source:expr) => {\n        AsyncApiError::Handler {\n            message: $msg.to_string(),\n            handler_name: $handler.to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::BusinessLogic,\n                true,\n            ).with_location(&format!(\"{}:{}\", file!(), line!())),\n            source: Some(Box::new($source)),\n        }\n    };\n}\n\n/// Error conversion utilities\nimpl From<serde_json::Error> for AsyncApiError {\n    fn from(error: serde_json::Error) -> Self {\n        AsyncApiError::Validation {\n            message: format!(\"JSON serialization/deserialization error: {}\", error),\n            field: None,\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Validation,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<anyhow::Error> for AsyncApiError {\n    fn from(error: anyhow::Error) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Configuration error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: None,\n        }\n    }\n}\n\nimpl From<std::env::VarError> for AsyncApiError {\n    fn from(error: std::env::VarError) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Environment variable error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<std::num::ParseIntError> for AsyncApiError {\n    fn from(error: std::num::ParseIntError) -> Self {\n        AsyncApiError::Configuration {\n            message: format!(\"Integer parsing error: {}\", error),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::Medium,\n                ErrorCategory::Configuration,\n                false,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\nimpl From<tokio::time::error::Elapsed> for AsyncApiError {\n    fn from(error: tokio::time::error::Elapsed) -> Self {\n        AsyncApiError::Resource {\n            message: format!(\"Operation timeout: {}\", error),\n            resource_type: \"timeout\".to_string(),\n            metadata: ErrorMetadata::new(\n                ErrorSeverity::High,\n                ErrorCategory::Resource,\n                true,\n            ),\n            source: Some(Box::new(error)),\n        }\n    }\n}\n\n`}\n        </File>\n    );\n}\n"],"names":["ErrorsRs","asyncapi","servers","protocols","Set","Object","entries","forEach","_name","server","protocol","add","toLowerCase","_jsx","File","name","children","Array","from","map","protocolTitle","charAt","toUpperCase","slice","join"],"mappings":";;;;;AAAe,SAASA,QAAQA,CAAC;AAAEC,EAAAA,QAAAA;AAAS,CAAC,EAAE;AAC3C;AACA,EAAA,MAAMC,OAAO,GAAGD,QAAQ,CAACC,OAAO,EAAE,CAAA;AAClC,EAAA,MAAMC,SAAS,GAAG,IAAIC,GAAG,EAAE,CAAA;AAE3B,EAAA,IAAIF,OAAO,EAAE;AACTG,IAAAA,MAAM,CAACC,OAAO,CAACJ,OAAO,CAAC,CAACK,OAAO,CAAC,CAAC,CAACC,KAAK,EAAEC,MAAM,CAAC,KAAK;MACjD,MAAMC,QAAQ,GAAGD,MAAM,CAACC,QAAQ,IAAID,MAAM,CAACC,QAAQ,EAAE,CAAA;AACrD,MAAA,IAAIA,QAAQ,EAAE;QACVP,SAAS,CAACQ,GAAG,CAACD,QAAQ,CAACE,WAAW,EAAE,CAAC,CAAA;AACzC,OAAA;AACJ,KAAC,CAAC,CAAA;AACN,GAAA;EAEA,oBACIC,cAAA,CAACC,IAAI,EAAA;AAACC,IAAAA,IAAI,EAAC,WAAW;AAAAC,IAAAA,QAAA,EACjB,CAAA;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAEC,KAAK,CAACC,IAAI,CAACf,SAAS,CAAC,CAACgB,GAAG,CAACT,QAAQ,IAAI;AAC5B,MAAA,MAAMU,aAAa,GAAGV,QAAQ,CAACW,MAAM,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE,GAAGZ,QAAQ,CAACa,KAAK,CAAC,CAAC,CAAC,CAAA;MAE1E,OAAO,CAAA;AACnB,IAAA,EAAMH,aAAa,CAAA;AACnB;AACA,SAAA,EAAWA,aAAa,CAAA;AACxB,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAA,EAAeA,aAAa,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAMV,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAMA,EAAAA,QAAQ,KAAK,OAAO,GAAG,CAAA;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAMA,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAA,EAAOA,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,GAAI,CAAA;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA,IAAA,EAAOA,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,GAAI,CAAA;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAA,CAAO,GAAG,EAAE,CAAA;AACZ;AACA;AACA,KAAA,EAAOU,aAAa,CAAA;AACpB;AACA;AACA;AACA,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcV,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AACpC,YAAA,EAAcU,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA8C,4CAAA,CAAA,GAAG,EAAE,CAAA;AAC9E,YAAcV,EAAAA,QAAQ,KAAK,OAAO,GAAG,CAAA;AACrC,YAAA,EAAcU,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA6C,2CAAA,CAAA,GAAG,EAAE,CAAA;AAC7E,YAAcV,EAAAA,QAAQ,KAAK,MAAM,GAAG,CAAA;AACpC,YAAA,EAAcU,aAAa,CAAA;AAC3B,YAAA,EAAcA,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA4C,0CAAA,CAAA,GAAG,EAAE,CAAA;AAC5E,YAAA,EAAeV,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,GAAI,CAAA;AAC1D,YAAA,EAAcU,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA+C,6CAAA,CAAA,GAAG,EAAE,CAAA;AAC/E,YAAA,EAAeV,QAAQ,KAAK,MAAM,IAAIA,QAAQ,KAAK,OAAO,GAAI,CAAA;AAC9D,YAAA,EAAcU,aAAa,CAAA;AAC3B,YAAcA,EAAAA,aAAa,CAA8C,4CAAA,CAAA,GAAG,EAAE,CAAA;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAA,EAAYA,aAAa,CAAA;AACzB,mBAAA,EAAqBA,aAAa,CAAA;AAClC;AACA;AACA,uBAAA,EAAyBV,QAAQ,CAAA;AACjC;AACA;AACA;AACA;AACA,CAAE,CAAA,CAAA;AACM,KAAC,CAAC,CAACc,IAAI,CAAC,IAAI,CAAC,CAAA;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAA;AAAC,GACa,CAAC,CAAA;AAEf;;;;"}